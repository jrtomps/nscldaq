With Class Chart Export File
I:\LINUX\EVENTFRAMEWORK\EventFramework.omtUnified Method


General Info
Internal Version #, NextClassID, NextClassShapeID, NextRelationShapeID, NextStateID, NextStateShapeID, NextTransitionID, NextTransitionShapeID, NextObjectID, NextObjectShapeID, NextInteractionID, NextInteractionShapeID, NextOperationID, NextAttributeID
***BEGIN_TABLE***
4.71342181021111111160215
***END_TABLE***

Classes
ClassID, Name, Description, Multiplicity, Concurrency, Visibility, Persistence, FileName, Package, Import File, Author, LibraryBaseClass, Invariant, User1, User2, User3, Stereotype, 
***BEGIN_TABLE***
41
52CTCLProcessorpublicTCL0000
53CDAQTCLProcessorProvides a synchronized TCL command.
Inheriting from this class allows you to produce
a TCL command which is synchronized to the
application through the application mutex.
  This member essentially just replaces the
TCLProcessor's registration procedures
and static callback relay.  The static callback
relay will now lock the application mutex prior
to calling operator() and unlock on return
(exception or normal).
publicTCL0000
55CThreadRecursiveMutexProvides a mutex which can be locked in a nested manner by a thread.
The "nested ness'  is managed through the m_nLockLevel and the 
m_OwningThread member.  Atomicity of the otherwise non-atomic 
function is handled by bracketing calls with locks of the mutexe's
own m_MonitorMutex
publicUtilityDAQThreadMutex0010
56CObjectRegistryEncapsulates a registry for a set of uniquely named
objects.   Only the names of the objects are held. 
These are held in an STL map.  The map is keyed by object name and contains a poniter 
to the object. Any object derived from CNamedObject can be registred.  Normally
Named objects which require registry will be derived from CRegisteredObject,
that class' constructor will automatically register the object in the appropriate registry.
publicUtility0000
63CClassifiedObjectRegistryImplements a registry of object registries.  The registries are
in a map which is keyed by the actual object type as determined 
by RTTI.  Note that use of RTTI as well makes it unecessary for
this object registry to be templatized.  Objects can be passed by
reference of type CNamedObject.  No policy decisions are made
as to the granullarity of the registry.  The client is responsible for
making registries.  It wouild be possible to derive a class which
had registration granularity to the type level as by deriving and
wrapping the Add with a create if not yet created sort of 
member.publicUtility0000
64CNamedObjectBase class for all objects in the event management system.publicUtility0000
65CRegisteredObjectEncapsulates objects which self register and 
force name uniqueness.publicUtility0000
67CEventMonitorABC for Event Monitors.  An event monitor provides event
specific logic for waiting for external program events.
oeprator() is expected to wait for an event to occur 
and return to indicate if the event in fact did occur.publicMonitors1000
68CReactorEncapsulates the base class for reactors.
A reactor is an object which responds to an 
event.  This class hierarchy is of necessity slightly
parallel to the Monitor hierarchy.
In additional to the Named Object standard functions,
all monitors must implement:
operator()  - called when the monitor fires.
isMonitorCompatible - to determine if the reactor is
                                  being associated with a compatible
                                  monitor.publicReactors1100
80CLocationMonitorEncapsulates a location monirtor.  
The location monitor watches a volatile memory location 
to satisfy some predicate function object.  Predicates are
objects from classes which implement:
bool operator()(T value)
T is a templated variable of the class.
Such objects are function objects.  The 
Event is firfed when the predicate returns TRUE.
publicMonitors0001
81CPointerPredicateEncapsulates standard predicates for location monitors.
Location monitor predicates are template classes on a type T
They must implement the function:

bool operator()(T nCurrent)

The function returns TRUE if nCurrent satisfies whatever condition 
the predicate is established on the location.
publicMonitors0001
82CFdMonitorMonitors activity on a file descriptor.
A file descriptior can be monitored for the logical
or of any of the following conditions:
Readable
Writable
Exception

Monitoring is done via the select(2) system service.
Note that this can yield some unexpected
results.  For example, in some operating systems,
tape drives are never considered readable without
blocking.publicMonitors0010
83CBufferMonitorMonitor to encapsulate a DAQ<type>Buffer.  The monitor can block 
until the buffer receives data and indicates an event when this happens.
Timeouts are also allowed on the receipt.publicMonitors0011
85CTimerMonitorEncapsulates an event monitor for timers.
Timers can be either repeating or oneshot.
A oneshot timer willl fire once after a delay and 
then refuse to fire until it's time is reset.

Repeating timers essentially reset their time after
each instance of an event.publicMonitors0010
86CLocationReactorReacts to location monitor events.  A location
monitor monitors a Specific volatile object for
various abstract conditions checked by a predicate.
This is an abstract base class which must be derived
for a particular applciation.  The purpose of this class
is to provide a branch in the Reactor class hierarchy
from which Location Monitors can determine comptibility
of the reactor.
publicReactors1000
87CFdReactorBase class for file descriptor reactors:
Fd reactors react to events on a file descriptor.
This abstract base class must be subclassed by the
programmer to provide application specific behavior.
publicReactors1000
88CBufferReactorBase class for SpectroDaq buffer receipt.
This object must be subclassed to provide
application specific processing.publicReactors1000
111CEventEncapsulates event handling.  Events consist of an
event monitor which is responsible for determining when
an event fires and a reactor which provides application
specific handling of the event.  
When enabled, the event will schedule a thread m_EventThread
to process the event.  The event thread contains code to
repeatedly calll the monitor's operator(), lock the global mutex
and call the reactor's operator().  The reactors provided with 
classes derived from this are generally standardized to invoke
Subclass virtual function which are specific to the event
being managed..publicEvents0000
112CEventContainerEncapsulates multiple events.
This serves as a lightweight event manager
for the application.

Additional types:
CEventContainer::iterator  - Iterates through the underlying 
                                           STL container m_Events
EventMatchPredicate:
   Function objects which implement:
   bool operator()(CEvent& rEvent)

Predefined Predicate:
    MatchAll - returns TRUE unconditionally
    MatchName(const string& rname)  - matches events of this name.
    MatchType(CEvent& rEvent)         - Match all events of same type as sample
                                                            IF sample is in the container matches it as well.publicEvents0010
113CApplicationEncapsulates a user application.
Entry is at operator()
This object is a singleton object, however, 
due to the way SpectroDaq works, it must
be declared somewhere.  Note that multiple
declarations will result in an exception.
The static member function GetApplication
can retrieve the application.
The user builds a SpectroDaq client
by subclassing this object. operator()
in general will fill the event container with
events and their application specific responses.
The operator() then blocks.
publicApplicationDAQRocNode1000
114CLocationEventEncapsulates application level location monitor event
processing. The CLocation event contains a special 
CLocationReactor which understands that it lives
inside a CLocation event.  It gathers typicallly needed
information from the event monitor and passes it
back to the location event's operator() member.

This class must be subclassed with operator() filled in.
Note that information sufficent to start a location monitor
is passed in at construction time.. this is an abstract,templated
class.publicEvents1001
115CFileEventAbstract base class providing functionality for 
file descriptor events.  Must be derived and 
operator() implemented to provide application
functionality.
publicEvents1100
116CBufferEventProvides an ABC for building
application level objects to react to
SpectroDaq Buffers.  This is an abstract,
templated class which is templated by the
type of buffer whch can be received.
Note that depending on how this is constructed,,
The object can handle alarm events instead
of data buffers.
publicEvents1101
120CChangedPredicateDefines a pointer predicate which is satisfied 
whenever the current value changes.publicMonitors0001
121CMaskedValuePredicateDoes a comparison with a value given a set of
significant bits.  Note that one of the constructors makes
all bits signiificant, effectively making this a match of value.publicMonitors0011
124CAlarmMonitorPerforms all of the operations which
CBufferMonitor performs, however the
links are programmed as alarm receivers.publicMonitors0000
158CEventThreadEncapsulates a thread for monitoring events.
Each Event thread instance contains an event monitor, and an
event.
When the thread is scheduled (via Start), it executes a
loop which invokes the operator() function of the monitor.
when the monitor indicates an event has fired, the Event's 
OnEvent function is called.  OnEvent presumably
Synchronizes with the application, invokes it's reactor
and ends the synchronization pass.publicEvents0010
254DAQThreadpublicSpectrodaq0000
255CEventLoopEncapsulates within a thread an application library which 
runs it's own event loop.  Examples are Xt and Tcl/Tk.
These systems include their own mechanisms for detecting and
dispatching events to application and framework specific code.

   Attempting to instantiate more than one instance of an event 
loop derived object results in a CDuplicateSingelton
exception.
Event loop derived processes implement operator() to 
initiate an event loop  how they are used depends on the
iindividual framework.  Each of these event loops is
supposed to ensure that event dispatching to application
level code is synchronized through the application's mutex.
It is legal to synchronize all such events or an "appropriate
subset".publicVirtualEventLoops1000
256CXtEventLoopEncapsulates an occurance of an Xt event loop.  
The main loop synchronizes the event loop thread
with the application each pass through the 
xt event loop e.g. the event loop looks like:

while(1) {
   XtGetEvent()
   LockMutex()
   XtDispatchEvent();
   UnlockMutex();
  yield();                         // Let someone else run.
}

This implies that work procedures and timer procs are
also synchonrized to the application.
Note that this synchronization can be costly if there
are work procedures continuously active.publicVirtualEventLoops0000
257CInterpreterStartupEncapsulates interfaces for starting up 
TCL based interpreter event loops.  The
TCL interpreter executes within a thread.
Adding a command  to the interpreter should
be done by subclassing  CDAQTCLProcessor,
instantiating an object for that class, and registring
it on the current interpreter.  It is important that DAQTCLProcessor
objects be used rather than TCLProcessor objects since  DAQTCLProcessor
is thread-aware and will therefore synchronize its action through the application's
global mutex.
publicVirtualEventLoops1000
258CTCLInterpreterStartupStarts up a TCL interpreter.  This is suitable for applications
which do not require or cannot use a GUI.
publicVirtualEventLoops0000
259CTKInterpeterStartupEncapsulates the startup of a Tk/wish interpreter.
An application must subclass this, Implement
RegisterExtensions.
publicVirtualEventLoops0000
469CTCLInterpreterpublicTCL0000
470CTCLProcessorpublic1000
518CTCLSynchronizeCommandImplements a Tcl command extension
sync {script}

The script parameter is simply evaluated.
Since this class is derived from CDAQTCLProcessor, however
the script is executed syncrhonized to the application's global mutex.publicTCL0010
519CSocketEncapsulates a generalized TCP/IP SOCK_STREAM
socket. 
  Note that TCP/IP Sockets can come in two flavors:
Clients and Servers.  Clients must perform a connect,
while servers perform a bind, listen and then serveral
accepts to create 'server instances'.
The state of a socket is maintained in the m_State
variable and is from the enumerator:
CSocket::State

Disconnected  - The socket is not connected to anything.
Bound              - The socket is a server socket which is
                           not connected, but has been bound to
                           a service port.
Listening           - The socket is a server port which is
                            listening and can therefore accept
                            connections
Connected        - The socket is either a client or a 
                            server instance and is connected
                            to it's counterpart.
publicTCP0010
520CServerConnectionEventEncapsulate a TCP/IP server accepting connections.
Each connection accepted can be validated by the
operator() member function.   If the connection is 
validated a new CServerInstance is created to 
process the conneciton.  The CServer Instance 
is created by cloning a sample 'reference' instance
provided at construction time.publicTCP0010
522CServerInstanceEncapsulates an instance of a TCP/IP server
connected to a client.
The server has an FdMonitor watching for activity
on the client's socket. It's reactor gathers information to pass to
operator()
  Note that a 'reference' version of this object is handed to
the ServerConnectionEvent representing the listening component
of this server.  This instance is cloned onto the server socket.
The serversocket is owned by the server instance and must
be destroyed when it is.publicTCP1000
670CClassifiedObjectRegistryImplements a registry of object registries.  The registries are
in a map which is keyed by the actual object type as determined 
by RTTI.  Note that use of RTTI as well makes it unecessary for
this object registry to be templatized.  Objects can be passed by
reference of type CNamedObject.  No policy decisions are made
as to the granullarity of the registry.  The client is responsible for
making registries.  It wouild be possible to derive a class which
had registration granularity to the type level as by deriving and
wrapping the Add with a create if not yet created sort of 
member.public0000
950CServerMonitorMonitors a TCP/IP socket for connection
requests.  When a connection request is
available, returns.  Note that it is up to
the reactor to actually accept the connection
request.  ServerMonitors can have
monitors which are descended from CFdMoniitors
publicMonitors0010
***END_TABLE***

Class Shape
ShapeID, PosX, PosY, TopText, MiddleText, BottomText, ClassDataID, ClassType, Abstract, Template, Interface, Final
***BEGIN_TABLE***
5242030CTCLProcessor52000000
69184010CNamedObjectm_sName:m_sClassPathDescribeSelf:AppendClassInfo64000000
954209090CClassifiedObjectRegistryCreateRegistry:DeleteRegistry:Add:Remove:Find:Find$:beginregistry:endregistry:DescribeSelf670000000
701840180CRegisteredObjectRegisterSelf65000000
958393070CThreadRecursiveMutexm_Mutex:m_tOwningThread:m_nLockLevel:m_MonitorMutexLock:UnLock:TryLock:isLocked:UnLockCompletely55000110
90260020CEventMonitorm_tvTimeout:m_fTimedWaitoperator():isReactorCompatible:setTimeout67100010
942480200CBufferMonitorm_Buffer:m_lLinksoperator():AddLink:RemoveLink:RemoveLink$:FindLink:beginLinks:endLinks:getBufferPointer:SetBufferTag:SetBufferMask:DescribeSelf:isReactorCompatible83010100
962790190CTimerMonitorm_fOneShot:m_fFiredoperator():Repeat:setTimeout:DescribeSelf:isReactorCompatible85000100
912950200CLocationMonitorm_pTLocationChangePredicate:operator():ChangeLocation:DescribeSelf:isReactorCompatible80010000
1522480530CAlarmMonitorAddLink124000000
922600600CPointerPredicateoperator()81010000
1482490760CChangedPredicatem_TOldValueoperator():DescribeSelf120010000
1492710760CMaskedValuePredicatem_TMask:m_TValueoperator():DescribeSelf121010100
993190310CLocationReactorisMonitorCompatible86100000
97336080CReactoroperator():isMonitorCompatible681010121024
1013570310CBufferReactorisMonitorCompatible88100000
1003390310CFdReactorisMonitorCompatible87100000
1374340170CReactoroperator():isMonitorCompatible6810101258
138444020CEventMonitorm_tvTimeout:m_fTimedWaitoperator():isReactorCompatible:setTimeout6710001258
1364120240CEventm_fEnabledOnEvent:ReplaceMonitor:ReplaceReactor:Enable:Disable:DescribeSelf111000000
932330200CFdMonitorm_nFd:m_nConditionMask:m_fLastEventMaskMonitorReadable:MonitorWritable:MonitorExceptions:operator():DescribeSelf:isReactorCompatible82000100
14072330430CServerMonitorm_Socketoperator():DescribeSelf950000100
2044140760CClassifiedObjectRegistryCreateRegistry:DeleteRegistry:Add:Remove:Find:Find$:beginregistry:endregistry:DescribeSelf63000010
1414040420CLocationEventoperator()114110000
1434250420CBufferEventoperator()116111000
1424150420CFileEventoperator()115101000
2054440260CEventThreadm_fStopSoon:m_fRunningStart:Stop158000100
7354360420CServerConnectionEventm_ReferenceInstanceoperator()520000100
7364470540CSocketm_Fd:m_StateConnect:Bind:Listen:Accept:Shutdown:Read:Write:getPeer:OOBInline:isOOBInline:setRcvLowWaterMark:getRcvLowWaterMark:setSndLowWaterMark:getSndLowWaterMark:setRcvTimeout:getRcvTimeout:setSndTimeout:getSndTimeout:Debug:isDebug:SetNotRoutable:isNotRoutable:setSndBufSize:getSndBufSize:setRcvBufSize:getRcvBufSize:setLinger:getLinger5190001124394
7384310580CServerInstanceOnStartup:clone522100000
1393920460CEventContainerAddEvent:RemoveEvent:RemoveEvent$:FindEvent:FindEvent$:beginEvents:endEvents:EnableEvents:DisableEvents:DescribeSelf112000100
9571590360CEventm_fEnabledOnEvent:ReplaceMonitor:ReplaceReactor:Enable:Disable:DescribeSelf1110000120083
14081710360CEventContainerAddEvent:RemoveEvent:RemoveEvent$:FindEvent:FindEvent$:beginEvents:endEvents:EnableEvents:DisableEvents:DescribeSelf1120001124394
731910360CReactoroperator():isMonitorCompatible68101000
1531810600CPointerPredicateoperator()81010010
721620600CEventMonitorm_tvTimeout:m_fTimedWaitoperator():isReactorCompatible:setTimeout67100000
14092060600CApplicationm_InstanceGetInstance:DescribeSelf11310001263
1403930790CApplicationm_InstanceGetInstance:DescribeSelf113100000
348493060DAQThread254000000
3494930160CEventLoopm_pTheInstancegetInstance:operator()255100000
663520060CTCLInterpreter469000000
7304830580CTCLSynchronizeCommandoperator()518000100
3514740270CXtEventLoopm_TopLevelInitializeApplication:SetupApplicationResources:SetupWidgetTree:operator()256000000
6644920270CTCLProcessor470100000
3525160400CInterpreterStartupOnIniitialize:RegisterExtensions:operator()257100000
8824870400CDAQTCLProcessorRegister:EvalRelay:DeleteRelay530000124931
203112020CNamedObjectm_sName:m_sClassPathDescribeSelf:AppendClassInfo64000010
581210220CObjectRegistryAdd:Remove:Remove$:Find:begin:end:DescribeSelf56000000
53400190CDAQTCLProcessorRegister:EvalRelay:DeleteRelay53000000
67890220CClassifiedObjectRegistryCreateRegistry:DeleteRegistry:Add:Remove:Find:Find$:beginregistry:endregistry:DescribeSelf63000000
734581060CSocketm_Fd:m_StateConnect:Bind:Listen:Accept:Shutdown:Read:Write:getPeer:OOBInline:isOOBInline:setRcvLowWaterMark:getRcvLowWaterMark:setSndLowWaterMark:getSndLowWaterMark:setRcvTimeout:getRcvTimeout:setSndTimeout:getSndTimeout:Debug:isDebug:SetNotRoutable:isNotRoutable:setSndBufSize:getSndBufSize:setRcvBufSize:getRcvBufSize:setLinger:getLinger519000100
5640200CThreadRecursiveMutexm_Mutex:m_tOwningThread:m_nLockLevel:m_MonitorMutexLock:UnLock:TryLock:isLocked:UnLockCompletely55000100
3535060590CTCLInterpreterStartupoperator():Tcl_Init258000000
3545220590CTKInterpeterStartupoperator():Tk_Init259000000
***END_TABLE***

Attributes
ClassID, ClassName, AttrID, Name, Type, Length, IsStatic, Description, Visibility, MaxVal, MinVal, InitVal, Stereotype, Constraint, IsConstant, IsIndexed, IsUnique, IsNotNull, IsPrimaryKey, IsForeignKey, User1, User2, User3, IsArray, IsFinal, IsWriteProperty, IsReadProperty
***BEGIN_TABLE***
55CThreadRecursiveMutex14m_MutexDAQThreadMutex0Mutex locked.private0000000This is the mutex which will be locked to produce the 
thread synchronization at levels more global than the
mutex operations itself... e.g. this is the mutex each thread
is trying to lock.0000
55CThreadRecursiveMutex71m_tOwningThreaddaqthread_t0Id of owning thread. private0if(m_LockLevel < 0) m_OwningThread = NULL;000000This value is only valid if m_LockLevel > 0.
In that case it represents the owner of the
mutex.  The owner of the mutex is used to
determine if a lock should result in an 
actual lock request or merely an increment
of the locklevel.0000
55CThreadRecursiveMutex72m_nLockLevelunsigned0Locking depth for owning thread.private0m_nLockLevel >= 0000000Each time a thread locks a mutex, the lock level increments actual final unlocking 
only occurs when the m_nLockLevel goes to zero.0000
55CThreadRecursiveMutex96m_MonitorMutexDAQThreadMutex0Atomicity Mutex.private0000000member is used to force otherwise non-atomic members to execute atomically
with respect to the mutex represented by this object.0000
64CNamedObject67m_sNamestring0Object name.private100000The name of this object, as assigned at creation time.0000
64CNamedObject68m_sClassPathstring0Class derivation.private0000000Class derivation as determined by at
construction time by recursing the
typeinfo tree.0000
67CEventMonitor109m_tvTimeouttimeval0Timeout lengthprivate0000000contains the timeout if timeouts are enabled else indeterminate.0000
67CEventMonitor110m_fTimedWaitbool0Timed wait?private0000000if TRUE, waits for events are timed,
else they are determined by the timeout.0000
80CLocationMonitor74m_pTLocationvolatile T*0Location monitoredprivate0000000Points to the location monitored. This location is
assumed to be changing asynchronously to the 
execution of the thread which monitors the location.
Note that the pointer can point to any type which can be
accepted by the predicate.   For the predefined predicates:
CChangedPredicate:        Requiires operator== be implemented fo rT
                                                        CopyConstruction
CMaksedValuePredicate Requires:   operator&,
                                                          operator==
                                                          Copy construction:
CisValuePredicate Require:     opreator==
                                                CopyConstruction0000
82CFdMonitor79m_nFdint0File descriptorprivate0000000File descriptor which will be monitored by the 
monitor.0000
82CFdMonitor80m_nConditionMaskUInt_t0Monitored conditions.private0000000Conditions which will be monitored by the 
monitor for the file descriptor.  This will
be a mask of the bits:
FD_READABLE
FD_WRITABLE
FD_EXCEPTION

These bits are defined
as members of the public bit-field strructure:
CFdMonitor::FdConditions
0000
82CFdMonitor100m_fLastEventMaskint0last set of file events.private0000000Mask of the last set of events to be detected on a 
file.  This is calculated from the select() service, and
does not necessarily reflect the actual state. e.g.
if an fd is readable and writable, but only readability
was monitored, this mask will contain FD_READABLE
not FD_READABLE | FD_WRITABLE0000
83CBufferMonitor106m_BufferDAQBuffer<T>0Encapsulated bufferprivate000000Contains the buffer which is to be managed by this 
monitor.  All data received is received into this buffer.0000
83CBufferMonitor108m_lLinkslist<CBufferMonitor::LinkInfo>0List of links.private0000000Contains a list of LinkInfo data structures 
which describe the current set of links.
For each link the following is maintained:
int Tag      - The tag associated with the link.
int Mask    - The mask associated with the link.
string URL - The URL defining the source system.
int linkid     - The id which identifies the link to the
                    spectrodaq link manager object.0000
85CTimerMonitor84m_fOneShotbool0Oneshot flagprivate0000000This flags indicates whether or not the timer is a
One-shot timer or a Recurring timer.0000
85CTimerMonitor112m_fFiredbool0Fired flagprivate0000000If m_fOneShot is true, this flag is used
to indicate whether or not the timer has fired
already.0000
111CEvent91m_fEnabledbool0Event enabled flag.privateFALSE000000TRUE if the event is enabled and actively monitoriing
FALSE if the event is disabled or disable pending.0000
113CApplication116m_InstanceCApplication*1Meprivate0000000Static member data:
If an application instance has been created,
this points to it, otherwise it is null.0000
120CChangedPredicate75m_TOldValueT0Prior value.private00000000000
121CMaskedValuePredicate76m_TMaskT0mask anded with value.private00000000000
121CMaskedValuePredicate77m_TValueT0Value compared with.private00000000000
158CEventThread90m_fStopSoonBOOL0Stop FlagprivateFALSE000000When set, at the next opportunity, the 
event thread will exit.  Note that the
thread object will not be destroyed.
0000
158CEventThread113m_fRunningBOOL0Thread active indicatorprivateFALSE000000TRUE if the thread is already running
FALSE otherwise.0000
255CEventLoop93m_pTheInstanceCEventLoop*1Singleton instanceprivate0000000Contains  a pointer to the single
event loop instance allowed.  If
there are no instances of the singleton,
this pointer is null.  Note that GetInstance
will not attempt to create a new instance
since it does not know which element of the
class hierarchy to create. 0000
256CXtEventLoop118m_TopLevelWidget0Top level widgetprivate0000000Top level shell widget created
by the InitializeApplication member.
0000
519CSocket94m_Fdint0Socketprivate0000000A CSocket is create by construction.
This member variable contains the
file descriptor associated with the socket.
0000
519CSocket95m_StateCSocket::State0State of socket.private0000000Describes the current state of the socket.
This is taken from the enum:
CSocket::State and can be:
Disconnected  - The socket is not connected to anything.
Bound              - The socket is a server socket which is
                           not connected, but has been bound to
                           a service port.
Listening           - The socket is a server port which is
                            listening and can therefore accept
                            connections
Connected        - The socket is either a client or a 
                            server instance and is connected
                            to it's counterpart.
0000
520CServerConnectionEvent115m_ReferenceInstanceCServerInstance0Reference Serverprivate0000000This member is cloned to produce a server instance
executing on a connection.0000
950CServerMonitor114m_SocketCSocket&0Associated Socketprivate0000000Socket object which represents the 
server listen socket.0000
***END_TABLE***

Operations
ClassID, ClassName, OperID, OperName, Return Type, Post Condition, PreCondition, Invariant, Stereotype, Classification, Exception, Transformation, Concurrency, Visibility,  Comment1, Comment2, Comment3, IsStatic, IsConstant, IsPureVirtual, IsVirtual, IsProcedure, IsInline, IsEvent, IsOverride, Message, IsFinal, IsSynchronized, IsNative, IsFriend
***BEGIN_TABLE***
53CDAQTCLProcessor454RegistervoidTcl Interface.publicRegisters the processor on the current interpreter.000110000000
BEGIN_CODE

END_CODE
53CDAQTCLProcessor455EvalRelayintpublicLocks the application mutex, calls
operator() and the unlocks the resource.100010000000
BEGIN_CODE

END_CODE
53CDAQTCLProcessor456DeleteRelayvoidpublicLocks the application mutex, call's
the object's OnDelete member function
(the object is pointed to by the client data
parameter), and unlocks the mutex.100010000000
BEGIN_CODE

END_CODE
55CThreadRecursiveMutex457LockintOverride.publicLocks the mutex.  Returns zero on success,
otherwise, errno has the reason for the failure.
Note that if we own the mutex the lock level is
incremented, otherwise, this function may block.000010010000
BEGIN_CODE

END_CODE
55CThreadRecursiveMutex458UnLockintOverridepublicUnlocks a locked mutex.  If the mutex is already locked by us,
the lock level is decremented.  The mutex is not actually released
until the lock level goes to zero.  If we don't own the mutex, and
error results.
Returns zero on success,
otherwise, errno has the reason for the failure.000010010000
BEGIN_CODE

END_CODE
55CThreadRecursiveMutex459TryLockintOverridepublicTries to lock the mutex. 
 If the mutex is owned by the running thread
the lock succeeds and the lock level is incremented.
If the lock level is zero, then trylock is done on the
base class and the result is returned.  On success, the
lock level is incremented.
Returns 0 on success, otherwise, errno has reason for
failure.000010010000
BEGIN_CODE

END_CODE
55CThreadRecursiveMutex460isLockedintOverride.publicReturns non zero if someone, anyone (even self()) owns the mutex.
Note that the mutex is considered owned if the lock level is 
nonzero.  This should even be faster than the base class 
implementation.000010010000
BEGIN_CODE

END_CODE
55CThreadRecursiveMutex461UnLockCompletelyvoidpublicReleases all lock levels.  If we don't 
already own the mutex, this call is a no-op,
otherwise, the m_nLockLevel variable is set to
zero and the underlying semaphore is unlocked.000010000000
BEGIN_CODE

END_CODE
56CObjectRegistry462AddvoidMutatorpublicRegisters its parameter in the registry.
If the name is already present in the map,
CDuplicateNameException is thrown.000010001000
BEGIN_CODE

END_CODE
56CObjectRegistry463RemovevoidMutatorpublicRemoves an object from the registry.
This version locates an object by name
and removes it from the registry.  If the object
does not exist the CNoSuchObject exception
is thrown.000010001000
BEGIN_CODE

END_CODE
56CObjectRegistry464Remove$voidMutatorpublicRemoves an object from the registry.
This version locates an object by a reference
tot he object and removes it from the registry.  If the object
does not exist the CNoSuchObject exception
is thrown.000011001000
BEGIN_CODE
Remove(rObject.getName());
END_CODE
56CObjectRegistry465Findconst ObjectRegistryIteratorSelectorpublicLocates the object described by the input string.
If there is no such object then CNoSuchObject is
thrown.  Note that a const iterator is returned.
To get a non-const iterator,  clients will need
to use the STL find algorithm, with begin and end
iterators produced by this class.010010001000
BEGIN_CODE

END_CODE
56CObjectRegistry466beginObjectIteratorSelector/indirect mutatorpublicReturns an iterator which 'points' to the first object in the
registry.  Traversing the registry through this iterator will
visit all objects in name alphabetical order.
ObjectIterator is a typedef for:
map<string,CNamedObject*>::iterator000010001000
BEGIN_CODE

END_CODE
56CObjectRegistry467endObjectIteratorSelector.publicReturns an iterator which 'points' off the end of
the m_Registrants map.  Provided to allow
clients to know when to terminate iteration through
the objects.000010001000
BEGIN_CODE

END_CODE
56CObjectRegistry468DescribeSelfstringSelectorpublicReturns a string which describes the registry.
The string is of the form:

CNamedObject::DescribSelf()
Objects in the registry:
   <Each object is asked to describe itself>
000110010000
BEGIN_CODE

END_CODE
63CClassifiedObjectRegistry469CreateRegistryvoidMutatorpublicCreates a new registry. It is not an error
to create a registry which already exists.
If this is attempted, it is a no-op.000010001000
BEGIN_CODE

END_CODE
63CClassifiedObjectRegistry470DeleteRegistryvoidMutatorpublicDelete an existing registry. Any registry entries
are destroyed, however the objects they point to
are not.
Attempts to destroy an nonexsitent registry
result in a NoSuchObject exception.000010001000
BEGIN_CODE

END_CODE
63CClassifiedObjectRegistry471Addvoidbase class mutator.publicAdds an item to a registry.
If the item already exists in that registry,
a DuplicateName exception is thrown.
If the registry does not exist a 
NoSuchObject exception is thrown.000110000000
BEGIN_CODE

END_CODE
63CClassifiedObjectRegistry472Removevoidbase class mutatorpublicThe named object is removed from the designated registry.
If the object does not exist, or the registry does not exist,
a NoSuchObject exception is thrown. The name embedded
in the exception differentiates between these two cases.
000110000000
BEGIN_CODE

END_CODE
63CClassifiedObjectRegistry473FindObjectRegistryIteratorSelectorpublicLocates an object in a specific registry.
If the registry or object don't exist a
NoSuchObject exception is thrown.
000010001000
BEGIN_CODE

END_CODE
63CClassifiedObjectRegistry474Find$CRefcountedPtr<ObjectList>SellectorpublicReturns a referece counted pointer to
a dynamically allocated list of Objects which
match the name requested.
ObjectList is a typedef for:
list<CNamedObject*>
The list is drawn from all of the registries.
If no registries contain the requested name,
an empty list is returned.000010000000
BEGIN_CODE

END_CODE
63CClassifiedObjectRegistry475beginregistryRegistryIteratorSelectorpublicReturns an iterator into the registries which
are contained by this object.  Note that iteratiing
will return registries... that is RegistryIterator is a
typedef for:

map<string,CObjectRegistry>::iterator000010001000
BEGIN_CODE

END_CODE
63CClassifiedObjectRegistry476endregistryRegistryIteratorSelectorpublicReturns a registry iterator suitable for determining
when iteration has been completed
(e.g. while(p != coreg.endregistry()) {...
  p++;
}000010001000
BEGIN_CODE

END_CODE
63CClassifiedObjectRegistry477DescribeSelfstringSelectorpublicDescirbes self.  This produces a string of the form:

CNamedObject::DescibeSelf()
"  Registries defined: "  List of registries
"     Registry " <name>"  Contains:   <- for all registries.
          Registry::DescribeSelf000110000000
BEGIN_CODE

END_CODE
64CNamedObject478DescribeSelfstringSelectorpublicReturns a string decribing what is known about 
the object.  In this case, the string is of the
form:
>>>>>>>>>>>>>>>>>>><<<<<<<<<<<<<<<<<<<
Object of type m_sClassPath named m_sName000110000000
BEGIN_CODE

END_CODE
64CNamedObject479AppendClassInfovoidConstruction helperprotectedCalled down through the construction chain
to build up the m_sClassPath string.000110001000
BEGIN_CODE

END_CODE
65CRegisteredObject480RegisterSelfvoidInteractorpublicRegisters this object in the appropriate object
registry.  Note: the object registry will throw
a DuplicateName exception if there is already
an object in our registry with that name.
If necesary, the registry is created.

Implicit parameters:
   m_Registry - a static member which is the collection
                       of object registries into which the object
                      will be registered.
   m_sName  - The name under which the object
                       will be registered.
000010001000
BEGIN_CODE

END_CODE
67CEventMonitor481operator()CEventMonitor::resultInterfacepublicMonitor for the occurance of an event.
Concrete classes must implement this.
Return values are from the enum:

CEventMonitor::result:

Occured   - The event happened.
TimedOut -  The event monitor supports timeouts
                    and the timeout fired.
Error         -  An error condition was encountered
                   waiting for the event.
001110000000
BEGIN_CODE

END_CODE
67CEventMonitor482isReactorCompatibleboolInterfacepublicDetermines if a reactor can be applied to
an event monitor.  That is if a reactor is of
a type which can successfully interact with
an event monitor.  This must be implemented
by the concrete classes themselves.001110000000
BEGIN_CODE

END_CODE
67CEventMonitor483setTimeoutvoidmutatorpublicSets the timeout.  The length of the timeout is
determined by the parameter in ms..  Special values:

0   - Poll (return instantly).
FOREVER - Block until event.
000110000000
BEGIN_CODE

END_CODE
68CReactor484operator()voidInterface DefinitionpublicThis method is called in response ot an event
from an event monitor on which this reactor
has been established.  The Reactor provides 
application specific procesing of the event.001110000000
BEGIN_CODE

END_CODE
68CReactor485isMonitorCompatibleBOOLinterface.publicDetermines if the monitor passed in
is compatible with us.   Base class
default functionality is to return TRUE.000110000000
BEGIN_CODE

END_CODE
80CLocationMonitor486ChangePredicatevoidMutator.publicAssociates a new predicate with the 
location monitor.000010000000
BEGIN_CODE

END_CODE
80CLocationMonitor487operator()CEventMonitor::resultsbehavior override.publicReads the current value of the location and passes it to the predicate.
Returns:
1. Occured - if the predicate returned TRUE
2. TimedOut - if the wait time for this event timedout.
3. Error         - If the predicate threw an exception.000110000000
BEGIN_CODE

END_CODE
80CLocationMonitor488ChangeLocationvoidMutatorpublicChanges the location monitored.000010000000
BEGIN_CODE

END_CODE
80CLocationMonitor489DescribeSelfstringSelectorpublicReturns a string which describes the monitor.  Inlcudes:
1. CEventMonitor::DescribeSelf
2. Dumps of thte pointer value,
3.  m_Predicate.DescribeSelf()
000110000000
BEGIN_CODE

END_CODE
80CLocationMonitor490isReactorCompatibleboolOverride.publicReturns TRUE if the Reactor passed in is a 
valid reactor for location monitors (is an object
descended from CLocationReactor.000110000000
BEGIN_CODE

END_CODE
81CPointerPredicate491operator()boolpublicCalled to evaluate a value by a 
location  monitor.001110000000
BEGIN_CODE

END_CODE
82CFdMonitor492MonitorReadablevoidMutatorpublicSets or clears the FD_READABLE bit in 
m_nConditionMask.000010001000
BEGIN_CODE

END_CODE
82CFdMonitor493MonitorWritablevoidMutatorpublicSets or clears the FD_WRITABLE bit in the
m_nConditionMask attribute.000010001000
BEGIN_CODE

END_CODE
82CFdMonitor494MonitorExceptionsvoidMutatorpublicSets or clears  the FD_EXCEPTION bit
in m_nConditionMask.000010000000
BEGIN_CODE

END_CODE
82CFdMonitor495operator()voidInterface ImplementationpublicImplements a wait for a single file descriptor event
as described in the mask.  Returns one of:
Occured   - one of the masked conditions occured.
TimedOut - Timeout was enabled and none of the
                  conditions occured within the timeout.
Error         - An error condition ocurred.
000110010000
BEGIN_CODE

END_CODE
82CFdMonitor496DescribeSelfstringBehavioral override.publicReturns a string which describes the state of the monitor:

CEventMonitor::DescribeSlef()
    File descriptor = $m_nFd
    Conditions      = <Decoded condition>
    Timeout          = Enabled  at $m_tvTimeout ms | Disabled 
000110010000
BEGIN_CODE

END_CODE
82CFdMonitor497isReactorCompatibleboolinterface implementationpublicIndicates if the passed reactor is compatible with the monitor.  This will be the
case if the reactor is dynamcially castable to a CLocationReactor type.000110010000
BEGIN_CODE
try {
   CFdReactor& r(dynamic_cast<CFdReactor&>(rReactor));
   return TRUE;
}
catch (...) {
   return FALSE;
}
END_CODE
83CBufferMonitor498operator()CEventMonitor::resultoverride.publicWaits for a buffer to be recieved.  Returns 
one of the following:
Occured   - A buffer was received into m_Buffer.
TimedOut - Timeouts were enabled and no buffer
                   was received during the timeout
                   interval (See m_fTimedWait and
                   m_tvTimeout in base class).
000110010000
BEGIN_CODE

END_CODE
83CBufferMonitor499AddLinkintmutatorpublicAdds a link to the link manager.  Note that links
are somewhat independent of buffers.  A link
Buffers are accepted along links, the tag and
mask of each link and buffer combine to determine
what data is receieved into the buffer.  However if
these conditions overlap, it is possible to get some
strange results as for each buffer accepted by the link
at >most< one buffer is allowed to receive it.

The link is inserted in the m_lLinks list of links.
The linkid (from the SpectroDaq link manager) is returned.
On failure, CLinkFailed is thrown.


000110000000
BEGIN_CODE

END_CODE
83CBufferMonitor500RemoveLinkvoidmutatorpublicIf the specified link exists, it is removed from the link list and
deleted from the SpectroDaq link manager.
If the link does not exist, then CNoSuchLink is thrown.
000010000000
BEGIN_CODE

END_CODE
83CBufferMonitor501RemoveLink$voidmutatorpublicRemoves a link given the iterator to
it's link structure in the link list.
If the iterator is end() then
CNoSuchLink is thrown.000010000000
BEGIN_CODE

END_CODE
83CBufferMonitor502FindLinkLinkIteratorSelector (Templated)publicLocates the first link which satisfies a 
given predicate.  Predefined predicates
include:
MatchURL  - Matches a URL only.
MatchAll      - Matches URL, tag and mask.

A LinkMatchPredicate is a function object
implementing:
bool operator()(LinkInfo)
  which returns TRUE if the link satisfies
the predicate.

Returns:
  An iterator 'pointing' to the first match or
end() if there are no matches.000010000000
BEGIN_CODE

END_CODE
83CBufferMonitor503beginLinksLinkIteratorSelectorpublicReturns an iterator to the beginning of the 
links list.000010000000
BEGIN_CODE

END_CODE
83CBufferMonitor504endLinksLinkIteratorselectorpublicReturns an iterator suitable for
determining end of iteration
through the link list e.g.:
LinkIterator p;
for(p = o.beginLinks(); p != o.endLinks(); o++) {
...
}000010000000
BEGIN_CODE

END_CODE
83CBufferMonitor505getBufferPointerDAQBufferPointer<T>Selector (Templatized).publicReturns a pointer to the daq buffer.000010000000
BEGIN_CODE

END_CODE
83CBufferMonitor506SetBufferTagvoidMutator.publicSets the tag matched on receives into the buffer.
For each link/buffer pair, tags are used to determine
which buffers routed through SpectroDaq will be
received by a link or buffer.  The logic is that
at each stage, the routed buffer's tag is anded with
the receiving entity's mask.  If this is equal to the
receiving entity's tag, the buffer is accepted.
So, for a given link (link.mask, link.tag), and
our buffer (buffer.mask, buffer.tag):
A routed buffer rbuffer.tag is received when:

((rbuffer.tag & link.mask) == link.tag) &&
((rbuffer.tag & buffer.mask) == buffer.tag)
000010000000
BEGIN_CODE

END_CODE
83CBufferMonitor507SetBufferMaskvoidMutator.publicSets the receive mask associated with the buffer.
See SetBufferTag for an explanation of tags and masks
and how they interact with link tags and masks and the tag
of the incomming buffer to determine receipt.000010000000
BEGIN_CODE

END_CODE
83CBufferMonitor508DescribeSelfstringSelectorpublicProduces a desciprtion string of the object.  This includes
1. Calling CEventManager::DescribeSelf()
2. Putting out the tag and mask of the buffer.
3. Listing the links and their information.000010000000
BEGIN_CODE

END_CODE
83CBufferMonitor509isReactorCompatibleboolRealityCheck.publicDetermines if the reactor passed in is descended from
a CBufferReactor.  If not, returns FALSE, if so 
Returns TRUE.
000010000000
BEGIN_CODE

END_CODE
85CTimerMonitor510operator()CEventMonitor::resultsOverride behaviorpublicWaits for the timer as follows:
1. If m_fOneshot is false, this function blocks
    for m_tvTimeout time, then returns Occured
2. If m_fOneshot is true, but m_fFired is false,
    blocks for m_tvTimeout, sets m_fFired and
    returns Occured
3. If m_fOneshot and m_fFired are both true,
    returns TimedOut
000110000000
BEGIN_CODE

END_CODE
85CTimerMonitor511Repeatvoidmutator.publicSets m_fOneshot to the value of its
parameter.000010000000
BEGIN_CODE

END_CODE
85CTimerMonitor512setTimeoutvoidMutator.public  Calls CEventMonitor::setTimeout and
clears m_fFired.
  The wait flag FOREVER results in a
MAXINT being passed to CEventMonitor::setTimeout
000110000000
BEGIN_CODE

END_CODE
85CTimerMonitor513DescribeSelfstringselectorpublicProduces a string describing the object:
1. Calls CEventMonitor::DecribeSelf
2. Dumps the state of the oneshot and timed flags.
000110000000
BEGIN_CODE

END_CODE
85CTimerMonitor514isReactorCompatibleboolerrorcheckingpublicDetermines if the Reactor passed in is derived from CReactor (TRUE).
000110000000
BEGIN_CODE

END_CODE
86CLocationReactor515isMonitorCompatibleBOOLOverride.publicReturns TRUE if the monitor passed
in is descended from CLocation Monitor.000110010000
BEGIN_CODE

END_CODE
87CFdReactor516isMonitorCompatibleBOOLOverride.publicReturns TRUE if the EventMonitor passed
in is derived from a CFdMonitor object.000110010000
BEGIN_CODE

END_CODE
88CBufferReactor517isMonitorCompatibleBOOLOverride.publicReturns TRUE if the Event monitor passed in is 
subclassed from CBufferMonitor000110010000
BEGIN_CODE

END_CODE
111CEvent518OnEventvoidCallbackprotectedLocks the global mutex, invokes the
Reactor's operator() and unlocks the global mutex.000010001000
BEGIN_CODE

END_CODE
111CEvent519ReplaceMonitorvoidMutator.publicReplaces the event monitor with a different
object.  This allows the event to reconfigure
itself at run time.  In theory base class
events can completely reconfigure what they
point to.  In practice, this member is called
by constructors of descendants to set up
the initial event systesm.

 Note that it is an error to call this when the
EventThread is active.  If this is done a
CAlreadyRunning exception will be thrown.
000010001000
BEGIN_CODE

END_CODE
111CEvent520ReplaceReactorvoidMutatorpublicCalled to replace the current instance of the event reactor.
This is typically called at construction time by subclasess
to set up the actual event framework.  Event reactors
may be modified when the event thread is active.000010001000
BEGIN_CODE

END_CODE
111CEvent521EnablevoidMutator.publicThe Event thread is started in a synchronized way.
If the event thread is already running, this is a noop.
000010001000
BEGIN_CODE

END_CODE
111CEvent522DisablevoidMutator.publicThe event thread is stopped.  This member
returns when the stop has been requested,
but not necessarily halted.  If the
event thread has been halted or has a halt
pending, this is a No-Op.000010001000
BEGIN_CODE

END_CODE
111CEvent523DescribeSelfstringSelectorpublicReturns a description of this.
1. CNamedObject::DescribeSelf
2. Values of m_fEnabled.
3. Describe self from:
   Event monitor
   Event reactor,
   

000110000000
BEGIN_CODE

END_CODE
112CEventContainer524AddEventCEventContainer::iteratormutatorpublicAdds an event to the container.
The state of the event is not changed.
It is up to the caller to enable/disable the
event.  In most physics applications,
events remain enabled once created
in any event.
Exception to this: servers.000010000000
BEGIN_CODE

END_CODE
112CEventContainer525RemoveEventvoidMutatorpublicRemoves an event given it's name.
If the event does not exist in the container,
throws CNoSuchObject.000010000000
BEGIN_CODE

END_CODE
112CEventContainer526RemoveEvent$voidMutator.publicRemoves an event from the container
given an iterator.  If the iterator is end()
CNoSuchObject is thrown.000010000000
BEGIN_CODE

END_CODE
112CEventContainer527FindEventCEventContainer::iteratorSelector.publicLocates an event given it's name.
If the event is not found, endEvents() is
returned.000010000000
BEGIN_CODE

END_CODE
112CEventContainer528FindEvent$CEventContainer::iteratorSelectorpublicReturns an event iterator which points to
a selected event.  The event is the first one
in iteration order to match an EventMatchPredicate
EventMatchPredicates are function objects which
implement: 
bool operator()(CEvent& rEvent)

If no event causes the predicate to return TRUE,
endEvents() is returned.000010000000
BEGIN_CODE

END_CODE
112CEventContainer529beginEventsCEventContainer::iteratorpublicReturns an iterator pointing towards the 
'first' item in m_Events.000010000000
BEGIN_CODE

END_CODE
112CEventContainer530endEventsCEventContainer::iteratorSelectorpublicReturns an iterator suitable for 
ending iteration through the
container e.g.:
CEventContainer::iterator p = cont.beginEvents();
for(;p!= cont.endEvents(); p++) {
   // do stuff on *p.
}000010000000
BEGIN_CODE

END_CODE
112CEventContainer531EnableEventsvoidMutatorpublicEnables execution of all 
events which match the predicate.000010000000
BEGIN_CODE

END_CODE
112CEventContainer532DisableEventsvoidmutatorpublicDisables all events which match the predicate.000010000000
BEGIN_CODE

END_CODE
112CEventContainer533DescribeSelfstring&SelectorpublicReturns a string which defines the event container.  
The container describes all events it
contains.000110010000
BEGIN_CODE

END_CODE
113CApplication534GetInstanceCApplication*SelectorpublicReturns the application instance.
(m_Instance).100010000000
BEGIN_CODE

END_CODE
113CApplication535DescribeSelfstringSelectorpublicDescribes the application.
This is done by calling CNamedObject::DescribeSelf
then dumping the event container and the object registry in that
order.
000110000000
BEGIN_CODE

END_CODE
114CLocationEvent536operator()voidInterface.publicCalled in response to a location monitor event.
001110000000
BEGIN_CODE

END_CODE
115CFileEvent537operator()voidInterfacepublicProvides an interface for application
specific processing of file events.
The EventMask describes the state of
the fd and consists of a mask of zero or more:

FD_READABLE  - File descriptor can be read
FD_WRITABLE  - File descriptor can be written
FD_EXCEPTION - File descriptor has an exceptional
                              condition set.

001110000000
BEGIN_CODE

END_CODE
116CBufferEvent538operator()voidinterfacepublicProvides an interface on which to supply application
specific behavior when a Spectrodaq buffer is 
received.  001110000000
BEGIN_CODE

END_CODE
120CChangedPredicate539operator()booloverride.publicReturns TRUE if the current value is different from the prior value.000110010000
BEGIN_CODE
bool retval = (m_TOldValue == nValue) ? (FALSE) : (TRUE);
m_TOldValue = nValue;
return retval;
END_CODE
120CChangedPredicate540DescribeSelfstringOverride.publicDescribes self as:
CPointerPredicate::DescribeSelf()
Value to compare with.
000110000000
BEGIN_CODE

END_CODE
121CMaskedValuePredicate541operator()boolOverridepublicReturns TRUE if nVal & m_TMask == m_TValue000110000000
BEGIN_CODE
return ((m_TMask & nValue) == m_TValue);
END_CODE
121CMaskedValuePredicate542DescribeSelfstringOverride.publicReturns a string which describes this object:
1. CPointerPredicate::DescribeSellf
2. Values of mask and value.

Note that T must implement an operator <<000110000000
BEGIN_CODE

END_CODE
124CAlarmMonitor543AddLinkintMutatorpublicAdds an alarm link to the link list.
The link id is returned.  On failure
CLinkFailed is thrown.000110000000
BEGIN_CODE

END_CODE
158CEventThread544StartvoidMutator.publicSchedules the event thread for
execution. Note that if the thread is
already executing , this will
throw a CAlreadyRunning exception.000010000000
BEGIN_CODE

END_CODE
158CEventThread545StopvoidMutator.publicRequests the thread to stop execution
by setting m_fStopSoon  The
thread will exit as soon as it can
notice that it should.  If an event fires
with m_fStopSoon set, it will not be dispatched.
If the thread is not running, then this member throws:

CNotRunning000010001000
BEGIN_CODE

END_CODE
255CEventLoop546getInstanceCEventLoop*Selector.publicRetrieves the instance pointer.100010000000
BEGIN_CODE

END_CODE
255CEventLoop547operator()voidInterfaceprivateProvdes an interface for starting an event
loop.  operator() is called when the thread
is started.001110000000
BEGIN_CODE

END_CODE
256CXtEventLoop548InitializeApplicationWidgetIniitializationpublicCalled to initialize the X toolkit.  Default
behavior is to call XtAppinit(), and return
its result.000110000000
BEGIN_CODE

END_CODE
256CXtEventLoop549SetupApplicationResourcesvoidInitializationpublicCalled from operator() to process the
resource database.  Since the resource
database requires definitions which are
application specific but is not actually 
required, the default behavior is to do
nothing.  Normal applications will set 
up resource definition structures and
invoke XtGetApplicationResrouces()000110000000
BEGIN_CODE

END_CODE
256CXtEventLoop550SetupWidgetTreevoidInitialization.publicoperator() calls this function to set up the
initial widget tree.000110000000
BEGIN_CODE

END_CODE
256CXtEventLoop551operator()intEntry pointprivateentry point for the Xt event loop thread.
The initialization functions are called to
allow the application to set up the application
widget set.  After this is done, the event loop
is entered. Each call of XtDispatchEvent is
bracketed by calls to lock/unlock the application
serializatio mutex.000110000000
BEGIN_CODE

END_CODE
257CInterpreterStartup552OnIniitializevoidDefault behaviorprotectedOn initialize is called very early in 
the execution of the operator() member.
It is intended that subclassed interpreters
perform early initialization here.  At this
point an interpreter has not yet been 
instantiated.  Therefore,  you may not
perform Tcl/Tk library calls at this 
stage.
  Default implementation is a no-op.000110000000
BEGIN_CODE

END_CODE
257CInterpreterStartup553RegisterExtensionsvoidInterfaceprotectedConcrete subclasses of this class must
implement this function.  It is expected that
all tcl interpreters run in this envrionment will
have extensions (if not, just implement an
empty function), therefore this member is
pure virtual.  At this point, an interpreter has
been created.  If this is a Tk derived 
interpreter, it's not certain that the tk Main
window has been created yet however.
001110000000
BEGIN_CODE

END_CODE
257CInterpreterStartup554operator()intInterfaceprivateThis pure virtual member function is expected
to start the interpreter and call the other member
functions; it is the entry point of the thread.001010000000
BEGIN_CODE

END_CODE
258CTCLInterpreterStartup555operator()voidOverride.private1. Calls OnInitialize.
2. Sets up the Tcl interpreter.
3. Within the Tcl initialization function
    (CTCLInterpreterStartup::Tcl_Init) call
   RegisterExtensions.

Note that the instance of the interpreter is gotten
via a call to CEventLoop::getInstance() since this is
a singleton class.
000110011000
BEGIN_CODE

END_CODE
258CTCLInterpreterStartup556Tcl_InitintInitialization.publicCalled from the Tcl_Main() function.
This static member:
1. Obtains the object by calling
    CEventLoop::getInstanc()
2. Initializes the interpreter.
3. Invokes the Object's RegisterExtensions function
    to load packages, register modules and add
    application specific commands.
4. Returns to allow Tcl to start it's main loop.
100010000000
BEGIN_CODE

END_CODE
259CTKInterpeterStartup557operator()voidpublic1. Calls OnInitialize to allow users to do early initialization.
2..Starts the Tk interpreter by callling Tk_Main.
The static member Tk_Init iis passed as 
the application initialization function.
001110010000
BEGIN_CODE

END_CODE
259CTKInterpeterStartup558Tk_InitintpublicCalled by Tk_Main to do application 
specific initialization.

Establishes object context by invoking
CEventLoop::getInstance(), 
invokes RegisterExtensions so that
applicaiton packages and commands can be
registered on the interpreter.

Finally returns to the Tk event loopo.100010000000
BEGIN_CODE

END_CODE
518CTCLSynchronizeCommand559operator()voidCommand processor.publicExecutes the script passed as argv[1]  synchronized
to the appliication's global mutex.000110010000
BEGIN_CODE

END_CODE
519CSocket560ConnectvoidConnection ControlpublicIndicates that the socket will be used
as a client socket and attempts to connect it
to a server. 
The address of the server can be
passed in either in IP address or
IP name textual format.  Similarly,
the port can be passed in as a textual
port name (in /etc/services) or a port number.

Exceptions which can be thrown:
CTCPBadSocketState -- m_State was not Disconnected
CTCPNoSuchHost       - Host not in DNS or nonexistent.
CTCPNoSuchService  - Named service does not translate.
CTCPConnectionFailed- Connection refused by remote host.


On Success m_State --> Connected000010001000
BEGIN_CODE

END_CODE
519CSocket561BindvoidConnectionControlpublicIndicates that the socket will be used
as a server listener socket, and binds it
to a service port.  The service can be
provided either as a numerical string
or as a string translated via getservbyname().

The following exceptions can be thrown:

CTCPBadSocketState   - m_State != Disconnected
CTCPNoSuchService    - getservbyname() failed and
                                        service string was not numeric.

On success, m_State --> Bound000010001000
BEGIN_CODE

END_CODE
519CSocket562ListenvoidConnection ControlpublicIndicates that the specified server 
listener socket is ready to listen
for connections. 

The Following exceptions can be 
thrown:

CTCPBadSocketState - m_State != Bound

On success, m_State --> Listening000010001000
BEGIN_CODE

END_CODE
519CSocket563AcceptCSocket* Connection ControlpublicThis member function can be called on 
a server socket.  The calling thread is blocked
until a connection request is received.  At that
time, the connection is accepted (granted),
and a new CSocket is created in the Connected
state.  The new CSocket represents a Server
Instance socket, communication along that
socket can take place immediately and will
represent communication with the client.

Exceptions which can be thrown:
CTCPBadSocketState -- m_State != Listening

Side effects:

The client parameter is 
written with a string representing the
hostname of the client or the IP address
if the hostname can not be determined.

The socket created is created via new, therefore 
it is the responsibility of the caller to delete it.000010001000
BEGIN_CODE

END_CODE
519CSocket564ShutdownvoidConnection Controlpublic  Shuts down a connection to a remote system.
Unlike shutdown(2) this function does not support
selectively shutting down reads or writes.  Both are
unconditionally shutdown.
  Note that the destructor will automatically call Shutdown
if necessary.

Exceptions:
CTCPBadSocketState  -- m_State != Connected.000010001000
BEGIN_CODE

END_CODE
519CSocket565ReadintIO initiatorpublicPerforms a read on the socket.  The read will transfer
all of the bytes currently waiting in the socket buffers
or block until data is avaialble.  The return valiue will
be the number of bytes transferred.  If the connection
is lost, CTCPConnectionLost will be thrown.000010000000
BEGIN_CODE

END_CODE
519CSocket566WriteintIO Initiator.publicWrites data to the socket.  Note that
this member will block as needed until
all data has been queued to the socket buffers.
This may require multiple write(2) function calls
if the amount of data to be written is larger than
the socket's blocking factor.  Note that if the connection
is lost during the write, CTCPConnectionLost will be thrown.000010000000
BEGIN_CODE

END_CODE
519CSocket567getPeervoidSelector.publicReturns information about who a socket
is connected to.  If the socket is not
connected, CTCPBadSocketState is thrown.
If possible, the peername parameter is returned
as a string containing the DNS name of the
peer. If the DNS lookup fails, the IP address
is converted into dotted form.000010000000
BEGIN_CODE

END_CODE
519CSocket568OOBInlinevoidConfigurationpublicAllows Out Of Band (OOB) data to be inserted in line with buffered data.
OOB data is data with a higher delivery priority than 'normal data'. If this
flag is not set, then by default OOB data must be read through normal
socket interface functions by specifying it in the recv flags parameter.
If this flag is set, oob data is queue at the front of the data to be read
with the Read member.
  If the socket is not connected, then the CTCPBadSocketState exception
is thrown.000010000000
BEGIN_CODE

END_CODE
519CSocket569isOOBInlineboolOptionspublicReturns TRUE if OOBinline is set
FALSE otherwise.  Note that the underlying
socket state is inquired, not some saved internal
state.
  If not connected, CTCPBadSocketState is returned.000010000000
BEGIN_CODE

END_CODE
519CSocket570setRcvLowWaterMarkvoidConfigurationpublicSets the Receive low water mark for the socket.
This is the number of bytes received by the
protocol before any is made available to the
user.  Note that some systems do not allow 
this to be changed.  It is not an error at this
level to attempt to do so, however you will need to 
call getRcvlowWaterMark to be sure the change was
actually made.

Throws CTCPBadSocketState if not connected.000010000000
BEGIN_CODE

END_CODE
519CSocket571getRcvLowWaterMarksize_tpublicReturns the size of the current receive low water mark.
See setRcvLowWaterMark for information about what this
parameter does.  Note that the value returned is inquired from
the socket rather than stored in internal state.000010000000
BEGIN_CODE

END_CODE
519CSocket572setSndLowWaterMarkvoidconfigurationpublicSets the new value of the Send Low water mark.
This controls the number of bytes which must be written
before transferring data to the protocol layers for transmission.
Note that some systems don't allow this value to be changed.
It is not an error to attempt to change this value on those systems,
however you should use getSndLowWaterMark to determine the
actual value negotiated by the system,000010000000
BEGIN_CODE

END_CODE
519CSocket573getSndLowWaterMarksize_tConfigurationpublicReturn the value of the current Send Low Water Mark
Set setSndLowWaterMarrk for more information.000010000000
BEGIN_CODE

END_CODE
519CSocket574setRcvTimeoutvoidConfigurationpublicSet the protocol receive timeouts.  Note that in some systems,
these are not settable.  However it is not an error to attempt to do so.000010000000
BEGIN_CODE

END_CODE
519CSocket575getRcvTimeoutunsigned intConfigurationpublicRetrieve the protocol receive timeout.000010000000
BEGIN_CODE

END_CODE
519CSocket576setSndTimeoutvoidConfigurationpublicSet the number of milliseconds in the send timeout.
Some systems may not allow this to be set, however it is not
an error to try.000010000000
BEGIN_CODE

END_CODE
519CSocket577getSndTimeoutunsigned intConfigurationpublicReturns the current send timeout in ms.

000010000000
BEGIN_CODE

END_CODE
519CSocket578DebugvoidConfigurationpublicAttempts to turn on Socket debugging.
To support this. The user must have effective
UID = 0.  If the socket is not connected,
the CTCPBadSocketState exception is thrown.
If there are other errors (e.g. because the user
doesn't have eff UID=0), then the appropriate
CErrnoException object is thrown.000010000000
BEGIN_CODE

END_CODE
519CSocket579isDebugboolConfigurationpublicReturns TRUE if socket debugging is
turned on and False otherwise.  If the socket
is not connected, CTCPBadSocketState is
thrown.000010000000
BEGIN_CODE

END_CODE
519CSocket580SetNotRoutablevoidConfigurationpublicAllows the caller to control the routability of messages
sent on the socket.  If set, messages will not
be sent through a gateway.
Note:
 The socket need not be connected. Presumably,
if this flag is set prior to Connect on a client socket
the client will be unable to connect outside the local
subnet, and if set prior to Bind for a server, the server will
be unable to accept connections from outside the subnet.
000010000000
BEGIN_CODE

END_CODE
519CSocket581isNotRoutableboolConfigurationpublicReturns the state of the routability flag.000010000000
BEGIN_CODE

END_CODE
519CSocket582setSndBufSizevoidConfigurationpublicSets the socket send buffer size.  This 
has to do with how many bytes can be 
sent in a single write(2) service call. Messages
larger than that must be segmented into multiple
write(2) calls.  Note howerver that 
CTCPSocket::Write automatically handles
any necessary segmentation.
  If the socket is not connected, throws:
CTCPBadSocketState

000010000000
BEGIN_CODE

END_CODE
519CSocket583getSndBufSizesize_tConfigurationpublicReturns the number of bytes that can be
written in a single write(2) call.
000010000000
BEGIN_CODE

END_CODE
519CSocket584setRcvBufSizevoidConfigurationpublicSets the maximum number of bytes which can be received in a single
read(2) operation.  Note that CTCPSocket::Read does >NOT< 
automatically segment or else you may block when you'd like
to believe that a message has been received.

If the socket is not connected, throws CTCPBadSocketState
000010000000
BEGIN_CODE

END_CODE
519CSocket585getRcvBufSizesize_tConfigurationpublicReturns the maximum number of bytes which can be 
recieved in a single read(2) call.000010000000
BEGIN_CODE

END_CODE
519CSocket586setLingervoidConfigurationpublicSets the socket linger parameters.  Linger properties
govern the way a shutdown, operates.  Note that
object destruction which requires a shutdown implicitly
turns off linger.  
  If linger is enabled, then the close will block until
all pending data has been successfully sent or until the
linger timerout is exceeded.  If the socket is not
connected, throws a CTCPBadState exception.

000010000000
BEGIN_CODE

END_CODE
519CSocket587getLingervoidConfigurationpublicRetrieve the linger parameters.000010000000
BEGIN_CODE

END_CODE
520CServerConnectionEvent588operator()boolDefault functionality.publicoperator() is supposed to determine if a 
connection request to the server should be
honored.  The default functionality is to return
TRUE indicating that all connection requests are
valid.000110010000
BEGIN_CODE

END_CODE
522CServerInstance589OnStartupBOOLIniitializerpublicCalled after a particular instance has
been created to provide application
specific post connection functionality.
If FALSE is returned, this is considered a
late rejection of the connection (perhaps
as a result of an invalid username/password
interaction on the socket).
  Default functionality is a no-op returning TRUE.
000110010000
BEGIN_CODE

END_CODE
522CServerInstance590cloneCServerInstance*Interface:virtual constructionpublicProvides an interface for cloning the 
reference instance and associating it
with a server socket.  Returns a pointer
to a new server instance of this type
001110000000
BEGIN_CODE

END_CODE
670CClassifiedObjectRegistry591CreateRegistryvoidMutatorpublicCreates a new registry. It is not an error
to create a registry which already exists.
If this is attempted, it is a no-op.000010001000
BEGIN_CODE

END_CODE
670CClassifiedObjectRegistry592DeleteRegistryvoidMutatorpublicDelete an existing registry. Any registry entries
are destroyed, however the objects they point to
are not.
Attempts to destroy an nonexsitent registry
result in a NoSuchObject exception.000010001000
BEGIN_CODE

END_CODE
670CClassifiedObjectRegistry593Addvoidbase class mutator.publicAdds an item to a registry.
If the item already exists in that registry,
a DuplicateName exception is thrown.
If the registry does not exist a 
NoSuchObject exception is thrown.000110000000
BEGIN_CODE

END_CODE
670CClassifiedObjectRegistry594Removevoidbase class mutatorpublicThe named object is removed from the designated registry.
If the object does not exist, or the registry does not exist,
a NoSuchObject exception is thrown. The name embedded
in the exception differentiates between these two cases.
000110000000
BEGIN_CODE

END_CODE
670CClassifiedObjectRegistry595FindObjectRegistryIteratorSelectorpublicLocates an object in a specific registry.
If the registry or object don't exist a
NoSuchObject exception is thrown.
000010001000
BEGIN_CODE

END_CODE
670CClassifiedObjectRegistry596Find$CRefcountedPtr<ObjectList>SellectorpublicReturns a referece counted pointer to
a dynamically allocated list of Objects which
match the name requested.
ObjectList is a typedef for:
list<CNamedObject*>
The list is drawn from all of the registries.
If no registries contain the requested name,
an empty list is returned.000010000000
BEGIN_CODE

END_CODE
670CClassifiedObjectRegistry597beginregistryRegistryIteratorSelectorpublicReturns an iterator into the registries which
are contained by this object.  Note that iteratiing
will return registries... that is RegistryIterator is a
typedef for:

map<string,CObjectRegistry>::iterator000010001000
BEGIN_CODE

END_CODE
670CClassifiedObjectRegistry598endregistryRegistryIteratorSelectorpublicReturns a registry iterator suitable for determining
when iteration has been completed
(e.g. while(p != coreg.endregistry()) {...
  p++;
}000010001000
BEGIN_CODE

END_CODE
670CClassifiedObjectRegistry599DescribeSelfstringSelectorpublicDescirbes self.  This produces a string of the form:

CNamedObject::DescibeSelf()
"  Registries defined: "  List of registries
"     Registry " <name>"  Contains:   <- for all registries.
          Registry::DescribeSelf000110000000
BEGIN_CODE

END_CODE
950CServerMonitor600operator()voidpublic000010000000
BEGIN_CODE

END_CODE
950CServerMonitor601DescribeSelfstringselectorpublicDescribes self as a file descriptor
which has a socket that has a state.
000110000000
BEGIN_CODE

END_CODE
***END_TABLE***

Parameters
OperID, Parameter Text
***BEGIN_TABLE***
455ClientData/pData//
455Tcl_Interp*/pInterp//
455int/Argc//
455char**/Argv//
456ClientData/pData//
462CNamedObject&/rObject//
463const string&/rName//
464const CNamedObj&/rObject//
465const string&/rObjectName//
469const string&/RegistryName//
470const string&/RegistryName//
471const string&/RegistryName//
471CNamedObject&/rObject//
472const string&/RegistryName//
472CNamedObject&/Object//
473const string&/RegistryName//
473const string&/ObjectName//
474const string&/ObjectName//
480const string&/RegistryName//
483int/nTimeout/FOREVER/
484CEventMonitor&/rMonitor//
484CEventMonitor::result/Reason//
485CEventMonirtor&/rMonitor//
486LocationMonPred&/newloc//
488T*/pNewLocation//
490CReactor&/rReactor//
491T/newValue//
492bool/fReadable/TRUE/
493bool /fWritable/TRUE/
494bool/fException/TRUE/
497CReactor&/rReactor//
499const string&/URL//
499int/tag/COS_ALLBITS/
499int/mask/COS_ALLBITS/
499bool/fReliable/TRUE/
500int/linkid//
501LinkIterator/link//
502LinkMatchPredicate&/rPredicate//
502LinkIterator/startat//
505offset_t/nOffset/0/
506int/tag/COS_ALLBITS/
507int/nMask//
511bool/fReapeat/TRUE/
512int/nTimeout/FOREVER/
514CReactor&/rReactor//
515CEventMonitor&/rMonitor//
516CEventMonitor&/rEvent//
517CEventMonitor&/rMonitor//
518CEventMonitor::result/why//
519CEventMonitor&/rEvent//
520CReactor&/rReactor//
524CEvent&/rEvent//
525const string&/rName//
526CEventContainer::iter/p//
527const string&/rName//
528EventMatchPredicate/Predicate//
531EventMatchPredicate/pred/MatchAll/
532EventMatchPredicate/pred/MatchAll/
536CEventMonitor::result/why//
536T&/CurrentValue//
537CEventMonitor::result/why//
537int/fd//
537int/EventMask//
538CEventMonitor::result/why//
538CDAQBuffer&/rBuffer//
539T/nValue//
541T/nValue//
543const string&/URL//
543int/tag/COS_ALLBITS/
543int/mask/COS_ALLBITS/
543bool/fReliable/TRUE/
547int/argc//
547char**/argv//
548int/argc//
548char**/argv//
549Widget/TopLevel//
550Widget/TopLevel//
551int/argc//
551char**/argv//
552int/argc//
552char**/Argv//
554int/argc//
554char**/argv//
556Tcl_Interp*/pInterp//
559CTCLInterpreter&/rInterp//
559CTCLResult/&rResult//
559int/nArguments//
559char/pArguments[]//
560const string&/host//
560const string&/service//
561const string&/service//
562unsigned int/nBacklog/5/
563string&/client//
565void*/pBuffer//
565size_t/nBytes//
566void*/pBuffer//
566size_t/nBytes//
567int&/short//
567string&/peer//
568bool/State/TRUE/
570size_t/nBytes//
572size_t/nBytes//
574unsigned int/nMs//
576unsigned int/nMs//
578bool/fState/TRUE/
580bool/fRoutable/TRUE/
582size_t/nBufferSize//
584size_t/nBytes//
586bool/lOn//
586int/nLingerSeconds//
587bool&/isLingering//
587int&/nLingerSeconds//
588CEventMonitor::result/why//
588CSocket&/Listener//
588CSocket*/Server//
590CSocket&/rSocket//
591const string&/RegistryName//
592const string&/RegistryName//
593const string&/RegistryName//
593CNamedObject&/rObject//
594const string&/RegistryName//
594CNamedObject&/Object//
595const string&/RegistryName//
595const string&/ObjectName//
596const string&/ObjectName//
***END_TABLE***

Includes
ClassID, ClassName, Include Text
***BEGIN_TABLE***
56CObjectRegistrystring
56CObjectRegistrymap
63CClassifiedObjectRegistrymap
63CClassifiedObjectRegistrystring
63CClassifiedObjectRegistrylist
64CNamedObjectstring
64CNamedObjecttypeinfo
82CFdMonitorselect.h
82CFdMonitortime.h
111CEventspectrodaq.h
670CClassifiedObjectRegistrymap
670CClassifiedObjectRegistrystring
670CClassifiedObjectRegistrylist
***END_TABLE***

Relation Shape
ShapeID, Type, Text, Multiplicity, Source Node ID, Source Index, LineTexture, IsDisplayByVal, IsDisplayByRef, QualifierSrc
***BEGIN_TABLE***
242is a05230001
264NoText053100012
300NoText067130011
312NoText06930001
430NoText09130001
442NoText09030001
452NoText09750001
591NoText013690001
602NoText013630001
610NoText013900001
662NoText09230001
682NoText
09430001
872NoText020330001
890NoText014090001
1512NoText034930001
1522NoText035230001
3070NoText073830001
3080NoText073510001
3692NoText066430001
3702NoText088230001
3730NoText05860001
4042NoText07030001
4050NoText070130001
4060NoText013600001
5620NoText0205140011
5640NoText020520011
5982NoText014250001
5992NoText09330001
6000NoText073550001
6010NoText014040001
6722NoText034870001
6734NoText0352120012
6754NoText035240011
***END_TABLE***

Branches
Relation Shape ID, Multiplicity, Destination Node ID, Destination Index, Text, Relation Type, Branch Id,  IsDisplayStatic, IsDisplayFriend, IsDisplayPlus, QualifierDest, Offset x, Offset y
***BEGIN_TABLE***
24053225000000
260569Synchronizes via.45200000
3015812m_Registries05700000
31070225800000
430924m_Predicate07500000
44091427600000
44093627700000
44094227800000
44096228000000
45099228100000
450100428200000
450101228300000
59013812111000000
59013712111100000
59020512118000000
6001412211300000
6001424211400000
6001432211500000
60073502158400000
6111368m_Events011700000
6601484212500000
6601492212600000
6801522212900000
870674217600000
870582217700000
8902048m_ObjectRegistry0179100220
15103514231200000
15103522231300000
15203532231400000
15203542231500000
307073610m_ServerSocket073200000
30817386073300000
36908822290100000
37007302290200000
373120313090500000
4040724299500000
40401532299600000
4040736299700000
404095722100000000
4040140822158900000
4040140922159000000
405095412m_Registry099800000
40609585m_Synchronizer0100100000
5620136130148200000
564013830148400000
598073822158500000
5990140722158600000
60007362m_ConnectionSocket0158700000
601013930158800000
672034922180300000
673088211Invokes through4180400000
675066314180600000
***END_TABLE***

Relations
Id,ParentId,Name,Type,Description,SrcVisibility,SrcMultiplicity,SrcLength,IsSrcByRef,IsSrcByVal,IsSrcFriend,IsSrcStatic,SrcRole,SourceClassId,
DestVisibility,DestMultiplicity,DestLength,DestByRef,IsDestByVal,IsDestFriend,IsDestStatic,IsDestRole,DestClassId
***BEGIN_TABLE***
49230private00000052private00000053
50242private00000052private00000053
51252private00000054private00000055
5226Synchronizes via.4private00000053private00000055
5730m_Registries0Map of registries, one per category.private00000063private10000056
58312private00000064private00000065
59322private00000065private00000066
60322private00000065private00000067
61322private00000065private00000068
7139m_Checker0private00010066private00010067
7240m_Reactor0private00000066private00000068
73412private00000080private00000081
74422private00000080private00000081
7543m_Predicate0private00000080private00000081
76442private00000067private00000080
77442private00000067private00000082
78442private00000067private00000083
79442private00000067private00000084
80442private00000067private00000085
81452private00000068private00000086
82452private00000068private00000087
83452private00000068private00000088
84442private00000067private00000089
85460private00000089private00000067
110591private000000111private00000067
111591private000000111private00000068
112602private000000111private000000112
113602private000000111private000000114
114602private000000111private000000115
115602private000000111private000000116
116602private000000111private000000117
11761m_Events0Map of events.private000000112private100000111
118622private000000112private000000113
119630private00000055private00000054
120642private00000065private000000118
121652private000000118private00000066
122652private000000118private00000067
123652private000000118private00000068
124662private00000081private000000119
125662private00000081private000000120
126662private00000081private000000121
127662private00000081private000000122
128672private000000123private00000067
129682private00000083private000000124
130652private000000118private00000081
176872private00000064private00000063
177872private00000064private00000056
178882private000000113private00000063
17989m_ObjectRegistry0private000001113private00000163
180591private000000111private000000158
181904private000000159private00000053
182912private00000053private000000160
183920private000000163private000000159
184932private000000163private000000164
185932private000000163private000000165
186942private000000169private000000168
187952private000000168private000000166
188952private000000168private000000167
2471212private000000168private000000159
2481220private000000168private000000159
2491230private000000163private000000168
3111502private000000255private000000254
3121512private000000255private000000256
3131512private000000255private000000257
3141522private000000257private000000258
3151522private000000257private000000259
6462712private000000465private000000466
6472712private000000465private000000467
6482712private000000465private000000468
6492722private000000467private000000469
6502730private000000467private000000469
6512740private000000468private000000469
7243002private000000470private000000471
7253012private000000471private000000518
7263022private000000469private000000471
7273030private000000469private000000471
7283044private000000469private000000471
729602private000000111private000000520
730305m_ConnectionSocket0private000000520private000000519
7313062private000000522private000000519
732307m_ServerSocket0Socket communicating with clientprivate000000522private000000519
7333080private000000520private100000522
734602private000000111private000000522
9013692private000000470private00000053
9023702private00000053private000000518
9033714private000000469private00000053
9043724private000000469private00000053
9053730private00000056private10000064
9944042private00000065private00000066
9954042private00000065private00000067
9964042private00000065private00000081
9974042private00000065private00000068
998405m_Registry0private00000165private000000670
9994042private00000065private000000671
10004042private00000065private000000111
1001406m_Synchronizer0private000001111private00000055
14825620private000000158private000000111
14835630private000000158private00000068
14845640private000000158private00000067
1584602private000000111private000000520
15855982private000000115private000000522
15865992private00000082private000000950
1587600m_ConnectionSocket0Socket listening for connectionsprivate000000520private000000519
15886010private000000113private000000112
15894042private00000065private000000112
15904042private00000065private000000113
18036722private000000254private000000255
1804673Invokes through4private000000257private00000053
18056744private000000257private000000469
18066754private000000257private000000469
***END_TABLE***

General Shape
 ShapeId, Type,Positionx, Position.y, # ConnectPoints metafileName, TextOffset, ShapeSize, Width, Height, Texture, FileName,  Class, Text

***BEGIN_TABLE***
5702103101606070110Simple Classes
985281059216f:\Program Files\WC4\note.emf2120217700LocationMonitors
:and PointerPredicates
:are template <class T>
1040235098016360265110EventMonitor class hierarchy With Predicates as well.
68010808701606050110Registries
1450412097016160125110Event Convenience Classes
955520803716f:\Program Files\WC4\note.emf2120149340Static member.
880178092016060260330Top level of named objects.
:Note that subsequent pages show the interconnections
:between classes of this type.
959539101916f:\Program Files\WC4\note.emf2120152340Static member
102535106016f:\Program Files\WC4\note.emf2120235790LinkAlarmMonitors can dispatch
:to BufferReactors and 
:TimerMonitors can dispatch to
:Reactors.
9605409069016f:\Program Files\WC4\note.emf2120229530CApplication is a singleton.
:Enforced by having fixed name
895162078016f:\Program Files\WC4\note.emf21204231150In general thes objects will be registered in
:one of the sub-registries of a ClassifieObjectRegistry.
:Classifications would include Event, EventChecker, Rector
2060483093016060320220Event Loops:  Support concurrent operation of an event framework
:along with a DAQRocNode.
733056909501616260145110TCP/IP Client server classes.
350550306916f:\Program Files\WC4\note.emf2120149340Singleton class.
54538030016f:\Program Files\WC4\note.emf2120314760CDAQTClProcessor will 
:synchronize with a globally
:defined master semaphore prior to invoking
:operator()
***END_TABLE***

