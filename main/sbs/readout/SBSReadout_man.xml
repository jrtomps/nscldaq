<!-- manpage 3sbsReadout -->

    <refentry id="manpage.cbusy">
      <refmeta>
         <refentrytitle>CBusy</refentrytitle>
         <manvolnum>3sbsReadout</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>CBusy</refname>
     <refpurpose>Abstract base class for Busy module management.</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;CBusy.h&gt;
         </programlisting>
         <classsynopsis>
            <ooclass><classname>CBusy</classname></ooclass>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type>
                <methodname>GoBusy</methodname>
                <void /><modifier>=0</modifier>
                </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type>
                <methodname>GoClear</methodname>
                <void /><modifier>=0</modifier>
                </methodsynopsis>
         </classsynopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
            <classname>CBusy</classname> is an abstract base class
            for managing busy modules.   When the Readout program accepts a
            trigger, there is a <firstterm>deadtime</firstterm> during which it
            is not able to accept subsequent trigger.  External electronics often
            needs to know when this deadtime is.
         </para>
         <para>
            The normal way to provide a signal showing when the computer is busy
            is to have some electronics module that acts like a latch.  The
            latch is set true by the trigger itself.  Software clears the latch
            when it is able to respond to the next trigger.  
            </para>
        <para>
            Concrete busy classes are created by deriving them from
            <classname>CBusy</classname>.  An instance of one of these concrete
            classes should be created and registered with the
            <link linkend='manpage.cexperiment'>CExperiment</link>
            in <classname>Skeleton</classname>::<methodname>SetupReadout</methodname>
            </para>
      </refsect1>
      <refsect1>
         <title>
            Public member functions
         </title>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type>
                <methodname>GoBusy</methodname>
                <void /><modifier>=0</modifier>
                </methodsynopsis>
            <para>
                Pure virtual function the framework calls when, for software
                reasons, it is about to be unable to respond to triggers for
                some extended period of time.  This will be called when data taking
                is about to stop due to a <command>end</command> or
                <command>pause</command> command.
                </para>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type>
                <methodname>GoClear</methodname>
                <void /><modifier>=0</modifier>
                </methodsynopsis>
            <para>
                Pure virtual function the framework calls when it's about to be
                able to respond to triggers.  In addition to calling this
                member after processing each trigger, the framework will invoke
                this at some point just prior to starting data taking as a result
                of a <command>begin</command> or <command>resume</command>
                command.
                </para>
        </refsect1>
   </refentry>


    <refentry id="manpage.ccaenv262busy">
      <refmeta>
         <refentrytitle>CCAENV262Busy</refentrytitle>
         <manvolnum>3sbsReadout</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>CCAENV262Busy</refname>
     <refpurpose>Concrete busy class for the CAEN V262 input module.</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;CCAENV262Busy&gt;
         </programlisting>
         <classsynopsis>
            <ooclass><classname>CCAENV262Busy : public CBusy</classname></ooclass>
            <constructorsynopsis>
                <methodname>CCAENV262Busy</methodname>
                <methodparam>
                    <type>uint32_t</type> <parameter>base</parameter>
                    </methodparam>
                <methodparam>
                    <type>unsigned</type> <parameter>crate</parameter>
                    </methodparam>
                </constructorsynopsis>
            <constructorsynopsis>
                <methodname>CCAENV262Busy</methodname>
                <methodparam>
                    <type>CCaenIO&amp;</type> <parameter>module</parameter>
                    </methodparam>
                </constructorsynopsis>
            <constructorsynopsis>
                <methodname>CCAENV262Busy</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CCAENV262Busy&amp;</type>
                    <parameter>rhs</parameter>
                    </methodparam>
                </constructorsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>void</type> <methodname>GoBusy</methodname> <void />
                </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>void</type> <methodname>GoReady</methodname> <void />
                </methodsynopsis>
         </classsynopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
            This class uses the CAEN V262 I/O register to provide signals
            needed to implement a computer busy.  When you use this module,
            module outputs have the following meanings:
            <informaltable frame='all'>
                <tgroup cols='2'>
                    <thead>
                        <row>
                            <entry>Output</entry>
                            <entry>Meaning</entry>
                            </row>
                        </thead>
                    <tbody>
                        <row>
                            <entry>SHP0</entry>
                            <entry><para>Computer is about to go busy for a long time</para></entry>
                            </row>
                        <row>
                            <entry>SHP1</entry>
                            <entry><para>
                                Computer is about to go ready.</para></entry>
                            </row>
                        <row>
                            <entry>SHP3</entry>
                            <entry><para>
                                Module clears are output just prior to releasing the
                                 busy.</para></entry>
                            </row>
                        </tbody>
                    </tgroup>
                </informaltable>
         </para>
         <para>
            Note that <literal>SHP0</literal> is not a hardware signal.  It means
            that the computer is about to be busy due to data taking stopping or
            pausing.  To use this module you must have an external latch or
            gate generator in latch mode.  The latch should start on the OR
            of the master trigger and <literal>SHP0</literal> it should clear
            on <literal>SHP1</literal>.
            </para>
         <para>
            The module clears are a convenience output and need not be used, however
            if you can use them, this is quicker than clearing modules in software.
            </para>
      </refsect1>
      <refsect1>
         <title>
            Public member functions
         </title>
            <methodsynopsis><type></type>
                <methodname>CCAENV262Busy</methodname>
                <methodparam>
                    <type>uint32_t</type> <parameter>base</parameter>
                    </methodparam>
                <methodparam>
                    <type>unsigned</type> <parameter>crate</parameter>
                    </methodparam>
                </methodsynopsis>
            <para>
                Construct a busy object.  <parameter>base</parameter> is the
                base address of the V262 module and <parameter>crate</parameter> the
                VME crate in which the module lives.  <parameter>crate</parameter>
                is an optional parameter that defaults to <literal>0</literal>.
                </para>
            <methodsynopsis><type></type>
                <methodname>CCAENV262Busy</methodname>
                <methodparam>
                    <type>CCaenIO&amp;</type> <parameter>module</parameter>
                    </methodparam>
                </methodsynopsis>
            <para>
                Constructs a busy object. <parameter>module</parameter> is a
                refererence to a <classname>CCaenIO</classname> module that
                has already been constructed and will be the busy hardware
                controlled by this object.
                </para>
            <methodsynopsis><type></type>
                <methodname>CCAENV262Busy</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CCAENV262Busy&amp;</type>
                    <parameter>rhs</parameter>
                    </methodparam>
                </methodsynopsis>
            <para>
                Copy constructs a new busy module that is a functional
                equivalent to <parameter>rhs</parameter>.
		</para>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>void</type> <methodname>GoBusy</methodname> <void />
                </methodsynopsis>
            <para>
                Called by the framework to indicate the busy should
                be asserted.  This is not called in response to a gate.
                Busy in response to a gate must happen at hardware speeds,
                not software.
                </para>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>void</type> <methodname>GoReady</methodname> <void />
                </methodsynopsis>
            <para>
                Called by the framework to indicate it is able to react to
                the next trigger.
                </para>
      </refsect1>
      <refsect1>
        <title>EXAMPLES</title>
        <example>
            <title>Creating and registering a V262 as a busy:</title>
            <programlisting>
#include &lt;CCAENV262Busy.h&gt;
...
void
Skeleton::SetupReadout(CExperiment* pExperiment)
{
   ...
   pExperiment-&gt;EstablishBusy(new CCAENV262(0x444400));
   ...
}
                </programlisting>
            </example>
      </refsect1>
      <refsect1>
         <title>
            SEE ALSO
         </title>
     <para>
        <link linkend="manpage.cbusy">CBusy(3sbsReadout)</link>
        <link linkend="CaenIO">CaenIO(3daq)</link>
        <link linkend='manpage.ccaenv262trigger'>CCAENV262Trigger(3sbsReadout)</link>
     </para>
      </refsect1>
   </refentry>

    <refentry id="manpage.ccaenv262trigger">
      <refmeta>
         <refentrytitle>CCAENV262Triger</refentrytitle>
         <manvolnum>3sbsReadout</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>CCAENV262Triger</refname>
     <refpurpose>Trigger module with CAEN V262</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;CCAEANV262Trigger.h&gt;
         </programlisting>
         <classsynopsis>
            <ooclass><classname>CCAENV262Trigger : public CEventTrigger</classname></ooclass>
            <constructorsynopsis>
                <methodname>CCAENV262Trigger</methodname>
                <methodparam>
                    <type>uint32_t</type> <parameter>base</parameter>
                    </methodparam>
                <methodparam>
                    <type>unsigned</type> <parameter>crate</parameter>
                    <initializer>0</initializer>
                    </methodparam>
                </constructorsynopsis>
            <constructorsynopsis>
                <methodname>CCAENV262Trigger</methodname>
                <methodparam>
                    <type>CCaenIO&amp;</type> <parameter>module</parameter>
                    </methodparam>
                </constructorsynopsis>
            <constructorsynopsis>
                <methodname>CCAENV262Trigger</methodname>
                <methodparam>
                    <modifier>const</modifier>
                    <type>CCAENV262Trigger&amp;</type> <parameter>rhs</parameter>
                    </methodparam>
                </constructorsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>bool</type>
                <methodname>operator()</methodname><void />
                </methodsynopsis>
         </classsynopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
            Implements a trigger class based on the hardware of the
            CAEN V262 I/O register.  When used as a triggerm odule, the
            Following signals in the V262 have meaning:
            <informaltable>
                <tgroup cols='2'>
                    <thead>
                        <row>
                            <entry>Signal</entry>
                            <entry>Meaning</entry>
                            </row>
                        </thead>
                    <tbody>
                        <row>
                            <entry>IN0</entry>
                            <entry>Computer Master Gate (live)</entry>
                            </row>
                        <row>
                            <entry>SHP2</entry>
                            <entry><para>
                            Trigger acknowledge.  The V262 does not latch signals
                            IN0 must be held true until SHP2 is signalled.
                            </para>
                            </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </informaltable>
         </para>
      </refsect1>
      <refsect1>
         <title>
            Public member functions
         </title>
             <methodsynopsis><type></type>
                <methodname>CCAENV262Trigger</methodname>
                <methodparam>
                    <type>uint32_t</type> <parameter>base</parameter>
                    </methodparam>
                <methodparam>
                    <type>unsigned</type> <parameter>crate</parameter>
                    <initializer>0</initializer>
                    </methodparam>
                </methodsynopsis>
             <para>
                Constructs a <classname>CCAENV262Trigger</classname> object.
                The <parameter>base</parameter> parameter is the base address
                of the CAEN V262 module to be used as a trigger.
                The optional <parameter>crate</parameter> parameter specifies
                which VME crate the module is in. If not supplied,
                <parameter>crate</parameter> defaults to <literal>0</literal>.
                </para>
            <methodsynopsis>
                <methodname>CCAENV262Trigger</methodname>
                <methodparam>
                    <type>CCaenIO&amp;</type> <parameter>module</parameter>
                    </methodparam>
                </methodsynopsis>
            <para>
                Constructs a trigger object from an existing
                <classname>CaenIO</classname> object.
                <parameter>module</parameter> is the object that represents the
                physical module that will be used as the trigger module.
                </para>
            <methodsynopsis>
                <methodname>CCAENV262Trigger</methodname>
                <methodparam>
                    <modifier>const</modifier>
                    <type>CCAENV262Trigger&amp;</type> <parameter>rhs</parameter>
                    </methodparam>
                </methodsynopsis>
            <para>
                Copy constructor.  Contructs a trigger object from
                <parameter>rhs</parameter>.
                </para>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>bool</type>
                <methodname>operator()</methodname><void />
                </methodsynopsis>
            <para>
                The trigger poll function.  When the framework is able to accept
                triggers, it will poll this method. A <literal>true</literal>
                return indicates the presence of the trigger.  Note that
                this function will also strobe the SHP2 output when it sees a trigger,
                making this a possibly destructive read of the trigger.
                </para>
      </refsect1>
      <refsect1>
         <title>EXAMPLES</title>
         <para>
         </para>
      </refsect1>
      <refsect1>
         <title>
            SEE ALSO
         </title>
     <para>
        <link linkend='CaenIO'>CaenIO(3daq)</link>
        <link linkend='manpage.ccaenv262busy'>CCAENV262Busy(3sbsReadout)</link>
        <link linkend='manpage.ceventtrigger'>CEventTrigger(3sbsReadout)</link>
     </para>
      </refsect1>
   </refentry>
    
    
    <refentry id="manpage.ccompoundeventsegment">
      <refmeta>
         <refentrytitle>CCompoundEventSegment</refentrytitle>
         <manvolnum>3sbsReadout</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>CCompoundEventSegment</refname>
     <refpurpose>Container for other event segments</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;CCompoundEventSegment.h&gt;
         </programlisting>
         <classsynopsis>
            <ooclass><classname>CCompoundEventSegement : public CEventSegment</classname></ooclass>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>void</type>  <methodname>initialize</methodname>
                <void />
                </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>void</type> <methodname>clear</methodname>
                <void />
                </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type>
                <methodname>disable</methodname>
                <void />
                </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>size_t</type>
                <methodname>read</methodname>
                <methodparam>
                    <type>void*</type> <parameter>pBuffer</parameter>
                    </methodparam>
                <methodparam>
                    <type>size_t</type> <parameter>maxwords</parameter>
                    </methodparam>
                </methodsynopsis>
	    <methodsynopsis>
	      <modifier>virtual</modifier>
	      <type>void</type> <methodname>onBegin</methodname>
	      <void />
	    </methodsynopsis>
	    <methodsynopsis>
	      <modifier>virtual</modifier>
	      <type>void</type> <methodname>onEnd</methodname>
	      <void />
	    </methodsynopsis>
	    <methodsynopsis>
	      <modifier>virtual</modifier>
	      <type>void</type> <methodname>onPause</methodname>
	      <void />
	    </methodsynopsis>
	    <methodsynopsis>
	      <modifier>virtual</modifier>
	      <type>void</type> <methodname>onResume</methodname>
	      <void />
	    </methodsynopsis>
	    
            <methodsynopsis>
                <type>void</type> <methodname>AddEventSegment</methodname>
                <methodparam>
                    <type>CEventSegment*</type> <parameter>pSegment</parameter>
                    </methodparam>
                </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>DeleteEventSegment</methodname>
                <methodparam>
                    <type>CEventSegment*</type> <parameter>pSegment</parameter>
                    </methodparam>
                </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>bool</type>
                <methodname>isComposite</methodname>
                <void /><modifier>const</modifier>
                </methodsynopsis>
            <methodsynopsis>
                <type>EventSegmentIterator</type>
                <methodname>begin</methodname> <void />
                </methodsynopsis>
            <methodsynopsis>
                <type>EventSegmentIterator</type>
                <methodname>end</methodname><void />
                </methodsynopsis>
            <methodsynopsis>
                <type>size_t</type>
                <methodname>size</methodname><void /><modifier>const</modifier>
                </methodsynopsis>
            <methodsynopsis>
                <type>size_t</type> <methodname>leafCount</methodname> <void />
                </methodsynopsis>
            <methodsynopsis>
                <type>size_t</type> <methodname>fullCount</methodname><void />
                </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>visit</methodname>
                <methodparam>
                    <type>CVisitor&amp;</type> <parameter>visitor</parameter>
                    </methodparam>
                </methodsynopsis>
         </classsynopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
            <classname>CCompoundEventSegemnt</classname> provides an ordered
            container for event segment objects (or rather pointers to event
            segment objects).  Since a <classname>CCompoundEventSegment</classname>
            itself is an event segment you can build an arbitrarily deep hierarchy
            of event segments using this class.
         </para>
         <para>
            A rich set of facilities for navigating the event segment hierarchy
            is provided though normally this hierarchy gets built at program initialization
            time and is fixed throughout the lifetime of the program.  Navigation models
            include iteration and visitation.  See Types and Public Data for
            information about the class scoped data types that support these
            models.
            </para>
        <para>
            Event segments also provide a mechanism to determine if they are
            containers via the <methodname>isComposite</methodname> member function.
            </para>
      </refsect1>
      <refsect1>
         <title>
            Public member functions
         </title>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>void</type>  <methodname>initialize</methodname>
                <void />
                </methodsynopsis>
            <para>
                Part of the event segment interface.  Does a deep initialization
                of all events segments in the compound event segment. This is
                done by calling the <methodname>initialize</methodname>
                member on each element in the container.  This implies that
                if an element of the container is itself a compound event
                segment, it's children will be recursively initialized.
                </para>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>void</type> <methodname>clear</methodname>
                <void />
                </methodsynopsis>
            <para>
                Part of the event segment interface.  Does a deep clear of all
                event segments.  This is
                done by calling the <methodname>clear</methodname>
                member on each element in the container.  This implies that
                if an element of the container is itself a compound event
                segment, it's children will be recursively cleared.
                </para>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type>
                <methodname>disable</methodname>
                <void />
                </methodsynopsis>
            <para>
                Part of the event segment interface.  Does a deep disable of all
                event segments.  This is
                done by calling the <methodname>disable</methodname>
                member on each element in the container.  This implies that
                if an element of the container is itself a compound event
                segment, it's children will be recursively disabled.
                </para>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>size_t</type>
                <methodname>read</methodname>
                <methodparam>
                    <type>void*</type> <parameter>pBuffer</parameter>
                    </methodparam>
                <methodparam>
                    <type>size_t</type> <parameter>maxwords</parameter>
                    </methodparam>
                </methodsynopsis>
            <para>
                Part of the event segment interface.  Does a deep read of all
                event segments.  This is
                done by calling the <methodname>read</methodname>
                member on each element in the container.  This implies that
                if an element of the container is itself a compound event
                segment, it's children will be recursively read.
                </para>
            <para>
                <parameter>pBuffer</parameter> points to the buffer into which
                data should be read.  <parameter>maxwords</parameter> is the
                maximum number of words that can still fit in that buffer.
                The method returns the number of words that were read by this
                segment.
                </para>
	    <methodsynopsis>
	      <modifier>virtual</modifier>
	      <type>void</type> <methodname>onBegin</methodname>
	      <void />
	    </methodsynopsis>
	    <para>
	      Invokes <methodname>onBegin</methodname> for all
	      event segments in the compound. If there are nested segments,
	      traversal is depth first.
	    </para>
	    <methodsynopsis>
	      <modifier>virtual</modifier>
	      <type>void</type> <methodname>onEnd</methodname>
	      <void />
	    </methodsynopsis>
	    <para>
	      Invokes <methodname>onEnd</methodname> for all
	      event segments in the compound. If there are nested segments,
	      traversal is depth first.
	    </para>

	    <methodsynopsis>
	      <modifier>virtual</modifier>
	      <type>void</type> <methodname>onPause</methodname>
	      <void />
	    </methodsynopsis>
	    <para>
	      Invokes <methodname>onPause</methodname> for all
	      event segments in the compound. If there are nested segments,
	      traversal is depth first.
	    </para>

	    <methodsynopsis>
	      <modifier>virtual</modifier>
	      <type>void</type> <methodname>onResume</methodname>
	      <void />
	    </methodsynopsis>
	    <para>
	      Invokes <methodname>onResume</methodname> for all
	      event segments in the compound. If there are nested segments,
	      traversal is depth first.
	    </para>

            <methodsynopsis>
                <type>void</type> <methodname>AddEventSegment</methodname>
                <methodparam>
                    <type>CEventSegment*</type> <parameter>pSegment</parameter>
                    </methodparam>
                </methodsynopsis>
            <para>
                Adds an event segment <parameter>pSegment</parameter>
                to the end of the ordered container of
                event segments in the compound.  Very bad things will happen if
                <parameter>pSegment</parameter>'s lifetime is not at least that of
                the event segment.
                </para>
            <methodsynopsis>
                <type>void</type> <methodname>DeleteEventSegment</methodname>
                <methodparam>
                    <type>CEventSegment*</type> <parameter>pSegment</parameter>
                    </methodparam>
                </methodsynopsis>
            <para>
                If <parameter>pSegment</parameter> is one of the immediate
                children of the object, it is removed from the container.
                If not, this is a no-op.  Please note that this is not a deep
                delete.  If <parameter>pSegment</parameter> is actually a child
                of some compound event segment in the container, it will not
                be found and therefore not removed.
                </para>
            <para>
                <parameter>pSegment</parameter> is removed from the container.
                It is up to the calling software, if appropriate, to destroy
                the actual object.
                </para>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>bool</type>
                <methodname>isComposite</methodname>
                <void /><modifier>const</modifier>
                </methodsynopsis>
            <para>
                This returns true.  The member function <methodname>isComposite</methodname>
                is provided in all event segments.  It is true if the object
                implements the interface of the compound event segment.
                </para>
            <methodsynopsis>
                <type>EventSegmentIterator</type>
                <methodname>begin</methodname> <void />
                </methodsynopsis>
            <para>
                Returns a begin of iteration iterator.  See "Types and Public Data"
                below for more about iterators.  See as well <methodname>end</methodname>
                below for typical usage.  This iterator is a shallow iterator.
                </para>
            <methodsynopsis>
                <type>EventSegmentIterator</type>
                <methodname>end</methodname><void />
                </methodsynopsis>
            <para>
                Returns an iterator that points off the end of the container.
                This can be used to determine when the iterator has visited
                all members of the container.  The function below shows a
                typical usage.
                </para>
            <informalexample>
                <programlisting>
CCompoundEventSegment es;
...
CCompoundEventSegment::EventSegmentIterator p = es.begin();
while (p != es.end()) {
    CEventSegment *pSegment = *p;
    //
    // Do something with pSegment:
    ...
    p++;
}
                    </programlisting>
                </informalexample>
            
            <methodsynopsis>
                <type>size_t</type>
                <methodname>size</methodname><void /><modifier>const</modifier>
                </methodsynopsis>
            <para>
                Returns the number of elements in the event segment container.
                This is a shallow count.
                </para>
            <methodsynopsis>
                <type>size_t</type> <methodname>leafCount</methodname> <void />
                </methodsynopsis>
            <para>
                Returns the number of 'terminal' nodes in the hierarchy.  A
                terminal node is one for which <methodname>isComposite</methodname>
                returns <literal>false</literal>.  This is a deep count.
                </para>
            <methodsynopsis>
                <type>size_t</type> <methodname>fullCount</methodname><void />
                </methodsynopsis>
            <para>
                Returns the total number of nodes in the hiearchy.  This is a deep
                count.
                </para>
            <methodsynopsis>
                <type>void</type> <methodname>visit</methodname>
                <methodparam>
                    <type>CVisitor&amp;</type> <parameter>visitor</parameter>
                    </methodparam>
                </methodsynopsis>
            <para>
                Visits each node in the hieararchy and invokes the visitor
                at each node at this level of the hierarchy.  If deep visitation
                is required, then whenever the visitor is handed a node for which
                <methodname>isComposite</methodname> is true, it should invoke
                this method on that node with itself as a parameter.
                </para>
            <para>
                For more on the visitor class, see "Types and public data".
                For a recipe for doing recursive visitation, see "EXAMPLES"
                </para>
      </refsect1>
      <refsect1>
         <title>Types and public data</title>
         <para>
            This class provides an iterator for its container;
            <classname>CCompoundEventSegment::EventSegmentIterator</classname>.
            This is a pointer like object.  When dereferenced the iterator
            returns a <type>CEventSegment*</type> for a segment that is in the
            container.  Increment moves the 'pointer' to the next item
            in the container (shallow iteration).
            </para>
         <para>
            The class provides an abstract base class on which Visitors can be
            built: <classname>CCompoundEventSegment::CVisitor</classname>.
            The definition of this class is shown below:
            <informalexample>
                <programlisting>
  class CVisitor {
  public:
    virtual void operator()(CEventSegment* pSegment) = 0;
  };
                </programlisting>
                </informalexample>
         </para>
         <para>
            The idea is that you would derive a class from that and
            invoke the <methodname>visit</methodname> method with an object
            of that class to do something to all nodes in the container.
            </para>
      </refsect1>
      <refsect1>
         <title>EXAMPLES</title>
         <para>
            This section shows how to do deep iteration both with visitors and
            with iterators.  The key is that whenever a compound is found
            iteration or visitation is done recursively on that compond.
         </para>
        <example>
            <title>Deep iteration of <classname>CCompondEventSegment</classname> elements</title>
            <programlisting>
/*
   Do something to all leaf nodes of the event segment
   hierarchy
*/
void doSomething(CCompoundEventSegment* pSegment)
{
    CCompoundEventSegment::EventSegmentIterator p = pSegment-&gt;begin();
    while (p != pSegment&gt;end()) {
        CEventSegment* pSeg = *p;
        if (pSeg&gt;isComposite()) {
            doSomething(pSeg);     // Recurse to go deep.
        }
        else {
           // Do whatever needs doing here....
        }
        p++;
    }
}
                </programlisting>
            </example>
        <example>
            <title>Deep visitation of <classname>CCompoundEventSegment</classname> elements</title>
            <programlisting>
class MyVisitor : public CCompoundEventSegment::CVisitor
{
    virtual void operator()(CEventSegment* pSeg)
    {
        if (pSeg&gt;isCompound()) {
            pSeg&gt;visit(*this);
        }
        else {
            // Do what needs doing to terminal nodes....
        }
    }
};
...
CCompoundEventSegment segment;
MyVisitor visitor;
segment.visit(visitor);  // Visitor ensures deep visitation.

                </programlisting>
            </example>
        
      </refsect1>
      <refsect1>
         <title>
            SEE ALSO
         </title>
     <para>
        <link linkend='manpage.ceventsegment'>CEventSegment(3sbsReadout)</link>
     </para>
      </refsect1>
   </refentry>


    <refentry id="manpage.cdocumentedpacket">
      <refmeta>
         <refentrytitle>CDocumentedPacket</refentrytitle>
         <manvolnum>3sbsReadout</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>CDocumentedPacket</refname>
     <refpurpose>Encapsulate event data in a packet that is documented.</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;CDocumentedPacket&gt;
         </programlisting>
         <classsynopsis>
            <ooclass><classname>CDocumentedPacket</classname></ooclass>
            <constructorsynopsis>
                <methodname>CDocumentedPacket</methodname>
                <methodparam>
                    <type>unsigned short</type> <parameter>nTag</parameter>
                    </methodparam>
                <methodparam>
                    <modifier>const</modifier> <type>std::string&amp;</type>
                    <parameter>rName</parameter>
                    </methodparam>
                <methodparam>
                    <modifier>const</modifier> <type>std::string&amp;</type>
                    <parameter>Description</parameter>
                    </methodparam>
                <methodparam>
                    <modifier>const</modifier> <type>std::string&amp;</type>
                    <parameter>rVersion</parameter>
                    </methodparam>
                </constructorsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>operator==</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CDocumentedPacket&amp;</type>
                    <parameter>rhs</parameter>
                    </methodparam>
                <modifier>const</modifier>
                </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>operator==</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>std::string&amp;</type>
                    <parameter>rhs</parameter>
                    </methodparam>
                <modifier>const</modifier>
                </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>operator!=</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CDocumentedPacket&amp;</type>
                    <parameter>rhs</parameter>
                    </methodparam>
                <modifier>const</modifier>
                </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>operator!=</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>std::string&amp;</type>
                    <parameter>rhs</parameter>
                    </methodparam>
                <modifier>const</modifier>
                </methodsynopsis>
            <methodsynopsis>
                <type>unsigned short</type> <methodname>getTag</methodname>
                <void /><modifier>const</modifier>
                </methodsynopsis>
            <methodsynopsis>
                <type>std::string</type> <methodname>getName</methodname>
                <void /><modifier>const</modifier>
                </methodsynopsis>
            <methodsynopsis>
                <type>std::string</type> <methodname>getDescription</methodname>
                <void /><modifier>const</modifier>
                </methodsynopsis>
            <methodsynopsis>
                <type>std::string</type> <methodname>getVersion</methodname>
                <void /><modifier>const</modifier>
                </methodsynopsis>
            <methodsynopsis>
                <type>std::string</type> <methodname>getInstantiationDate</methodname>
                <void /><modifier>const</modifier>
                </methodsynopsis>
            <methodsynopsis>
                <type>unsigned short*</type> <methodname>getHeaderPtr</methodname>
                <void /><modifier>const</modifier>
                </methodsynopsis>
            <methodsynopsis>
                <type>bool</type> <methodname>getPacketInProgress</methodname>
                <void /><modifier>const</modifier>
                </methodsynopsis>
            <methodsynopsis>
                <type>std::string</type> <methodname>Format</methodname>
                <void />
                </methodsynopsis>
            <methodsynopsis>
                <type>unsigned short*</type> <methodname>Begin</methodname>
                <methodparam>
                    <type>unsigned short*</type> <parameter>rPointer</parameter>
                    </methodparam>
                </methodsynopsis>
            <methodsynopsis>
                <type>unsigned short*</type> <methodname>End</methodname>
                <methodparam>
                    <type>unsigned short*</type> <parameter>rBuffer</parameter>
                    </methodparam>
                </methodsynopsis>
         </classsynopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
            NSCL data taking programs should try to emit self describing event
            data.  This is facilitated by providing code to support the generation
            of <firstterm>packets</firstterm>.  A packet is a chunk of event data
            with a three word header.  The first longword (32 bits), is the
            number of words in the packet, including the header.  The last word
            of the header is an identifying code.  The remainder of the packet
            are the data read out for that identifying code.
         </para>
         <para>
            <ulink url="http://groups.nscl.msu.edu/userinfo/daq/nscltags.html">
                http://groups.nscl.msu.edu/userinfo/daq/nscltags.html</ulink>
            defines the set of identifiers (tags) that are defined.  The tag assigner
            for permanent devices is
            <ulink url="mailto:bazin@nscl.msu.edu">bazin at nscl dot msu dot edu</ulink>.
            Contact him if you need a new tag assigned.
            </para>
         <para>
            The <classname>CDocumentedPacket</classname> class goes a step further
            than encapsulating your data.  It registers itself with the framework
            in a way that allows the framework to emit data that describes the set
            of tags, and versions to expect in the event data.
            </para>
      </refsect1>
      <refsect1>
         <title>
            Public member functions
         </title>
           <methodsynopsis><type></type>
            <methodname>CDocumentedPacket</methodname>
            <methodparam>
                <type>unsigned short</type> <parameter>nTag</parameter>
                </methodparam>
            <methodparam>
                <modifier>const</modifier> <type>std::string&amp;</type>
                <parameter>rName</parameter>
                </methodparam>
            <methodparam>
                <modifier>const</modifier> <type>std::string&amp;</type>
                <parameter>Description</parameter>
                </methodparam>
            <methodparam>
                <modifier>const</modifier> <type>std::string&amp;</type>
                <parameter>rVersion</parameter>
                </methodparam>
            </methodsynopsis>
        <para>
            Constructs a documented packet.  <parameter>nTag</parameter> is the
            packet id and is the tag assigned to the packet, or one of the user
            defined tags.
            </para>
        <para>
            <parameter>rName</parameter> is a short name for the tag.  In the tag table
            at
            <ulink url="http://groups.nscl.msu.edu/userinfo/daq/nscltags.html">
                    http://groups.nscl.msu.edu/userinfo/daq/nscltags.html</ulink>,
            this is the value of the <emphasis>Acronym</emphasis> column.
            <parameter>Description</parameter> is a more verbose description
            and might be the <emphasis>Description</emphasis> column of that
            table.  <parameter>rVersion</parameter> is a string that allows you
            to indicate changes in the internal structure of this packet over time.
            This can allow analysis software to dynamically adapt to data format
            changes by knowing which data format is actually in the packet.
            </para>
        <methodsynopsis>
            <type>int</type> <methodname>operator==</methodname>
            <methodparam>
                <modifier>const</modifier> <type>CDocumentedPacket&amp;</type>
                <parameter>rhs</parameter>
                </methodparam>
            <modifier>const</modifier>
            </methodsynopsis>

        <methodsynopsis>
            <type>int</type> <methodname>operator==</methodname>
            <methodparam>
                <modifier>const</modifier> <type>std::string&amp;</type>
                <parameter>rhs</parameter>
                </methodparam>
            <modifier>const</modifier>
            </methodsynopsis>
        <methodsynopsis>
            <type>int</type> <methodname>operator!=</methodname>
            <methodparam>
                <modifier>const</modifier> <type>CDocumentedPacket&amp;</type>
                <parameter>rhs</parameter>
                </methodparam>
            <modifier>const</modifier>
            </methodsynopsis>
        <methodsynopsis>
            <type>int</type> <methodname>operator!=</methodname>
            <methodparam>
                <modifier>const</modifier> <type>std::string&amp;</type>
                <parameter>rhs</parameter>
                </methodparam>
            <modifier>const</modifier>
            </methodsynopsis>
        <methodsynopsis>
            <type>unsigned short</type> <methodname>getTag</methodname>
            <void /><modifier>const</modifier>
            </methodsynopsis>
        <para>
            Returns the tag that has been assigned to this documented packet.
            </para>            
        <methodsynopsis>
            <type>std::string</type> <methodname>getName</methodname>
            <void /><modifier>const</modifier>
            </methodsynopsis>
        <para>
            Returns the short name assigned to the packet
            </para>
        <methodsynopsis>
            <type>std::string</type> <methodname>getDescription</methodname>
            <void /><modifier>const</modifier>
            </methodsynopsis>
        <para>
            Returns the long description assigned to the packet.
            </para>
        <methodsynopsis>
            <type>std::string</type> <methodname>getVersion</methodname>
            <void /><modifier>const</modifier>
            </methodsynopsis>
        <para>
            Returns the packet version string
            </para>
        <methodsynopsis>
            <type>std::string</type> <methodname>getInstantiationDate</methodname>
            <void /><modifier>const</modifier>
            </methodsynopsis>
        <para>
            When a packet object is created a timestamp indicating when the object
            was create is also created.  This returns that timestamp.  The
            idea of this is to be able to account for any format changes that
            might have occured during an experiment that were accidently not
            reflected by updating the version of the packet.
            </para>
        <methodsynopsis>
            <type>unsigned short*</type> <methodname>getHeaderPtr</methodname>
            <void /><modifier>const</modifier>
            </methodsynopsis>
        <para>
            Returns a pointer to the header of the packet.  This is only meaningful
            if the packet is in the process of being emitted.  See
            <methodname>getPacketInProgress</methodname> below.
            </para>
        <methodsynopsis>
            <type>bool</type> <methodname>getPacketInProgress</methodname>
            <void /><modifier>const</modifier>
            </methodsynopsis>
        <para>
            Returns
            <literal>true</literal> if the packet is in the process of being built.
            </para>
        <methodsynopsis>
            <type>std::string</type> <methodname>Format</methodname>
            <void />
            </methodsynopsis>
        <para>
            Returns an information string about the packet that can be
            inserted in to a packet documentation event.
            </para>
        <methodsynopsis>
            <type>unsigned short*</type> <methodname>Begin</methodname>
            <methodparam>
                <type>unsigned short*</type> <parameter>rPointer</parameter>
                </methodparam>
            </methodsynopsis>
        <para>
            Starts the creation of a packet.  <parameter>rPointer</parameter>
            points to the location in memory in which the packet will be built.
            The function returns a pointer to the packet body.  The caller should
            not refrence the packet header directly.
            </para>
        <methodsynopsis>
            <type>unsigned short*</type> <methodname>End</methodname>
            <methodparam>
                <type>unsigned short*</type> <parameter>rBuffer</parameter>
                </methodparam>
            </methodsynopsis>
        <para>
            Indicates that the packet body has been filled in.  <parameter>rBuffer</parameter>
            points to the first word after the packet.  It is used to compute and
            fill in the packet length header field.
            </para>
      </refsect1>
      <refsect1>
        <title>EXCEPTIONS</title>
        <para>
            Under several circumstances, this class can throw a
            <link linkend='manpage.cinvalidpacketstateexception'>
                <classname>CInvalidPacketStateException</classname>
            </link>
            </para>
        <para>
            Specifically attempting to begin a packet that's already begun or
            ending a packet that's already ended, will cause this to be thrown.
            </para>
         </refsect1>
      <refsect1>
         <title>EXAMPLES</title>
        <example>
            <title>Using the <classname>CDocumentedPacket</classname> class</title>
            <programlisting>
class MySegment : public CEventSegment
{
private:
    CDocumentedPacket m_Packet;
public:
    MySegment() :
        CDocumentedPacket(0x1234, "Test", "A test packet", "T1.0")
    {
        
    }
    size_t read(void* pBuffer, size_t maxlen);
    ...
}
size_t
MySegment::read(void* pBuffer, size_t maxlen)
{
    uint16_t* p = reinterpret_cast&lt;uint16_t*&gt;(pBuffer);
    
    uint16_t pBody = m_Packet.Begin(p);
    
    // Fill in packet body incrementing pBody
    ...
    
    m_Packet.End(pBody);
}
                </programlisting>
            </example>
      </refsect1>
    <refsect1>
        <title>SEE ALSO</title>
        <para>
            <link linkend='manpage.ceventpacket'>CEventPacket(3sbsReadout)</link>
        </para>
        </refsect1>
   </refentry>

    <refentry id="manpage.ceventpacket">
      <refmeta>
         <refentrytitle>CEventPacket</refentrytitle>
         <manvolnum>3sbsReadout</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>CEventPacket</refname>
     <refpurpose>Encapsulate an event segment in a documented packet.</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;CEventPacket&gt;
         </programlisting>
         <classsynopsis>
            <ooclass><classname>CEventPacket : public CEventSegment</classname></ooclass>
            <constructorsynopsis>
                <methodname>CEventPacket</methodname>
                <methodparam>
                    <type>CEventSegment&amp;</type>   <parameter>seg</parameter>
                    </methodparam>
                <methodparam>
                    <type>short</type> <parameter>tag</parameter>
                    </methodparam>
                <methodparam>
                    <type>std::string</type> <parameter>name</parameter>
                    </methodparam>
                <methodparam>
                    <type>std::string</type> <parameter>description</parameter>
                    </methodparam>
                <methodparam>
                    <type>std::string</type> <parameter>version</parameter>
                    </methodparam>
                </constructorsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type> <methodname>initialize</methodname>
                <void />
                </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type> <methodname>clear</methodname>
                <void />
                </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type> <methodname>disable</methodname>
                <void />
                </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>size_t</type> <methodname>read</methodname>
                <methodparam>
                    <type>void*</type> <parameter>pBuffer</parameter>
                    </methodparam>
                <methodparam>
                    <type>size_t</type> <parameter>maxwords</parameter>
                    </methodparam>
                </methodsynopsis>
          

         </classsynopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
            This class allows you to wrap an existing event segment in a documented
            packet without modification to the event segment.
         </para>
      </refsect1>
      <refsect1>
         <title>
            Public member functions
         </title>
            <methodsynopsis><type></type>
                <methodname>CEventPacket</methodname>
                <methodparam>
                    <type>CEventSegment&amp;</type>   <parameter>seg</parameter>
                    </methodparam>
                <methodparam>
                    <type>short</type> <parameter>tag</parameter>
                    </methodparam>
                <methodparam>
                    <type>std::string</type> <parameter>name</parameter>
                    </methodparam>
                <methodparam>
                    <type>std::string</type> <parameter>description</parameter>
                    </methodparam>
                <methodparam>
                    <type>std::string</type> <parameter>version</parameter>
                    </methodparam>
                </methodsynopsis>
            <para>
                Creates the object.  <parameter>seg</parameter> is a reference
                to the event segment you want to wrap in a packet.  All the
                remaining parameters define the packet as in
                <link linkend='manpage.cdocumentedpacket'>CDocumentedPacket(3sbsReadout)</link>
                </para>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type> <methodname>initialize</methodname>
                <void />
                </methodsynopsis>
            <para>
                Invokes the <methodname>initialize</methodname> method of the
                event segment
                used to construct this object.
                </para>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type> <methodname>clear</methodname>
                <void />
                </methodsynopsis>
            <para>
                Invokes the <methodname>clear</methodname> method of the
                evnet segment used to create this object.
                </para>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type> <methodname>disable</methodname>
                <void />
                </methodsynopsis>
            <para>
                Invokes the event segment's <methodname>disable</methodname> method.
                </para>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>size_t</type> <methodname>read</methodname>
                <methodparam>
                    <type>void*</type> <parameter>pBuffer</parameter>
                    </methodparam>
                <methodparam>
                    <type>size_t</type> <parameter>maxwords</parameter>
                    </methodparam>
                </methodsynopsis>
            <para>
                Begins the packet, invokes the <methodname>read</methodname>
                method of the encapsulated event segment and ends the
                packet.
                </para>

      </refsect1>
      <refsect1>
         <title>
            SEE ALSO
         </title>
     <para>
        <link linkend='manpage.cdocumentedpacket'>CDocumentedPacket(3sbsReadout)</link>
        <link linkend='manpage.ceventsegment'>CEventSegment(3sbsReadout)</link>
     </para>
      </refsect1>
   </refentry>

    <refentry id="manpage.ceventsegment">
      <refmeta>
         <refentrytitle id="manpage.ceventsegment_title">CEventSegment</refentrytitle>
         <manvolnum>3sbsReadout</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>CEventSegment</refname>
     <refpurpose>Base class for all event segments.</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;CEventSegment.h&gt;
         </programlisting>
         <synopsis>
            class <ooclass><classname>CEventSegment</classname></ooclass> {
         </synopsis>
         <programlisting>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>void</type> <methodname>initialize</methodname>
                <void />
                </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>void</type> <methodname>clear</methodname>
                <void />
                </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>void</type>   <methodname>disable</methodname>
                <void />
                </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>size_t</type> <methodname>read</methodname>
                <methodparam>
                    <type>void*</type> <parameter>pBuffer</parameter>
                    </methodparam>
                <methodparam>
                    <type>size_t</type> <parameter>maxwords</parameter>
                </methodparam>
                <modifier>=0</modifier>
            </methodsynopsis>
	    <methodsynopsis>
	      <modifier>virtual</modifier>
	      <type>void</type> <methodname>onBegin</methodname>
	      <void />
	    </methodsynopsis>
	    <methodsynopsis>
	      <modifier>virtual</modifier>
	      <type>void</type> <methodname>onEnd</methodname>
	      <void />
	    </methodsynopsis>
	    <methodsynopsis>
	      <modifier>virtual</modifier>
	      <type>void</type> <methodname>onPause</methodname>
	      <void />
	    </methodsynopsis>
	    <methodsynopsis>
	      <modifier>virtual</modifier>
	      <type>void</type> <methodname>onResume</methodname>
	      <void />
	    </methodsynopsis>
	    
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>bool</type> <methodname>isComposite</methodname>
                <void /><modifier>const</modifier>
                </methodsynopsis>
            <!-- SW triggers -->
            <methodsynopsis>
                <type>void</type><methodname>reject</methodname>
                <void />
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type><methodname>rejectImmediately</methodname>
                <void />
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type><methodname>keep</methodname>
                <void />
            </methodsynopsis>
            <methodsynopsis>
                <type>CEventSegment::AcceptState</type><methodname>getAcceptState</methodname>
                <void /> <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type><methodname>setTimestamp</methodname>
                <methodparam>
                    <type>uint64_t</type><parameter>stamp</parameter>
                    </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type><methodname>setSourceId</methodname>
                <methodparam>
                    <type>uint32_tr</type><parameter>id</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>uint32_t</type> <methodname>getSourceId</methodname>
                <void />
            </methodsynopsis>
                
        };
         </programlisting>
      </refsynopsisdiv>
      <refsect1>
         <title>DESCRIPTION</title>
         <para>
            Event segments are a logical unit of an experiment readout.
            <classname>CEventSegment</classname> is an abstract base class
            that provides default implementations for most of the interface
            for an event segment as well as a pure virtual function as an
            interface placeholder for the readout of the segment itself.
         </para>
      </refsect1>
      <refsect1>
         <title>PUBLIC MEMBER FUNCTIONS</title>
        <methodsynopsis>
            <modifier>virtual</modifier>
            <type>void</type> <methodname>initialize</methodname>
            <void />
            </methodsynopsis>
        <para>
            This is called as the runs becomes active (begin or resume).  It
            should be overidden by concrete classes to provide code that
            sets up the hardware used by the segment and makes it ready for
            data taking.  The default implementation of this method is to do
            nothing.
            </para>
        <methodsynopsis>
            <modifier>virtual</modifier>
            <type>void</type> <methodname>clear</methodname>
            <void />
            </methodsynopsis>
        <para>
            Called to clear the data taking hardware just prior to releasing
            the busy and enabling gates.   This happens prior to the initial
            enable of response to triggers as well as after each event is read.
            Default action is to do nothing.
            </para>
        <methodsynopsis>
            <modifier>virtual</modifier>
            <type>void</type>   <methodname>disable</methodname>
            <void />
            </methodsynopsis>
        <para>
            Called to disable the electronics.  The default does nothing.
            </para>
        <methodsynopsis>
            <modifier>virtual</modifier>
            <type>size_t</type> <methodname>read</methodname>
            <methodparam>
                <type>void*</type> <parameter>pBuffer</parameter>
                </methodparam>
            <methodparam>
                <type>size_t</type> <parameter>maxwords</parameter>
                </methodparam>
            <modifier>=0</modifier>
            </methodsynopsis>
        <para>
            This must be suplied by concrete classes for them to be
            concrete classes.  This method is supposed to read out the electronics
            associated with the event segment and put it in <parameter>pBuffer</parameter>.
            At most <parameter>maxwords</parameter> words of data should be read.
            </para>
	    <methodsynopsis>
	      <modifier>virtual</modifier>
	      <type>void</type> <methodname>onBegin</methodname>
	      <void />
	    </methodsynopsis>
	    <para>
	      This method is invoked when the begin run event has been sent out
	      but before the readout program is responding to event triggers.
	      The base class implementation is to do nothing, so this is an optional
	      method.
	    </para>
	    <methodsynopsis>
	      <modifier>virtual</modifier>
	      <type>void</type> <methodname>onEnd</methodname>
	      <void />
	    </methodsynopsis>
	    <para>
	      This method is invoked after the trigger loop has stopped responding
	      to triggers as the run is ending but before the end run event has been 
	      emitted.
	      The base class method is to do nothing making this an optional method.
	    </para>
	    <methodsynopsis>
	      <modifier>virtual</modifier>
	      <type>void</type> <methodname>onPause</methodname>
	      <void />
	    </methodsynopsis>
	    <para>
	      This method is invoked after the trigger loop has stopped responding
	      to triggers as the run is pausing, but before the pause run event has
	      been emitted.
	      The base class method does nothing making this an optional method.
	    </para>
	    <methodsynopsis>
	      <modifier>virtual</modifier>
	      <type>void</type> <methodname>onResume</methodname>
	      <void />
	    </methodsynopsis>
	    <para>
	      This method is invoked after a resume event has been emitted when a run
	      is resuming but before the trigger thread has begun to poll for triggers.
	      The base class method does nothing making this an optional method.
	    </para>
        <methodsynopsis>
            <modifier>virtual</modifier>
            <type>bool</type> <methodname>isComposite</methodname>
            <void /><modifier>const</modifier>
            </methodsynopsis>
        <para>
            If the event segment contains other segments and those segments can
            be queried via the same interfaces supported by
            <classname>CCompoundEventSegment</classname>, this should return
            <literal>true</literal> <literal>false</literal> if not.
            </para>
        
        <methodsynopsis>
            <type>void</type><methodname>reject</methodname>
            <void />
        </methodsynopsis>
        <para>
            This can be called from <methodname>read</methodname> to indicate
            the framework should not keep the event.  The remainder of the
            event segments registered with the experiment are run unless a subsequent
            one calls <methodname>rejectImmediately</methodname> (see below).
        </para>
        <methodsynopsis>
            <type>void</type><methodname>rejectImmediately</methodname>
            <void />
        </methodsynopsis>
        <para>
            This can be called  from <methodname>read</methodname> to indicate
            the framework should not keep the event.  Processing of event
            segments stops with the return from <methodname>read</methodname>
            if this is called.
        </para>
        <methodsynopsis>
            <type>void</type><methodname>keep</methodname>
            <void />
        </methodsynopsis>
        <para>
            This is called by the framework to initalize the event segment
            accept state.  It can also be called to change your mind about
            rejecting an event.  If used in this manner, <methodname>keep</methodname>
            must be called within the same event segment that invoked
            <methodname>reject</methodname> or <methodname>rejectimmediately</methodname>.
        </para>
        <methodsynopsis>
            <type>CEventSegment::AcceptState</type><methodname>getAcceptState</methodname>
            <void /> <modifier>const</modifier>
        </methodsynopsis>
        <para>
            Returns the value of the accept state as set by the methods
            <methodname>keep</methodname>, <methodname>reject</methodname> and
            <methodname>rejectImmdediately</methodname>.  See PUBLIC TYPES AND VARIABLES
            below for possible return values.
        </para>
        <para>
            Normally this only needs to be called by the framework.  Since each
            event segement has its own acceptance state, this cannot be used
            to determine if the event has been marked for rejection by another
            event segment.
        </para>
        <methodsynopsis>
            <type>void</type><methodname>setTimestamp</methodname>
            <methodparam>
                <type>uint64_t</type><parameter>stamp</parameter>
                </methodparam>
        </methodsynopsis>
        <para>
            This should be called from the <methodname>read</methodname> method
            of at least one event segmetn when Readout is a data source for
            event building.  The method sets the event timestamp.  If called
            more than once, the last call in the event readout specifies the time.
            </para>
        <methodsynopsis>
            <type>void</type><methodname>setSourceId</methodname>
            <methodparam>
                <type>uint32_tr</type><parameter>id</parameter>
            </methodparam>
        </methodsynopsis>
        <para>
            Called by an event segment to set the source id.  Normally
            this is set at the command line via the <option>--sourceid</option>
            option.
        </para>
        <methodsynopsis>
            <type>uint32_t</type> <methodname>getSourceId</methodname>
            <void />
        </methodsynopsis>
        <para>
            Returns the experiment's source id.
        </para>
      </refsect1>
      <refsect1>
        <title>PUBLIC TYPES AND VARIABLES</title>
        <para>
            <type>CEventSegment::AcceptState</type> is an enum that describes how the event
            should be disposed of after the segment returns from <methodname>read</methodname>.
            This type can take the following values:
        </para>
        <variablelist>
            <varlistentry>
                <term><literal>CEventSegment::keep</literal></term>
                <listitem>
                    <para>
                        Indicates the event segment wants the framework to keep the
                        event.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><literal>CEventSegement::reject</literal></term>
                <listitem>
                    <para>
                        Indicates that the event segment wants the framework to
                        reject the event but that the remainder of the event
                        segments should keep running.  This takes precedence
                        over <literal>CEventSegment::keep</literal>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><literal>CEventSegment::rejectImmediately</literal></term>
                <listitem>
                    <para>
                        Same meaning as <literal>CExperiment::reject</literal>
                        except that this requests that no more event segments
                        be run.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
      </refsect1>
   </refentry>

    <refentry id="manpage.ceventtrigger">
        <refentryinfo>
            <author>
                <personname>
                    <firstname>Ron</firstname>
                    <surname>Fox</surname>
                </personname>
            </author>
            <productname>NSCLDAQ</productname>
            <productnumber></productnumber>
        </refentryinfo>
        <refmeta>
         <refentrytitle>CEventTrigger</refentrytitle>
         <manvolnum>3sbsReadout</manvolnum>
         <refmiscinfo class='empty'></refmiscinfo>
      </refmeta>
      <refnamediv>
         <refname>CEventTrigger</refname>
     <refpurpose>Abstract base class for triggers.</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;CEventTrigger&gt;
         </programlisting>
         <synopsis>
            class <ooclass><classname>CEventTrigger</classname></ooclass> {
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>void</type> <methodname>setup</methodname>
                <void />
                </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>void</type> <methodname>teardown</methodname>
                <void />
                </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>bool</type> <methodname>operator()</methodname>
                <void /><modifier>= 0</modifier>
                </methodsynopsis>
        };
        </synopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
            Event triggers are responsible for kicking off event and scaler
            readouts.  <classname>CEventTrigger</classname> is an
            abstract base class
            on which event triggers must be built. 
         </para>
      </refsect1>
      <refsect1>
         <title>
            Public member functions
         </title>
        <methodsynopsis>
            <modifier>virtual</modifier>
            <type>void</type> <methodname>setup</methodname>
            <void />
            </methodsynopsis>
        <para>
            Inititialize the trigger hardware.  By default this is a no-op.
            </para>
        <methodsynopsis>
            <modifier>virtual</modifier>
            <type>void</type> <methodname>teardown</methodname>
            <void />
            </methodsynopsis>
        <para>
            Disable the trigger hardware.  By default this is a no-op.
            </para>
        <methodsynopsis>
            <modifier>virtual</modifier>
            <type>bool</type> <methodname>operator()</methodname>
            <void /><modifier>= 0</modifier>
            </methodsynopsis>
        <para>
            Check for a trigger.  Return <literal>true</literal>
            if there is a trigger <literal>false</literal> otherwise.
            This must be implemented by concrete classes as it is pure virtual
            in this class.
            </para>
      </refsect1>
   </refentry>

    <refentry id="manpage.cexperiment">
      <refmeta>
         <refentrytitle>CExperiment</refentrytitle>
         <manvolnum>3sbsReadout</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>CExperiment</refname>
     <refpurpose>Encapsulate the experiment.</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;CExperiment&gt;
         </programlisting>
         <synopsis>
            <ooclass><classname>CExperiment</classname></ooclass>
            <constructorsynopsis>
                <methodname>CExperiment</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>ringName</parameter>
                    </methodparam>
                <methodparam>
                    <type>size_t</type> <parameter>eventBufferSize</parameter>
                    <initializer>4096</initializer>
                    </methodparam>
                </constructorsynopsis>
            <methodsynopsis>
                <type>CEventTrigger*</type> <methodname>getEventTrigger</methodname>
                <void/>
                </methodsynopsis>
            <methodsynopsis>
                <type>CEventTrigger*</type> <methodname>getScalerTrigger</methodname>
                <void />
                </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>setBufferSize</methodname>
                <methodparam>
                    <type>size_t</type> <parameter>newSize</parameter>
                    </methodparam>
                </methodsynopsis>
            <methodsynopsis>
                <type>size_t</type> <methodname>getBufferSize</methodname>
                <void /> <modifier>const</modifier>
                </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>Start</methodname>
                <methodparam>
                    <type>bool</type> <parameter>resume</parameter><initializer>false</initializer>
                    </methodparam>
                </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>Stop</methodname>
                <methodparam>
                    <type>bool</type> <parameter>pause</parameter>
                    <initializer>false</initializer>
                    </methodparam>
                </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>AddEventSegment</methodname>
                <methodparam>
                    <type>CEventSegment*</type> <parameter>pSegment</parameter>
                    </methodparam>
                </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>RemoveEventSegment</methodname>
                <methodparam>
                    <type>CEventSegment*</type> <parameter>pSegment</parameter>
                    </methodparam>
                </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>AddScalerModule</methodname>
                <methodparam>
                    <type>CScaler*</type>  <parameter>pModule</parameter>
                    </methodparam>
                </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>RemoveScalerModule</methodname>
                <methodparam>
                    <type>CScaler*</type> <parameter>pModule</parameter>
                    </methodparam>
                </methodsynopsis>
            <methodsynopsis>
                <type>void</type>  <methodname>EstablishTrigger</methodname>
                <methodparam>
                    <type>CEventTrigger*</type> <parameter>pEventTrigger</parameter>
                    </methodparam>
                </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>setScalerTrigger</methodname>
                <methodparam>
                    <type>CEventTrigger*</type> <parameter>pScalerTrigger</parameter>
                    </methodparam>
                </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>EstablishBusy</methodname>
                <methodparam>
                    <type>CBusy*</type> <parameter>pBusyModule</parameter>
                    </methodparam>
                </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>ReadEvent</methodname>
                <void />
                </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>TriggerScalerReadout</methodname>
                <void />
                </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>DocumentPackets</methodname>
                <void />
                </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>ScheduleRunVariableDump</methodname>
                <void />
                </methodsynopsis>
            <methodsynopsis>
                <type>CRingBuffer*</type> <methodname>getRing</methodname>
                <void />
            </methodsynopsis>
         </synopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
            Most of the functionality of an experiment is encapsulated in or
            reachable via the <classname>CExperiment</classname> class.  This
            has methods for configuration as well as several well defined methods
            that are invoked by the framework at specific points in the run-time
            of the system.
         </para>
      </refsect1>
      <refsect1>
         <title>
            Public member functions
         </title>
        <methodsynopsis>
            <methodname>CExperiment</methodname>
            <methodparam>
                <type>std::string</type> <parameter>ringName</parameter>
                </methodparam>
            <methodparam>
                <type>size_t</type> <parameter>eventBufferSize</parameter>
                <initializer>4096</initializer>
                </methodparam>
            </methodsynopsis>
        <para>
            Constructs the <classname>CExperiment</classname> object.  The
            framework generally only has one experiment object live at a time.
            <parameter>ringName</parameter> is the name of the ring buffer into
            which data will bge put.  This is the name of a local ring buffer.
            </para>
        <para>
            <parameter>eventBufferSize</parameter> is the size of the buffer
            created to hold events.  No event can be larger than this size.
            The size can be changed via a call to
            <methodname>setBufferSize</methodname>.
            </para>
        <methodsynopsis>
            <type>CEventTrigger*</type> <methodname>getEventTrigger</methodname>
            <void/>
            </methodsynopsis>
        <para>
            Returns a pointer to the <type>CEventTrigger</type> object that will
            be used to trigger a readout of the event segment of the experiment.
            </para>
        <methodsynopsis>
            <type>CEventTrigger*</type> <methodname>getScalerTrigger</methodname>
            <void />
            </methodsynopsis>
        <para>
            Returns a pointer to the <classname>CEventTrigger</classname>  that will be used
            to trigger a readout of the scaler bank in the experiment.
            </para>
        <methodsynopsis>
            <type>void</type> <methodname>setBufferSize</methodname>
            <methodparam>
                <type>size_t</type> <parameter>newSize</parameter>
                </methodparam>
            </methodsynopsis>
        <para>
            Sets the event buffer size to <parameter>newSize</parameter>
            16 bit words. Ifyour experiment is taking large events that may overflow
            the default buffer size you may want to invoke this from
            your <methodname>Skeleton::SetupReadout</methodname> method.
            </para>
        <methodsynopsis>
            <type>size_t</type> <methodname>getBufferSize</methodname>
            <void /> <modifier>const</modifier>
            </methodsynopsis>
        <para>
            Returns the current event buffer size.
            </para>
        <methodsynopsis>
            <type>void</type> <methodname>Start</methodname>
            <methodparam>
                <type>bool</type> <parameter>resume</parameter><initializer>false</initializer>
                </methodparam>
            </methodsynopsis>
        <para>
            Invoked by the framework to start data taking.  If <parameter>resume</parameter>
            is <literal>true</literal> the run is being restarted
            after being paused.
            </para>
        <methodsynopsis>
            <type>void</type> <methodname>Stop</methodname>
            <methodparam>
                <type>bool</type> <parameter>pause</parameter>
                <initializer>false</initializer>
                </methodparam>
            </methodsynopsis>
        <para>
            Invoked by the framework to stop data taking.  If
            data is being suspended due to a pause, <parameter>pause</parameter>
            will be <literal>true</literal>.
            </para>
        <methodsynopsis>
            <type>void</type> <methodname>AddEventSegment</methodname>
            <methodparam>
                <type>CEventSegment*</type> <parameter>pSegment</parameter>
                </methodparam>
            </methodsynopsis>
        <para>
            Add an event segment to the top level event segment in the experiment.
            <parameter>pSegment</parameter> is the segment to add to the top
            level <classname>CCompoundEventSegment</classname> in the
            experiment.  Note that <parameter>pSegment</parameter> could itself
            point to a <classname>CCompoundEventSegment</classname> object.
            </para>
        <methodsynopsis>
            <type>void</type> <methodname>RemoveEventSegment</methodname>
            <methodparam>
                <type>CEventSegment*</type> <parameter>pSegment</parameter>
                </methodparam>
            </methodsynopsis>
        <para>
            Remove an event segment from the top level event segment in
            the experiment. If <parameter>pSegment</parameter> points to an
            event segment in the top level <classname>CCompoundEventSegment</classname>
            it is removed.  Otherwise this function does nothing.
            </para>
        <methodsynopsis>
            <type>void</type> <methodname>AddScalerModule</methodname>
            <methodparam>
                <type>CScaler*</type>  <parameter>pModule</parameter>
                </methodparam>
            </methodsynopsis>
        <para>
            Adds a scaler module to the top level scaler bank in the
            experiement.  <parameter>pModule</parameter> is added to
            the end of the collection of modules in the bank.  Note that
            <parameter>pModule</parameter> might itself point to a
            <classname>CScalerBank</classname> object.
              </para>
        <methodsynopsis>
            <type>void</type> <methodname>RemoveScalerModule</methodname>
            <methodparam>
                <type>CScaler*</type> <parameter>pModule</parameter>
                </methodparam>
            </methodsynopsis>
        <para>
            Removes a scaler object from the top level scaler bank.
            If <parameter>pModule</parameter> is in the
            top level <classname>CScalerBank</classname> object it is removed.
            If not, this method does nothing.
            </para>
        <methodsynopsis>
            <type>void</type>  <methodname>EstablishTrigger</methodname>
            <methodparam>
                <type>CEventTrigger*</type> <parameter>pEventTrigger</parameter>
                </methodparam>
            </methodsynopsis>
        <para>
            Establishes the event trigger.   The trigger for the top level
            event segment readout is set <parameter>pEventTrigger</parameter>.
            When this <classname>CEventTrigger</classname> object's
            <methodname>operator()</methodname> returns <literal>true</literal>
            when polled during data taking, the event segment will be read.
            </para>
        <methodsynopsis>
            <type>void</type> <methodname>setScalerTrigger</methodname>
            <methodparam>
                <type>CEventTrigger*</type> <parameter>pScalerTrigger</parameter>
                </methodparam>
            </methodsynopsis>
        <para>
            Sets the scaler trigger to <parameter>pScalerTrigger</parameter>.
            During data taking this trigger's <methodname>operator()</methodname>
            is polled.  When it returns <literal>true</literal> the top level
            scaler bank will be read.
            </para>
        <methodsynopsis>
            <type>void</type> <methodname>EstablishBusy</methodname>
            <methodparam>
                <type>CBusy*</type> <parameter>pBusyModule</parameter>
                </methodparam>
            </methodsynopsis>
        <para>
            Sets <parameter>pBusyModule</parameter> to be the object that
            will be used to handle the external computer busy hardware.
            </para>
        <methodsynopsis>
            <type>void</type> <methodname>ReadEvent</methodname>
            <void />
            </methodsynopsis>
        <para>
            Called by the trigger thread to read an event.
            </para>
        <methodsynopsis>
            <type>void</type> <methodname>TriggerScalerReadout</methodname>
            <void />
            </methodsynopsis>
        <para>
            Called by the trigger thread to read a scaler event.
            </para>
        <methodsynopsis>
            <type>void</type> <methodname>DocumentPackets</methodname>
            <void />
            </methodsynopsis>
        <para>
            Called by the framework to emit events that describe the set of
            <classname>CDocumentedPacket</classname> objects that are
            currently instantiated.
            </para>
        <methodsynopsis>
            <type>void</type> <methodname>ScheduleRunVariableDump</methodname>
            <void />
            </methodsynopsis>
        <para>
            Called by the framework to create events that describe the values of
            run and statevariables.
            </para>
      </refsect1>
   </refentry>


    <refentry id="manpage.cinvalidpacketstateexception">
      <refmeta>
         <refentrytitle>CInvalidPacketStateException</refentrytitle>
         <manvolnum>3sbsReadout</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>CInvalidPacketStateException</refname>
     <refpurpose>Exception thrown by documented packets.</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;CInvalidPacketStateException&gt;
         </programlisting>
         <classsynopsis>
            <ooclass><classname>CInvalidPacketStateException : public CReadoutException</classname></ooclass>
            <constructorsynopsis>
                <methodname>CInvalidPacketStateException</methodname>
                <methodparam>
                    <type>bool</type> <parameter>WasOpen</parameter>
                    </methodparam>
                <methodparam>
                    <modifier>const</modifier> <type>char*</type>
                    <parameter>pszAction</parameter>
                    </methodparam>
                </constructorsynopsis>
            <constructorsynopsis>
                <methodname>CInvalidPacketStateException</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CInvalidPacketStateException&amp;</type>
                    <parameter>rhs</parameter>
                    </methodparam>
                </constructorsynopsis>
            <destructorsynopsis>
                <methodname>~CInvalidPacketStateException</methodname>
                <void />
                </destructorsynopsis>
            <methodsynopsis>
                <type>CInvalidPacketStateException&amp;</type>
                <methodname>operator=</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CInvalidPacketStateException&amp;</type>
                    <parameter>rhs</parameter>
                    </methodparam>
                </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>operator==</methodname>
                <methodparam>
                    <modifier>const</modifier>
                    <type>CInvalidPacketStateException&amp;</type>
                    <parameter>rhs</parameter>
                    </methodparam>
                </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>operator!=</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CInvalidPacketStateException&amp;</type>
                    <parameter>rhs</parameter>
                    </methodparam>
                </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>getWasOpen</methodname>
                <void /><modifier>const</modifier>
                </methodsynopsis>
            <methodsynopsis>
                <type>Int_t</type> <methodname>ReasonCode</methodname>
                <void /><modifier>const</modifier>
                </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual const</modifier>
                <type>char*</type> <methodname>ReasonText</methodname>
                <void /><modifier>const</modifier>
                </methodsynopsis>
         </classsynopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
            This exception is thrown when a <classname>CDocumentedPacket</classname>
            is abused.  Specifically if a packet being formatted is begun again,
            or closed one ended.  The best protection against abusing
            <classname>CDocumentedPacket</classname> objects is to
            encapsulate an ordinary <classname>CEventSegment</classname> in
            a <classname>CEventPacket</classname> object as it will
            correctly use the <classname>CDocumentedPacket</classname> to put your
            data inside a packet.
         </para>
      </refsect1>
      <refsect1>
         <title>
            Public member functions
         </title>
           <methodsynopsis><type></type>
                <methodname>CInvalidPacketStateException</methodname>
                <methodparam>
                    <type>bool</type> <parameter>WasOpen</parameter>
                    </methodparam>
                <methodparam>
                    <modifier>const</modifier> <type>char*</type>
                    <parameter>pszAction</parameter>
                    </methodparam>
                </methodsynopsis>
            <para>
                Constructs the exception object.  <parameter>WasOpen</parameter>
                should be true if the packet was open when this exception was
                thrown.  <parameter>pszAction</parameter> provides some
                execution context for the exception.
                </para>
            <methodsynopsis>
                <type>int</type> <methodname>getWasOpen</methodname>
                <void /><modifier>const</modifier>
                </methodsynopsis>
            <para>
                Returns non zero if <parameter>WasOpen</parameter> was true
                when this object was constructed.
                </para>
            <methodsynopsis>
                <type>Int_t</type> <methodname>ReasonCode</methodname>
                <void /><modifier>const</modifier>
                </methodsynopsis>
            <para>
                Returns a code describing the reason for the exception.
                </para>
            <methodsynopsis>
                <modifier>virtual const</modifier>
                <type>char*</type> <methodname>ReasonText</methodname>
                <void /><modifier>const</modifier>
                </methodsynopsis>
            <para>
                Returns a pointer to a string that describes why the
                exception was thrown.
                </para>
      </refsect1>
   </refentry>

    <refentry id="manpage.cnulltrigger">
      <refmeta>
         <refentrytitle>CNullTrigger</refentrytitle>
         <manvolnum>3sbsReadout</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>CNullTrigger</refname>
     <refpurpose>A trigger that never fires.</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;CNullTrigger&gt;
         </programlisting>
         <classsynopsis>
            <ooclass><classname>CNullTrigger : public CEventTrigger</classname></ooclass>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>bool</type> <methodname>operator()</methodname>
                <void />
                </methodsynopsis>
         </classsynopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
            Provides a concrete event trigger that never fires.
         </para>
      </refsect1>
   </refentry>

    <refentry id="manpage.creadoutexception">
      <refmeta>
         <refentrytitle>CReadoutException</refentrytitle>
         <manvolnum>3sbsreadout</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>CReadoutException</refname>
     <refpurpose>Base class for readout specific exceptions</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;CReadoutException&gt;
         </programlisting>
         <classsynopsis>
            <ooclass><classname>CReadoutException :  public CException</classname></ooclass>
         </classsynopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
            This class is a place holder in the exception class hierarchy.  It allows
            programmers to catch all readout specific exception by catching exceptions
            of this type.
         </para>
      </refsect1>
      <refsect1>
         <title>EXAMPLES</title>
        <example>
            <title>Catching readout specific examples</title>
            <programlisting>
try {
// Code that might throw one of the readout applications
// exceptions:
...
}
catch (CReadoutException&amp; error) {
    // Process the exception here.
    ...
}
                </programlisting>
            </example>
      </refsect1>
      <refsect1>
         <title>
            SEE ALSO
         </title>
     <para>
        <link linkend='manpage.cinvalidpacketstateexception'>CInvalidPacketStateException(3sbsReadout)</link>
     </para>
      </refsect1>
   </refentry>

    <refentry id="manpage.cscalerbank">
      <refmeta>
         <refentrytitle>CScalerBank</refentrytitle>
         <manvolnum>3sbsreadout</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>CScalerBank</refname>
     <refpurpose>Container for individual Scaler objects.</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;CScalerBank&gt;
         </programlisting>
         <classsynopsis>
            <ooclass><classname>CScalerBank : public CScaler</classname></ooclass>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>void</type> <methodname>initialize</methodname>
                <void />
                </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>void</type> <methodname>clear</methodname>
                <void />
                </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>void</type> <methodname>disable</methodname>
                <void />
                </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>std::vector&lt;uint32_t&gt;</type> <methodname>read</methodname>
                </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>AddScalerModule</methodname>
                <methodparam>
                    <type>CScaler*</type> <parameter>pScaler</parameter>
                    </methodparam>
                </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>DeleteScaler</methodname>
                <methodparam>
                    <type>CScaler*</type> <parameter>pScaler</parameter>
                    </methodparam>
                </methodsynopsis>
            <methodsynopsis>
                <type>ScalerIterator</type> <methodname>begin</methodname>
                <void />
                </methodsynopsis>
            <methodsynopsis>
                <type>ScalerIterator</type> <methodname>end</methodname>
                <void />
                </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>bool</type> <methodname>isComposite</methodname>
                <void />
                <modifier>const</modifier>
                </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>visit</methodname>
                <methodparam>
                    <type>CVisitor&amp;</type> <parameter>visitor</parameter>
                    </methodparam>
                </methodsynopsis>
            <methodsynopsis>
                <type>size_t</type> <methodname>leafCount</methodname>
                <void />
                </methodsynopsis>
            <methodsynopsis>
                <type>size_t</type>
                <methodname>fullCount</methodname>
                <void />
                </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>bool</type>
                <methodname>isComposite</methodname>
                <void /><modifier>const</modifier>
                </methodsynopsis>
         </classsynopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
            <classname>CScalerBank</classname> is an ordered container of
            <classname>CScaler</classname> objects.  As such, it allows scalers
            to be organized into a hierarchy (since <classname>CScalerBank</classname>
            objects are also <classname>CScaler</classname> objects they can contain
            other <classname>CScalerBank</classname>s).
         </para>
         <para>
            The <classname>CExperiment</classname> has a single top level
            <classname>CScalerBank</classname>.  It is the application's
            responsibility to put the top level of the scaler readout hierarchy
            in that <classname>CScalerBank</classname>.  This is normally done in
            <methodname>CSkeleton::SetupScalers</methodname>.
            </para>
      </refsect1>
      <refsect1>
         <title>
            Public member functions
         </title>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>void</type> <methodname>initialize</methodname>
                <void />
                </methodsynopsis>
            <para>
                <classname>CScaler</classname> interface, invokes
                <methodname>initialize</methodname> on all
                elements of the collection.  This performs a deep initialization
                of the scaler hardware.
                </para>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>void</type> <methodname>clear</methodname>
                <void />
                </methodsynopsis>
            <para>
                <classname>CScaler</classname> Interface. Invokes <methodname>clear</methodname>
                on all members of the collection.  This performs a deep clear of
                the scaler hardware.
                </para>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>void</type> <methodname>disable</methodname>
                <void />
                </methodsynopsis>
            <para>
                <classname>CScaler</classname> interface.  invokes <methodname>disable</methodname>
                on all members of the collection.  This performs a deep
                <methodname>disable</methodname> of the scaler hardware in the
                hierarchy below this <classname>CScalerBank</classname>.
                </para>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>std::vector&lt;uint32_t&gt;</type> <methodname>read</methodname>
                </methodsynopsis>
            <para>
                <classname>CScaler</classname> interface.  Reads the scalers in the
                collection in inertion order.   The return value is a
                <classname>std::vector</classname>  of
                the data read.
                </para>
            <methodsynopsis>
                <type>void</type> <methodname>AddScalerModule</methodname>
                <methodparam>
                    <type>CScaler*</type> <parameter>pScaler</parameter>
                    </methodparam>
                </methodsynopsis>
            <para>
                Adds  the <classname>CScaler</classname> <parameter>pScaler</parameter>
                to the end of the collection maintained by this module.
                </para>
            <methodsynopsis>
                <type>void</type> <methodname>DeleteScaler</methodname>
                <methodparam>
                    <type>CScaler*</type> <parameter>pScaler</parameter>
                    </methodparam>
                </methodsynopsis>
            <para>
                If <parameter>pScaler</parameter> is an element of the collection
                it is removed from the collection.  IF <parameter>pScaler</parameter>
                is not in the collection, this function does nothing.
                </para>     
            <methodsynopsis>
                <type>ScalerIterator</type> <methodname>begin</methodname>
                <void />
                </methodsynopsis>
            <para>
                Returns a <type>CScalerBank::ScalerIterator</type> which is an
                iterator to the beginning of the collection.  Iterators are  pointer
                like objects. Dereferencing a <type>CScalerBank::ScalerIterator</type>
                retrieves the <type>CScaler*</type> at the iterator's position in
                the collection.  Incrementing a <type>CScalerBank::ScalerIterator</type>
                'points' to the next item in the collection.
                </para>
            <para>
                See also <methodname>end</methodname> below.
                </para>
            <methodsynopsis>
                <type>ScalerIterator</type> <methodname>end</methodname>
                <void />
                </methodsynopsis>
            <para>
                Returns a CScalerBank::<classname>ScalerIterator</classname>
                that points off the end of the collection.  Since iterators
                can be compared for equality, this provides a methdo to
                determine when an iterator has reached the end of
                iteration.
                </para>
            <para>
                For example
                <informalexample>
                    <programlisting>
CScalerBank theBank;
...
CScalerBank::ScalerIterator p = theBank.begin();
while(p != theBank.end()) {
    CScaler* pAScaler = *p;
    ...
    p++;
}
                        </programlisting>
                    </informalexample>
                </para>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>bool</type> <methodname>isComposite</methodname>
                <void />
                <modifier>const</modifier>
                </methodsynopsis>
            <para>
                Returns <literal>true</literal> indicating this scaler is a
                composite scaler and therefore implements insertion, deletion,
                visitation and iteration.
                </para>
            <methodsynopsis>
                <type>void</type> <methodname>visit</methodname>
                <methodparam>
                    <type>CVisitor&amp;</type> <parameter>visitor</parameter>
                    </methodparam>
                </methodsynopsis>
            <para>
                Visits (in a shallow way), all members of the container.  See
                the EXAMPLES for a way to do a deep visitation.  <parameter>visitor</parameter>
                is a reference to an object from a class derived from
                <classname>CScalerBank::CVisitor</classname>.    See
                "Types and public data" below for information about the
                <classname>CScalerBank::CVisitor</classname> class.
                </para>
            <methodsynopsis>
                <type>size_t</type> <methodname>leafCount</methodname>
                <void />
                </methodsynopsis>
            <para>
                Performs a deep visitation to count the total number of items
                in the hierarchy rooted at this object that are not composites.
                (for which <methodname>isComposite</methodname> returns
                <literal>false</literal>).
                </para>
            <methodsynopsis>
                <type>size_t</type>
                <methodname>fullCount</methodname>
                <void />
                </methodsynopsis>
            <para>
                Performs a deep visitation of the container to count the total
                number of elements regardless of the value returned by
                <methodname>isComposite</methodname>.
                </para>

      </refsect1>
      <refsect1>
         <title>Types and public data</title>
         <para>
            <classname>CScalerBank::Iterator</classname> is an iterator over
            the container of <classname>CScaler</classname>  objects
            maintained by this class.  It supports the following operations:
            <variablelist>
                <varlistentry>
                    <term>dereference (unary *)</term>
                    <listitem>
                        <para>
                            Returns the <classname>CScaler</classname>* at this
                            position in the container.
                            </para>
                        </listitem>
                    </varlistentry>
                <varlistentry>
                    <term>pre/post increment</term>
                    <listitem>
                        <para>Advances to the next item in the container.
                        This is a shallow advance.
                        </para>
                        </listitem>
                    </varlistentry>
                <varlistentry>
                    <term>Comparison (operator==) with other iterators</term>
                    <listitem>
                    <para>
                        Determines if two iterators  refer to the same location
                        of the container.  Along with the <methodname>end</methodname>
                        method can use to determine when iterators have gone
                        past the end of the container.
                        </para>
                    </listitem>
                    </varlistentry>
                <varlistentry>
                    <term>pre/post decrement</term>
                    <listitem>
                        <para>
                            Points the iterator at the previous element of the
                            container.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
         </para>
         <para>
            <classname>CScalerBank::CVisitor</classname>  is an abstract base class
            for objects to be passed to the <methodname>visit</methodname> method.
            This base class has a single, pure virtual method:
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>void</type> <methodname>operator()</methodname>
                <methodparam>
                    <type>CScaler*</type> <parameter>pScaler</parameter>
                    </methodparam>
                </methodsynopsis>
            </para>
         <para>
            This method is called during visitation for each element of the
            container.  <parameter>pScaler</parameter> points to the element
            being visited.
            </para>
      </refsect1>
      <refsect1>
         <title>EXAMPLES</title>
         <para>
            The example in this section shows how to do  deep visitation.
            The key is that when the visitor sees visits a composit element,
            it recursively invokes <methodname>visit</methodname> on that
            element.  The example produces statistics on the number leaf and
            composite elements.
         </para>
         <example>
            <title>Deep visitation in <classname>CScalerBank</classname> containers</title>
            <programlisting>
class Statistics : public CScalerBank::CVisitor
{
private:
    unsigned    m_leaves;
    unsigned    m_composites;
public:
    Statitics() :
        m_leaves(0),
        m_composites(0) {}
    unsigned leaves() {return m_leaves;}
    unsigned composites() {return m_composites;}
    
    virtual void operator(CScaler* pScaler) {
        if (pScaler&gt;isComposite()) {
            m_composites++;
            CScalerBank* pBank = reinterpret_cast&lt;ScalerBank*&gt;(pScaler);
            pBank&gt;visit(*this);
        } else {
            m_leaves++;
        }
    }
};
                </programlisting>
            </example>
         
      </refsect1>
      <refsect1>
         <title>
            SEE ALSO
         </title>
     <para>
        <link linkend='manpage.cscaler'>CScaler</link>
     </para>
      </refsect1>
   </refentry>

    <refentry id="manpage.ctimedtrigger">
      <refmeta>
         <refentrytitle>CTimedTrigger</refentrytitle>
         <manvolnum>3sbsReadout</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>CTimedTrigger</refname>
     <refpurpose>CEventTrigger that fires periodically</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;CTimedTrigger.h&gt;
         </programlisting>
         <classsynopsis>
            <ooclass><classname>CTimedTrigger : public CEventTrigger</classname></ooclass>
            <constructorsynopsis>
                <methodname>CTimedTrigger</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>timespec&amp;</type>
                    <parameter>interval</parameter>
                    </methodparam>
                </constructorsynopsis>
            <constructorsynopsis>
                <methodname>CTimedTrigger</methodname>
                <methodparam>
                    <modifier>const</modifier>
                    <type>CTimedTrigger&amp;</type> <parameter>interval</parameter>
                    </methodparam>
                </constructorsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>setPeriod</methodname>
                <methodparam>
                    <modifier>const</modifier>
                    <type>struct timespec&amp;</type> <parameter>newInterval</parameter>
                    </methodparam>
                </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>void</type> <methodname>setup</methodname>
                </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>bool</type>
                <methodname>operator()</methodname>
                <void/>
                </methodsynopsis>
         </classsynopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
            Provides a concrete <classname>CEventTrigger</classname>  class
            that fires periodically.  Note that the trigger is not latched, that
            that is once <methodname>operator()</methodname> returns
            <literal>true</literal> it won't do so again until the trigger is
            next due to fire.
         </para>
         <para>
            This is the typical event trigger attached to scaler readout.
            </para>
      </refsect1>
      <refsect1>
         <title>
            Public member functions
         </title>
           <methodsynopsis>
                <methodname>CTimedTrigger</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>timespec&amp;</type>
                    <parameter>interval</parameter>
                    </methodparam>
                </methodsynopsis>
           <para>
                Constructs a trigger that will fire periodically.  The
                trigger interval is <parameter>interval</parameter>.
                This can be modified by calling <parameter>setPeriod</parameter>
                </para>
            <methodsynopsis>
                <methodname>CTimedTrigger</methodname>
                <methodparam>
                    <modifier>const</modifier>
                    <type>CTimedTrigger&amp;</type> <parameter>interval</parameter>
                    </methodparam>
                </methodsynopsis>
            <para>
                Copy construction.
                </para>
            <methodsynopsis>
                <type>void</type> <methodname>setPeriod</methodname>
                <methodparam>
                    <modifier>const</modifier>
                    <type>struct timespec&amp;</type> <parameter>newInterval</parameter>
                    </methodparam>
                </methodsynopsis>
            <para>
                Sets the new trigger period.  This takes effect immediately.  If
                the time since the last trigger is greater than
                <parameter>newInterval</parameter> the next call to
                <methodname>operator()</methodname> will return
                <parameter>true</parameter>.
                </para>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>void</type> <methodname>setup</methodname>
                </methodsynopsis>
            <para>
                Initializes the trigger by setting the last fired time to now.
                </para>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>bool</type>
                <methodname>operator()</methodname>
                <void/>
                </methodsynopsis>
            <para>
                Returns <literal>true</literal> if the last trigger was more
                longer ago than the trigger period.
                </para>
      </refsect1>
   </refentry>

    <refentry id="manpage.cv977busy">
      <refmeta>
         <refentrytitle>CV977Busy</refentrytitle>
         <manvolnum>volnum</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>CV977Busy</refname>
     <refpurpose>Concrete busy class using the CAEN V977 module</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;CV977Busy.h&gt;
         </programlisting>
         <classsynopsis>
            <ooclass><classname>CV977Busy : public CBusy</classname></ooclass>
            <constructorsynopsis>
                <methodname>CV977Busy</methodname>
                <methodparam>
                    <type>uint32_t</type> <parameter>base</parameter>
                    </methodparam>
                <methodparam>
                    <type>unsigned</type> <parameter>crate</parameter>
                    <initializer>0</initializer>
                    </methodparam>
                </constructorsynopsis>
            <constructorsynopsis>
                <methodname>CV977Busy</methodname>
                <methodparam>
                    <type>CCAENV977&amp;</type> <parameter>module</parameter>
                    </methodparam>
                </constructorsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type>
                <methodname>GoBusy</methodname> <void />
                </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>void</type> <methodname>GoClear</methodname>
                <void />
                </methodsynopsis>
         </classsynopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
            Busy objects control external hardware that indicates when the readout
            software is unable to respond to a new trigger.   The CAENV977 module
            achieves this by using its ability to copy input signals to it's outputs
            in a latchemd manner.  It is legal to use a single module as both a
            trigger and a busy module.  
         </para>
         <para>
            The following signals are used by the module:
            </para>
         <informaltable>
            <tgroup cols='3'>
                <thead>
                    <row>
                        <entry>Plug</entry>
                        <entry>Direction</entry>
                        <entry>Meaning</entry>
                        </row>
                    </thead>
                <tbody>
                    <row>
                        <entry>0</entry>
                        <entry>Input (left)</entry>
                        <entry>
                            <para>
                                This should be the event trigger the computer sees.
                                This is the trgger input as well for when the
                                module is being used as a trigger.
                                </para>
                            </entry>
                        </row>
                    <row>
                        <entry>0</entry>
                        <entry>Output (right)</entry>
                        <entry>
                            Computer is busy.
                            </entry>
                        </row>
                    <row>
                        <entry>1</entry>
                        <entry>Output (right)</entry>
                        <entry>
                            Computer going busy for software reasons (pulsed)
                            </entry>
                        
                        </row>
                    </tbody>
                </tgroup>
            </informaltable>  
      </refsect1>
      <refsect1>
         <title>
            Public member functions
         </title>
             <methodsynopsis><type></type>
                <methodname>CV977Busy</methodname>
                <methodparam>
                    <type>uint32_t</type> <parameter>base</parameter>
                    </methodparam>
                <methodparam>
                    <type>unsigned</type> <parameter>crate</parameter>
                    <initializer>0</initializer>
                    </methodparam>
                </methodsynopsis>
            <para>
                Constructor that uses the <parameter>base</parameter> address
                and VME <parameter>crate</parameter> number to describe the
                module.
                </para>
            <methodsynopsis><type></type>
                <methodname>CV977Busy</methodname>
                <methodparam>
                    <type>CCAENV977&amp;</type> <parameter>module</parameter>
                    </methodparam>
                </methodsynopsis>
            <para>
                Constructor that operates with an existing
                <classname>CCAENV977</classname>  <parameter>module</parameter>.
                </para>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type>
                <methodname>GoBusy</methodname> <void />
                </methodsynopsis>
            <para>
                Called by the framework to pulse the going busy output.
                </para>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>void</type> <methodname>GoClear</methodname>
                <void />
                </methodsynopsis>
            <para>
                Called by the framework to clear the busy output.
                </para>
      </refsect1>
      <refsect1>
         <title>
            SEE ALSO
         </title>
     <para>
        <link linkend='manpage.cbusy'>CBusy(3sbsReadout)</link>,
     <link linkend='manpage.cv977trigger'>CV977Trigger(3sbsReadout)</link>
     </para>
      </refsect1>
   </refentry>


    <refentry id="manpage.cv977trigger">
      <refmeta>
         <refentrytitle>CV977Trigger</refentrytitle>
         <manvolnum>volnum</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>CV977Trigger</refname>
     <refpurpose>Concrete Trigger class using CAEN V977 module.</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;CV977Trigger.h&gt;
         </programlisting>
         <classsynopsis>
            <ooclass><classname>CV977Trigger : public CEventTrigger</classname></ooclass>
            <constructorsynopsis>
                <methodname>CV977Trigger</methodname>
                <methodparam>
                    <type>uint32_t</type> <parameter>base</parameter>
                    </methodparam>
                <methodparam>
                    <type>unsigned</type> <parameter>crate</parameter>
                    <initializer>0</initializer>
                    </methodparam>
                </constructorsynopsis>
            <constructorsynopsis>
                <methodname>CV977Trigger</methodname>
                <methodparam>
                    <type>CCAENV977*</type> <parameter>pModule</parameter>
                    </methodparam>
                <methodparam>
                    <type>bool</type> <parameter>deleteme</parameter>
                    <initializer>true</initializer>
                    </methodparam>
                </constructorsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>void</type> <methodname>setup</methodname>
                <void />
                </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>bool</type> <methodname>operator()</methodname>
                <void />
                </methodsynopsis>
         </classsynopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
            <classname>CV977Trigger</classname> is a concrete trigger class that
            accepts triggers from a CAEN V977 I/O register module.  The trigger
            is accepted on input 0.  Since the module latches inputs input 0 should
            be pulsed.  Normally you should use this class in conjunction with a
            <classname>CV977Busy</classname> object to manage the busy.
         </para>
      </refsect1>
      <refsect1>
         <title>
            Public member functions
         </title>
           <methodsynopsis><type></type>
                <methodname>CV977Trigger</methodname>
                <methodparam>
                    <type>uint32_t</type> <parameter>base</parameter>
                    </methodparam>
                <methodparam>
                    <type>unsigned</type> <parameter>crate</parameter>
                    <initializer>0</initializer>
                    </methodparam>
                </methodsynopsis>
            <para>
                Constructs the object using a description of the electronics module's
                <parameter>base</parameter> address and VME
                <parameter>crate</parameter> number.
                </para>
            <methodsynopsis>
                <methodname>CV977Trigger</methodname>
                <methodparam>
                    <type>CCAENV977*</type> <parameter>pModule</parameter>
                    </methodparam>
                <methodparam>
                    <type>bool</type> <parameter>deleteme</parameter>
                    <initializer>true</initializer>
                    </methodparam>
                </methodsynopsis>
            <para>
                Constructs the object using an existing hardware object
                <parameter>pModule</parameter>.
                If <parameter>deleteme</parameter> is <literal>true</literal>,
                when this object is destroyed, the module passed in will be as well.
                This is appropriate if a
                <classname>CCAENV977</classname> was dynamically allocated/constructed
                for this object.
                </para>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>void</type> <methodname>setup</methodname>
                <void />
                </methodsynopsis>
            <para>
                <classname>CEventTrigger</classname> interface.  Called to
                setup the electronics and make it able to accept trigger.
                </para>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>bool</type> <methodname>operator()</methodname>
                <void />
                </methodsynopsis>
            <para>
                <classname>CEventTrigger</classname> interface.  Called to
                poll for a trigger condition.  Triggers are latched until
                they are cleared.  Normally this object will be used in
                conjucntion with a <classname>CV977Busy</classname> object
                on the same electronics.  The clear of the busy output of
                that object will reset the trigger as well.
                </para>
      </refsect1>

      <refsect1>
         <title>
            SEE ALSO
         </title>
     <para>
        <link linkend='manpage.ceventtrigger'>CEventTrigger(3sbsReadout)</link>,
        <link linkend='manpage.cv977busy'>CV977Busy(3sbsReadout)</link>
     </para>
      </refsect1>
   </refentry>

    <refentry id="manpage.runstate">
      <refmeta>
         <refentrytitle>RunState</refentrytitle>
         <manvolnum>3sbsReadout</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>RunState</refname>
     <refpurpose>Encapsulate important state of the software.</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;RunState.h&gt;
         </programlisting>
         <classsynopsis>
            <ooclass><classname>RunState</classname></ooclass>
            <fieldsynopsis>
                <type>State</type> <varname>m_state</varname>
                </fieldsynopsis>
            <fieldsynopsis>
                <type>uint32_t</type> <varname>m_runNumber</varname>
                </fieldsynopsis>
            <fieldsynopsis>
                <type>uint32_t</type>    <varname>m_timeOffset</varname>
                </fieldsynopsis>
            <fieldsynopsis>
                <type>char*</type> <varname>m_pTitle</varname>
                </fieldsynopsis>
            <methodsynopsis>
                <modifier>static</modifier>
                <type>RunState*</type>
                <methodname>getInstance</methodname>
                </methodsynopsis>
            <methodsynopsis>
                <type>std::string</type>
                <methodname>stateName</methodname>
                <void /><modifier>const</modifier>
                </methodsynopsis>
            <methodsynopsis>
                <modifier>static</modifier>
                <type>std::string</type> <methodname>stateName</methodname>
                <methodparam>
                    <type>State</type> <parameter>state</parameter>
                    </methodparam>
                </methodsynopsis>
         </classsynopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
            This is essentially a singleton structure that encapsulates the
            state of the run.  See Types and Public data for a description of
            the data elements of the struct.  See Public Member functions for the
            methods.  Note that since this is a singleton, construction is private.
            You must use the <methodname>getInstance()</methodname> method to
            obtain a pointer to the one and only instance of the object.
         </para>
      </refsect1>
      <refsect1>
         <title>
            Public member functions
         </title>
            <methodsynopsis>
                <modifier>static</modifier>
                <type>RunState*</type>
                <methodname>getInstance</methodname>
                </methodsynopsis>
            <para>
                Returns a pointer to the one and only instance of this class.
                If no instance exists yet, it is created.
                </para>
            <methodsynopsis>
                <type>std::string</type>
                <methodname>stateName</methodname>
                <void /><modifier>const</modifier>
                </methodsynopsis>
            <para>
                Returns a text string that describes the current state of the run.
                This is a textual equivalent of the <varname>m_state</varname>
                member variable.
                </para>
            <methodsynopsis>
                <modifier>static</modifier>
                <type>std::string</type> <methodname>stateName</methodname>
                <methodparam>
                    <type>State</type> <parameter>state</parameter>
                    </methodparam>
                </methodsynopsis>
            <para>
                Given a  <parameter>state</parameter> returns the textual
                equivalent of that state.
                </para>
      </refsect1>
      <refsect1>
         <title>Types and public data</title>
         <para>
            Since member data can be set and read, getters and setter methods
            would be overkill and all data are public.  The public member
            data are:
         </para>
         <variablelist>
            <varlistentry>
                <term><fieldsynopsis>
                <type>RunState::State</type> <varname>m_state</varname>
                </fieldsynopsis>
                </term>
                <listitem>
                    <para>
                        Current run state.  The legal values are
                        <literal>inactive</literal>,
                        <literal>active</literal> and
                        <literal>paused</literal>
                        </para>
                    </listitem>
                </varlistentry>
            <varlistentry>
                <term><fieldsynopsis>
                <type>uint32_t</type> <varname>m_runNumber</varname>
                </fieldsynopsis>
                </term>
                <listitem>
                    <para>
                        The run number of the active run or the next run (unless
                        changed by the user), if the run is not active.
                        </para>
                    </listitem>
                </varlistentry>
            <varlistentry>
                <term><fieldsynopsis>
                <type>uint32_t</type>    <varname>m_timeOffset</varname>
                </fieldsynopsis>
                </term>
                <listitem>
                    <para>
                        The nuber of seconds into the run we are.  This is used by
                        the pause/resume management to ensure that the system
                        does not count time when the run is paused.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
      </refsect1>
      <refsect1>
        <title>EXAMPLES</title>
        <example>
            <title>Outputting the state of the run</title>
            <programlisting>
RunState* pState = RunState::getInstance();
std::cout &lt;&lt; " The run is currently "
          &lt;&lt; pState-&gt;stateName
          &lt; std::endl;
                </programlisting>
            </example>
      </refsect1>
   </refentry>

    <refentry id="manpage.cscaler">
      <refmeta>
         <refentrytitle>CScaler</refentrytitle>
         <manvolnum>3sbsReadout</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>CScaler</refname>
     <refpurpose>Base class for scaler readout classes</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;CScaler.h&gt;
         </programlisting>
         <classsynopsis>
            <ooclass><classname>CScaler</classname></ooclass>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>void</type> <methodname>initialize</methodname>
                <void />
                </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>void</type> <methodname>clear</methodname>
                <void />
                </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>void</type> <methodname>disable</methodname>
                <void />
                </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>std::vector&lt;uint32_t&gt;</type>
                <methodname>read</methodname>
                <void /><modifier>= 0</modifier>
                </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>bool</type> <methodname>isComposite</methodname>
                <void />
                <modifier>const</modifier>
                </methodsynopsis>
         </classsynopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
            <classname>CScaler</classname> is an abstract base class for
            objects that read out scaler hardware.  Concrete classes have to be
            made by deriving from this class.
         </para>
      </refsect1>
      <refsect1>
         <title>
            Public member functions
         </title>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>void</type> <methodname>initialize</methodname>
                <void />
                </methodsynopsis>
            <para>
                Called by the framework to initialize the scaler hardware
                prior to starting data taking.
                </para>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>void</type> <methodname>clear</methodname>
                <void />
                </methodsynopsis>
            <para>
                Called by the framework to clear scaler hardware both prior to
                starting data taking and after reading a scaler event.
                </para>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>void</type> <methodname>disable</methodname>
                <void />
                </methodsynopsis>
            <para>
                Called by the framework to disable the scaler hardware
                prior to terminating data taking.
                </para>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>std::vector&lt;uint32_t&gt;</type>
                <methodname>read</methodname>
                <void /><modifier>= 0</modifier>
                </methodsynopsis>
            <para>
                Called by the framework to read this module's scaler(s).  The
                return value is a <type>std::vector</type> consisting of the
                data read from the hardware
                </para>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>bool</type> <methodname>isComposite</methodname>
                <void />
                <modifier>const</modifier>
                </methodsynopsis>
            <para>
                Should return <literal>false</literal> if the scaler is not a
                container for other scalers (see e.g.
                <link linkend='manpage.cscalerbank'>CScalerBank(3sbsReadout)</link>).
                Should return <literal>false</literal> if the scaler is a container
                and implements the interface defined by
                <link linkend='manpage.cscalerbank'>CScalerBank(3sbsReadout)</link>.
                </para>
      </refsect1>
      <refsect1>
         <title>
            SEE ALSO
         </title>
     <para>
        <link linkend='manpage.cscalerbank'>CScalerBank(3sbsReadout)</link>
     </para>
      </refsect1>
   </refentry>

<!-- /manpage -->

<!-- manpage 1sbsReadout -->
<refentry id="manpage.1sbsreadout">
  <refmeta>
     <refentrytitle>Readout</refentrytitle>
     <manvolnum>1sbsReadout</manvolnum>
  </refmeta>
  <refnamediv>
     <refname>Readout</refname>
     <refpurpose>Start an event readout program.</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
    <cmdsynopsis>
    <command>
Readout <replaceable>options...</replaceable>   
    </command>
    </cmdsynopsis>
  </refsynopsisdiv>
  <refsect1>
     <title>DESCRIPTION</title>
     <para>
    Starts the Readout program.
     </para>
  </refsect1>
  <refsect1>
     <title>
    OPTIONS
     </title>
     <variablelist>
    <varlistentry>
        <term><option>--port</option>=<replaceable>port-selection</replaceable></term>
        <listitem>
        <para>
            Enables the Tcl server component to listen on the specified port.
            If the value of this option is <replaceable>managed</replaceable>,
            the port manager is contacted to allocate a port.  Otherwise the
            value must be the integer port number on which to listen.
        </para>
        </listitem>
    </varlistentry>
    <varlistentry>
        <term><option>--ring</option>=<replaceable>name</replaceable></term>
        <listitem>
            <para>
                Provides the name of the local ring into which data will be placed.
                If this switch is omitted, the ring name will be the username
                running the program.
                </para>
            </listitem>
        </varlistentry>
    <varlistentry>
        <term><option>--sourceid</option>=<replaceable>value</replaceable></term>
        <listitem>
            <para>
                Sets the default source id for events that have timestamps.
                Events without timestamp have an abbreviated body header.
                A call to <methodname>setSourceId</methodname> from within the
                event processor overrides the value of this switch for this
                event only.
            </para>
        </listitem>
    </varlistentry>
    <varlistentry>
        <term><option>--init-script</option>=<replaceable>file-path</replaceable></term>
        <listitem>
            <para>
                After initialization, executes the script designated by
                <replaceable>file-path</replaceable> in the main thread's
                interpreter.
            </para>
        </listitem>
    </varlistentry>
    <varlistentry>
        <term><option>--help</option></term>
        <listitem>
            <para>
                Outputs a summary of the command line options and exits without
                doing anything else useful.
                </para>
            </listitem>
        </varlistentry>
    <varlistentry>
        <term><option>--version</option></term>
        <listitem>
            <para>
                Outputs the program version number and exists without doing anything
                else useful.
                </para>
            </listitem>
        </varlistentry>
    
     </variablelist>
  </refsect1>
  <refsect1>
    <title>COMMANDS</title>
    <para>
        The Readout program runs a Tcl interpreter.  The Tcl <command>set</command>
        command can set some variables that have meaning to the Readout program.
        See VARIABLES below for a list of those. This section describes commands
        that have been added to the base Tcl interpreter for the Readout program.
    </para>
    <variablelist>
        <varlistentry>
            <term><command>begin</command></term>
            <listitem>
                <para>
                    Starts a data taking run.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><command>end</command></term>
            <listitem>
                <para>
                    Ends a data taking run.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><command>pause</command></term>
            <listitem>
                <para>
                    Pauses a data taking run.  
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><command>resume</command></term>
            <listitem>
                <para>
                    Resumes a data taking run that was paused.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><command>runvar</command> <replaceable>varname</replaceable></term>
            <listitem>
                <para>
                    Designates <parameter>varname</parameter> as a Tcl variable
                    that will be written out to the event stream in a documentation
                    ring item.  Normally the values of these variables are set
                    either by the users's experiment specific code, or via external
                    programs interacting with Readout's Tcl server.  One example
                    of this is the use of the
                    <link linkend='manpage.controlpush' endterm='manpage.controlpush-title' />
                    program to push the values of Tcl variables into the interpreter. 
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><command>serverauth</command> <replaceable>subcommand ?parameters?</replaceable></term>
            <listitem>
                <para>
                    This controls access to the Tcl server embedded in the
                    Readout program.  By default only connections from
                    <literal>localhost</literal> (the host Reaout is running in)
                    are allowed. Note that this command must be issued to the
                    Tcl server not to the main command interpreter.
                </para>
                <para>
                    Subcommands are as follows:
                </para>
                <variablelist>
                    <varlistentry>
                        <term><command>add</command> <replaceable>host-or-ip</replaceable></term>
                        <listitem>
                            <para>
                                Adds a new <parameter>host-or-ip</parameter> to the
                                list of hosts that are allowed to connect.
                                <parameter>host-or-ip</parameter> is either the
                                DNS name of a host (e.g. <literal>u6pc3</literal>) or
                                the IP address of that host in dotted numeric form
                                (e.g. <literal>35.9.56.23</literal>).
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><command>list</command></term>
                        <listitem>
                            <para>
                                Lists the hosts that are allowed to connect
                                to the Tcl server. The returned value is a list of
                                hosts.  Each host is a two element hostname/IP address
                                list.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><command>delete</command> <replaceable>host-or-ip</replaceable></term>
                        <listitem>
                            <para>
                                Removes the specified <replaceable>host-or-ip</replaceable>
                                from the list of hosts authorized to connect.
                            </para>
                        </listitem>
                    </varlistentry>
                    
                </variablelist>
            </listitem>
        </varlistentry>
        
    </variablelist>
  </refsect1>
  <refsect1>
    <title>VARIABLES</title>
    <para>
        Besides the variables that have been defined via the <command>runvar</command>
        command to put in documentation ring items, some variables have
        special meaning for Readout:
    </para>
    <variablelist>
        <varlistentry>
            <term><varname>title</varname></term>
            <listitem>
                <para>
                    This variable contains the run title string that appears
                    in run state transition events.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><varname>run</varname></term>
            <listitem>
                <para>
                    This variable contains the run number as it appears in the
                    run state transition events.  <varname>run</varname> must
                    be a positive integer.  The ReadoutGUI enforces this restriction.
                </para>
            </listitem>
        </varlistentry>
        
    </variablelist>
  </refsect1>
</refentry>

<!-- /manpage -->
