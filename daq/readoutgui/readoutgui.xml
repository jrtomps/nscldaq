<!-- chapter utilities -->
<chapter>
    <title>ReadoutShell</title>
    <para>
        The <literal>ReadoutShell</literal> is a graphical user interface that
        servers as a front end for experiment control.  The <literal>ReadoutShell</literal>
        for NSCLDAQ-11 is significantly different than that of earlier versions.
        The ReadoutShell for NSCLDAQ-11 has been built to better support the
        multi-data source/event builder environment that NSCLDAQ-11 provides.
    </para>
    <para>
        The remainder of this chapter describes:
        <itemizedlist>
            <listitem>
                <para>
                    The principles of operation of the ReadoutShell.
                </para>
            </listitem>
            <listitem>
                <para>
                    The ReadoutShell's GUI (ReadoutGUI) and how to operate it.
                </para>
            </listitem>
            <listitem>
                <para>
                    The way the event logger ties into the Readout GUI and
                    The directory structure the ReadoutShell maintains
                    to support an experiment.
                </para>
            </listitem>
            <listitem>
                <para>
                    Ways in which the ReadoutShell supports customization
                    of both its appearance and operation.
                </para>
            </listitem>
        </itemizedlist>
    </para>
    <para>
        Reference material on the API provided by the ReadoutShell can be found in
        the <link linkend='rdogui_man'>3rdogui</link> man page section.  Note that
        the term ReadoutShell and ReadoutGUI will be used interchangeably though
        properly ReadoutShell refers to the progrma and ReadoutGUI refers
        to the packaged user interface.
    </para>
    <section>
        <title>Principles of operation</title>
        <para>
            This chapter describes the underlying principles of operation
            of the event builder.  Along the way terminology that will be used
            in the remainder of this chapter will be informally defined.
        </para>
        <para>
            The purpose of the ReadoutShell is to provide a graphical user interface
            that can control a set of readout programs or <firstterm>Data Sources</firstterm>.
            To do this, the ReadoutShell must know how to ask readout programs
            of various types to start, stop, pause and resume (if supported) runs.
            To do this it uses a set of <firstterm>Data Source Providers</firstterm>.
            You can think of a data source provider as a set of software that knows
            how to run a specific type of data source program.
        </para>
        <para>
            The ReadoutShell and Data source providers communicate via a
            well defined programmatic interface that is described in
            <link linkend="provider3_intro">3provider</link>.
        </para>
        <para>
            At the core of the ReadoutShell is a finite state automaton or
            <firstterm>State Machine</firstterm>.  The State machine defines
            a set of running modes or <firstterm>States</firstterm> the ReadoutShell
            can be in as well as the set of legal states to which the system
            can proceed via <firstterm>State Transitions</firstterm>.
            The ReadoutShell state machine provides a mechanism for other
            components of the ReadoutShell to register an interest in the transitions
            between states and to take appropriate action both prior to leaving
            a state and upon completing the transition to the new state.
            Functionality that is registered on a state machine is referred to
            as a <firstterm>bundle</firstterm>
        </para>
        <para>
            For example, event logging is implemented as a bundle.  As the
            state machine is transitioning from a halted state to an active state,
            the event log bundle starts up the event logger. When the state machine
            transitions either from the paused, or active states to the halted
            state, the bundle waits for logging to complete and then finalizes
            the run data by maintaining the correct filesystem/directory
            structure.
        </para>
        <para>
            We complete this section with a diagram of the state machine
            and a description of each state, what it means to be in that state,
            the legal transitions from that state and what it means to make
            those transitions.
        </para>
        <figure id='rdogui_statediagram'>
            <title id='rdogui_statediagram_title'>ReadoutShell's state diagram</title>
            <mediaobject>
               <imageobject>
                    <imagedata fileref='RunState.jpg' format='JPEG' />
                </imageobject>
               <imageobject>
                    <imagedata fileref='RunState.eps' format='EPS' />
               </imageobject>
            </mediaobject>
        </figure>
        <para>
            As we will see in the discussion below, some of the transitions
            that go directly back to <literal>NotReady</literal> actually
            represent a transition through <literal>Halted</literal> followed by
            a transition to <literal>NotReady</literal>.  The diagram's transitions
            are abbreviated in order to reduce the complexity and provide the
            intent (that the 'stable' end state of the transition is
            <literal>NotReady</literal>).
        </para>
        <para>
            Let's look at each state from top to bottom.
        </para>
        <variablelist>
            <varlistentry>
                <term><literal>NotReady</literal></term>
                <listitem>
                    <para>
                        This state means that none of the data sources are running
                        and therefore the system is not yet ready to be used.
                        In this state you can define the set of data sources
                        to use.  The <guibutton>Start</guibutton> button
                        causes a transition to the <literal>Starting</literal>
                        state.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><literal>Starting</literal></term>
                <listitem>
                    <para>
                        On making a transition to the <literal>Starting</literal>
                        state, the data source manager attempts to start all of the
                        data sources.  If any of the data sources fail to start,
                        a transition back to the <literal>NotReady</literal> state
                        is forced.  Once all data sources start successfully,
                        the data source manager forces a transition to the
                        <literal>Halted</literal> state.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><literal>Halted</literal></term>
                <listitem>
                    <para>
                        In the <literal>Halted</literal> state, the system is
                        ready for use.  The <guibutton>Begin</guibutton> button
                        can start a data taking run transitioning to the
                        <literal>Active</literal> state.  If a data source
                        fails, the system will transition back to the
                        <literal>NotReady</literal> state.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><literal>Active</literal></term>
                <listitem>
                    <para>
                        In this state, all data sources are actively taking data.
                        If a data source fails, the data source manager will
                        attempt to gracefully stop the run (transition to
                        <literal>Halted</literal>).  Regardless, eventually
                        a failing data source will result in the <literal>NotReady</literal>
                        state.
                    </para>
                    <para>
                        If all data sources being used support paused runs, the
                        <guibutton>Pause</guibutton> button is available
                        and clicking it will result in a transition to the
                        <literal>Paused</literal> state.
                        The <guibutton>End</guibutton> button is always available
                        in this state and forces a transition to <literal>Halted</literal>,
                        cleanly ending the run.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><literal>Paused</literal></term>
                <listitem>
                    <para>
                        This state represents a temporary halt of data taking
                        that does not close event files.   The
                        state is only reachable if all event sources support
                        pausing a run. If not, the <guibutton>Pause</guibutton>
                        button is not shown so operators of the GUI cannot
                        force a transition to this state.
                    </para>
                    <para>
                        Once <literal>Paused</literal> clicking the
                        <guibutton>Resume</guibutton> button forces a transtion
                        back to the <literal>Active</literal> state while
                        clicking the <guibutton>End</guibutton> button forces
                        a transition to the <literal>Halted</literal> state (ending
                        the run).
                    </para>
                    <para>
                        If any data source fails during the <literal>Paused</literal>
                        state, the data source manager attempts to force a transition
                        to the <literal>Halted</literal> state prior to forcing a
                        transition to the <literal>NotReady</literal> state.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
                
    </section>
    <section>
        <title>Operating the user interface</title>
        <para>
            Below is a screenshot of the graphical user interface presented by
            the ReadoutShell program.
        </para>
        <figure>
            <title>ReadoutShell's GUI</title>
            <mediaobject>
               <imageobject>
                    <imagedata fileref='readoutshell.jpg' format='JPEG' />
                </imageobject>
               <imageobject>
                    <imagedata fileref='readoutshell.eps' format='EPS' />
               </imageobject>
            </mediaobject>
        </figure>
        <para>
            The GUI is divided into four vertically stripped segments. From
            top to bottom these segments are:
        </para>
        <itemizedlist>
            <listitem>
                <para>
                    The <firstterm>Menu Bar</firstterm> which provides acces
                    to infrequenly used operations and commands.
                </para>
            </listitem>
            <listitem>
                <para>
                    The <firstterm>Run management segment</firstterm>
                    which allows you to set up run
                    parameters and to manage the ReadoutShell's state machine
                    as far as you are supposed to be able to stimulate it.
                </para>
            </listitem>
            <listitem>
                <para>
                    The <firstterm>Output Log window</firstterm> which provides
                    a scrolling text widget in which modules that make up the
                    RadoutShell can place textual messages.   In many cases
                    the messages are output in a log/severity format which just
                    means that messages have a timestamp and a severity and that the
                    severity affects the formatting of the messages.
                </para>
            </listitem>
            <listitem>
                <para>
                    The <firstterm>Status Bar</firstterm> which provides a region
                    for modules that make up the ReadoutShell, and data providers
                    to display status information that will not scroll away.
                </para>
            </listitem>
        </itemizedlist>
        <section>
            <title>The Menu bar</title>
            <para>
                The menu bar provides access to ReadoutShell commands
                that are not as frequently used as those that are presented
                by the Run Management segment described below.  In addtion
                to the fixed menus described in this section,
                <link linkend='customizing_readoutshell'
                      endterm='customizing_readoutshell_title' /> describes
                how your extensions to ReadoutShell can add more entries to the
                menus or create entirely new menus.
            </para>
            <formalpara>
                <title>The File menu</title>
                <para>
                    Provides access to file related commands.  The
                    specific operations provided are:
                    <variablelist>
                        <varlistentry>
                            <term><menuchoice><guimenu>File</guimenu><guimenuitem>Load...</guimenuitem></menuchoice></term>
                            <listitem>
                                <para>
                                    This command prompts for a file which must be
                                    a Tcl/Tk script.  The script selected is then
                                    sourced into the ReadoutShell.  The source is
                                    done in global level context.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><menuchoice><guimenu>File</guimenu>
                                <guimenuitem>Add Library..</guimenuitem></menuchoice></term>
                            <listitem>
                                <para>
                                    This command prompts for a directory.  The
                                    directory is then added to the path of
                                    directories that is searched for Tcl packages.
                                    This can be used, for example, to add a directory
                                    or set of directories that have data source
                                    provider packages to the search path making
                                    them known to the data source manager.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><menuchoice><guimenu>File</guimenu><guimenuitem>Log...</guimenuitem></menuchoice></term>
                            <listitem>
                                <para>
                                    Prompts for a file.  Once the file is selelcted,
                                    all output sent to the Output Log window is
                                    also logged to this file. Logging continues
                                    until either the <guimenuitem>Disable Log</guimenuitem>
                                    command is seleted, the program exits, or another
                                    log file is selected.
                                </para>
                                <para>
                                    If the selected log file already exists,
                                    it is opened for append, allowing a single file to
                                    easily log the output from more than one session.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><menuchoice><guimenu>File</guimenu><guimenuitem>Disable Log</guimenuitem></menuchoice></term>
                            <listitem>
                                <para>
                                    Once seleted, if logging has been established,
                                    the log file is closed.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><menuchoice><guimenu>File</guimenu><guimenuitem>Exit...</guimenuitem></menuchoice></term>
                            <listitem>
                                <para>
                                    After prompting for confirmation, exits the ReadoutShell.
                                </para>
                            </listitem>
                        </varlistentry>
                    </variablelist>
                </para>
            </formalpara>
            <formalpara>
                <title>The Data Source menu</title>
                <para>
                    This menu provides operations that allow you to establishthe set of
                    data sources you will be using and well as to list data sources
                    and their parameterizations.
                    <variablelist>
                        <varlistentry>
                            <term><menuchoice><guimenu>Data Source</guimenu>
                                <guimenuitem>Add...</guimenuitem></menuchoice></term>
                            <listitem>
                                <para>
                                    Allows you to add a data source to the set of data
                                    sources being used by the Readout GUI.  This can only
                                    be done when the state is not <literal>Paused</literal>
                                    or <literal>Active</literal>.  This also forces all
                                    running data sources to stop and transitions the state
                                    to the <literal>Not Ready</literal> state.
                                </para>
                                <para>
                                    Prompting for a data source is a two step operation.
                                    First you will be prompted for the Data source Provider
                                    (data source type) you want to use.  The built
                                    in provider are <literal>SSHPipe</literal> (suitable
                                    for Readout programs that operate on the
                                    end of an ssh pipeline), and
                                    <literal>S800</literal> which nkows how to
                                    control the S800 data acquisition system.
                                </para>
                                <para>
                                    Data sources are parameterized instances
                                    of a data source provider.  For example, the
                                    <literal>SSHPipe</literal> data source needs
                                    to  know which host the data source runs in
                                    as well as the program to run on the end
                                    of the pipe.  Optionally it an accept command
                                    line parameters for the program.
                                </para>
                                <para>
                                    Once you have been prompted for the
                                    data source provider, you will be prompted
                                    for its parameterization.  The dialog used
                                    to prompt for the data source parameterization
                                    will appear differently depending on the
                                    provider you choose.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><menuchoice><guimenu>Data Source</guimenu>
                                <guimenuitem>Delete...</guimenuitem></menuchoice></term>
                            <listitem>
                                <para>
                                    Presents a list of data sources and their
                                    parameterizations.  You can click on a
                                    data source to select it. Click
                                    <guibutton>Ok</guibutton> to delete the
                                    selected data source or <guibutton>Cancel</guibutton>
                                    to do nothing.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><menuchoice><guimenu>DataSource</guimenu>
                                <guimenuitem>List</guimenuitem></menuchoice></term>
                            <listitem>
                                <para>
                                    Lists the set of data sources you have currently
                                    selected for use and their parameterizations.
                                </para>
                            </listitem>
                        </varlistentry>
                    </variablelist>
                </para>
            </formalpara>
            <note>
                 <title>Note</title>
                 <para>
                     Data sources set up in the Data source menu are saved
                     and read back in when you next start the ReadoutShell,
                     this means that in general you only have to set up your
                     data sources once.
                 </para>
             </note>
            <formalpara>  <!-- used to get a title for these paragraphs -->
                <title> The Settings menu</title>
                <para>
                    The settings menu currently  an
                    <menuchoice><guimenu>Settings</guimenu><guimenuitem>Event Recording>></guimenuitem></menuchoice>
                    selection and a
                    <menuchoice><guimenu>Settings</guimenu><guimenuitem>Output Window..</guimenuitem></menuchoice>
                    selection.
                </para>
            </formalpara>
                <para>
                    The
                    <menuchoice><guimenu>Settings</guimenu><guimenuitem>Output Window..</guimenuitem></menuchoice>
                    selection allows you to configure the shape of the output
                    window, the number of lines of history information
                    retained and accessible through the vertical scroll-bar.
                    A checkbutton also allows you to turn on or off the display
                    of debugging output.
                </para>
                <para>
                    The
                    <menuchoice><guimenu>Settings</guimenu><guimenuitem>Event Recording>></guimenuitem></menuchoice>
                    allows you to configure parameters that control the way
                    events are recorded.
                    This allows you to set up a large number
                    configuration parameters for the event logging program.
                    The dialog this menu pops up is a bit complex and therefore
                    will be shown and described below.
                </para>
           
            <figure>
                <title>The Eventlog settings dialog</title>
                <mediaobject>
                   <imageobject>
                        <imagedata fileref='eventlogsettings.jpg' format='JPEG' />
                    </imageobject>
                   <imageobject>
                        <imagedata fileref='eventlogsettings.eps' format='EPS' />
                   </imageobject>
                </mediaobject>
            </figure>
            <variablelist>
                <varlistentry>
                    <term>Event Log Program</term>
                    <listitem>
                        <para>
                            This item allows you to select the event logging
                            program.  This is normally used either to do
                            NSCLDAQ-8.x event logging via the compatibility
                            tools, or to select the 10.x event logger when
                            using the 11.x ReadoutShell with 10.x software.
                        </para>
                        <para>
                            The
                            <guibutton>Browse...</guibutton>
                            button alows you to graphically
                            select the event logger.  You must be sure the event
                            logger will produce event segment files with names
                            that are compatible with what is expected by the
                            ReadoutShell.  See the section
                            <link linkend='readoutshell_filestruct'
                                  endterm='readoutshell_filestruct_title' /> for
                            more information about this.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>Data Source Ring URI</term>
                    <listitem>
                        <para>
                            Allows you to override the ring from which data are
                            logged.  Note that if you are using the event builder,
                            it will override this setting using the output
                            ring from the event builder instead of your selection
                            here.
                        </para>
                        <para>
                            If you click the <guibutton>Known Rings..</guibutton>
                            button, you can choose from a list of rings.  This
                            list will include all local rings and all rings remote
                            rings from which data has been accepted previously.
                            It is possible that the ring you want won't be
                            listed (if it is a remote ring from which data has
                            not been taken since the last reboot).  In that
                            case you can type in the ring specification which
                            is of the form
                            <literal>tcp://</literal><replaceable>host-name</replaceable><literal>/</literal><replaceable>ringname</replaceable>
                            Where <replaceable>host-name</replaceable> is the name
                            of the host on which the ring producer is located
                            and <replaceable>ringname</replaceable> is the name
                            of the ring in that host.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>Use <option>--number-of-sources</option></term>
                    <listitem>
                        <para>
                            This checkbutton causes the ReadoutGUI to use the
                            <option>--number-of-sources</option> option when
                            starting the event logger.  It can only be used with
                            the NSCLDAQ-11.x and later native event logger.
                        </para>
                        <para>
                            This option should be used if you are combining
                            the data from more than one event source using the
                            NSCLDAQ-11.x or later event builder.
                            See
                            <link linkend='manpage.eventlog'
                                  endterm='manpage.eventlog_title' /> for more
                            detailed information about this option.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>Additional Sources</term>
                    <listitem>
                        <para>
                            This option is related to the <literal>use --number-of-sources</literal>
                            checkbutton and only does something if that box is checked.
                            When <literal>use --number-of-sources</literal> is checked,
                            the ReadoutShell computes a
                            <firstterm>base source count</firstterm> from the
                            number of data sources it is controlling.  The
                            signed value of the <literal>Additional Sources</literal>
                            field is added to the base source count and used as
                            the value of the <option>--number-of-sources</option>
                            option when starting the event logger.
                            This value is the number of end run records the event
                            logger will expect to see to indicate all data in a
                            run has been received/recorded.
                        </para>
                        <para>
                            Usually <literal>0</literal> is the right value for
                            this control.  If, however you have data sources
                            which are not being managed by the ReadoutShell, you
                            may need to put a positive number in this box.
                            If you have data sources which are managed by the
                            ReadoutShell that don't produce end run records,
                            you may need to use a negative value here to adjust
                            the base source count downward.
                        </para>
                        <para>
                            The important thing is that the base source count
                            as modified by this value must be the number of active
                            sources that produce NSCL end run records at the
                            end of a data taking run.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>Use GUI Run number</term>
                    <listitem>
                        <para>
                            This checkbox determines if the ReadoutShell uses
                            the <option>--run</option> option when starting the
                            eventlog program.  When this option is used, its
                            value is the value in the ReadoutShell's run  number
                            control in the Run management segment of the GUI.
                            That value overrides anything eventlog might see in
                            the data stream and determines the run number field
                            of the filename in the event segments it generates.
                        </para>
                        <para>
                            This checkbutton should normally  not be checked.  It
                            should only be checked if all data sources are non-NSCL
                            data sources and none of them generate anything
                            like a begin run record that has a run number.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </section>
        <section>
            <title>The Run Management segment</title>
            <para>
                Below the ReadoutShell menubar are a set of controls that collectively
                make up the <firstterm>Run Management segment</firstterm>.  These
                are used to control data taking and the state of the system.
                Here is a description of the controls and what they do.
            </para>
            <variablelist>
                <varlistentry>
                    <term>Title</term>
                    <listitem>
                        <para>
                            This entry control allows you to type in a title.
                            Titles can only be entered when the state of the
                            system is not <literal>Active</literal> or
                            <literal>Paused</literal>.  When the state is any of
                            those, the title entry is disabled.
                        </para>
                        <para>
                            When a run is started, the text in this title
                            field is passed to the data source provider for each
                            data source.  It is the responsibility of that provider
                            to know what to do.  NSCL data source providers
                            use this to set the title of the run in the data source.
                            For standard NSCL data sources this sets the title of
                            the begin run ring item record. For the S800, this
                            sets the title in the Begin run buffer.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>Run Number</term>
                    <listitem>
                        <para>
                            As with the titlwe field, this entry control is only
                            enabled when the state is not <literal>Active</literal>
                            or <literal>Paused</literal>. When you navigate
                            focus out of this control, the value of the control
                            is checked and, if it is not a positive integer
                            (<literal>0</literal> is legal), an error message pops up
                            and the field is restored to its prior value.
                        </para>
                        <para>
                            When a run is started, the run number is passed to
                            the data source providers for  all data sources.
                            For NSCL data sources this value is passed to the readout
                            program as the run number to place in state transition
                            records.
                        </para>
                        <para>
                            For the S800 data provider, the run number is passed
                            in and used by the S800 Data source to set the run
                            number in its state transition buffers.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>Run Control cluster</term>
                    <listitem>
                        <para>
                            The run control cluster is the set of two or
                            three buttons at the left side of the
                            Run Management segment.  The top button of this
                            cluster of buttons is always the <guibutton>Start</guibutton>
                            button.  It is enabled whenever the system is in the
                            <literal>NotReady</literal> state.
                        </para>
                        <para>
                            Clicking the <guibutton>Start</guibutton> button
                            transitions to the <literal>Starting</literal> state.
                            The data source manager then attempts to start
                            all of the data sources and, if successful, the
                            system transitions to the <literal>Halted</literal>
                            state.
                        </para>
                        <para>
                            The <guibutton>Begin/End</guibutton> button contains
                            a label and state that depends on the systsem state:
                        </para>
                        <itemizedlist>
                            <listitem>
                                <para>The button is disabled when the system
                                    is in the <literal>NotReady</literal> or
                                    <literal>Starting</literal> state.
                                </para>
                            </listitem>
                            <listitem>
                                <para>The button is enabled and labeled
                                    <literal>Begin</literal> when the state
                                    is <literal>Halted</literal>. In this state,
                                    when clicked, the system transitions to
                                    <literal>Active</literal> and all data sources
                                    are told to start taking data.
                                </para>
                            </listitem>
                            <listitem>
                                <para>The button is enabled and labeled
                                    <literal>End</literal> when the state of the'
                                    system is <literal>Active</literal> or
                                    <literal>Paused</literal>.  When clicked in
                                    this state, the data sources are told to stop
                                    taking data (end the run), and the system
                                    transitions to the <literal>Halted</literal>
                                    state.
                                </para>
                            </listitem>
                        </itemizedlist>
                        <para>
                            If all data sources support pausing a run, a third
                            button appears in this cluster.  The third button
                            is the <guibutton>Pause/Resume</guibutton> button.
                        </para>
                        <itemizedlist>
                            <listitem>
                                <para>
                                    This button is disabled when the system
                                    is not in the <literal>Active</literal>
                                    or <literal>Paused</literal> state.
                                </para>
                            </listitem>
                            <listitem>
                                <para>
                                    This button is enabled and labeled
                                    <guibutton>Pause</guibutton> when the system
                                    is in the <literal>Active</literal> state.
                                    If clicked in that state, the system transitions
                                    to the <literal>Paused</literal> state and
                                    all data sources are instructed to pause data
                                    taking but keep the run alive.
                                </para>
                            </listitem>
                            <listitem>
                                <para>
                                    This button is enabled and labeled
                                    <guibutton>Resume</guibutton>. Clicking
                                    this button transition to the <literal>Active</literal>
                                    state after instructing all data sources
                                    to resume data taking in their paused run.
                                </para>
                            </listitem>
                        </itemizedlist>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><guibutton>Record</guibutton></term>
                    <listitem>
                        <para>
                            This is located below the Run control cluster.
                            It is enabled only when the state is not
                            <literal>Active</literal> or <literal>Paused</literal>
                            when checked, the next begin run will also initiate
                            the event logger as configured by the
                            <menuchoice><guimenu>Settings</guimenu><guimenuitem>Event Recording...</guimenuitem></menuchoice>
                            menu item.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>Active Run Time</term>
                    <listitem>
                        <para>
                            This is located to the right of the <guibutton>Start</guibutton>
                            button.  This represents the elapsed time of the
                            current or most recent run.  The timer is cleared
                            when a run begins, pauses when a run is paused
                            and runs when in the <literal>Active</literal> state.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>Timed Run Controls</term>
                    <listitem>
                        <para>
                            This set of controls is located to the right
                            of the <guibutton>Begin</guibutton> and
                            <guibutton>Pause</guibutton> (if visible) buttons.
                            The controls consist of two segments:
                        </para>
                        <itemizedlist>
                            <listitem>
                                <para>
                                    A <literal>Timed Run</literal> checkbutton
                                    which, when checked automatically ends
                                    a run when the Active run time counter
                                    reaches the selected length
                                </para>
                            </listitem>
                            <listitem>
                                <para>
                                    A set of drop downs that allow you to
                                    select the length of time a run will
                                    be active if timed.
                                </para>
                            </listitem>
                        </itemizedlist>
                    </listitem>
                </varlistentry>
            </variablelist>
        </section>
        <section>
            <title>The Output Log window</title>
            <para>
                The output log window provides a scrolling window for messages
                from components of the ReadoutShell and data sources.
                Must but not all messages will include a timestamp as well
                as a logging type.  The log type may also carry some visual form
                of emphasis.
            </para>
            <para>
                Note that when event logging is active, the background of ths
                window is Spartan Green, otherwise it is grey.
            </para>
            <para>
                Unless otherwise noted below, log entries are in black text
                on the current background.
                The log types are currently:
            </para>
            <variablelist>
                <varlistentry>
                    <term><literal>debug</literal></term>
                    <listitem>
                        <para>
                            The <literal>debug</literal> log level is intended
                            to provide debugging/tracing information that shows
                            programmers the internal operation of components of
                            the ReadoutShell.
                            By default these log entries are not displayed.
                            See, however
                            <link linkend='rdogui3_ui_OutputWindow'
                                endterm='rdogui3_ui_OutputWindow_title' />  for
                            information on how to make these visible.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>log</literal></term>
                    <listitem>
                        <para>
                            Log entries at the <literal>log</literal> level
                            log a significant event that represents the normal
                            operation of the program.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>output</literal></term>
                    <listitem>
                        <para>
                            <literal>output</literal> log entries capture
                            output from a program that is being run under the
                            control of the ReadoutShell (usually a data source).
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>warning</literal></term>
                    <listitem>
                        <para>
                            <literal>warning</literal> log entries are intended
                            to warn you of an unusual condition.  They are
                            displayed in magenta text on the current background.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>error</literal></term>
                    <listitem>
                        <para>
                            <literal>error</literal> log entries are intended
                            to inform you of a problem.  A typical cause of an
                            error is the unexpected exit of a data source.
                            Error log messagesa are displayed in red on a white
                            background.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
            <para>
                The log types and their visual representations can be controlled
                programmatically. See
                <link linkend='rdogui3_ui_OutputWindow'
                      endterm='rdogui3_ui_OutputWindow_title' /> for information
                that describes how to locate the output window widget
                and the interfaces it provides.
            </para>
        </section>
        <section>
            <title>The Status Bar</title>
            <para>
                At the very bottom of the ReadoutShell GUI is the status bar.
                This is used by components of the ReadoutShell and its
                extensions to provide status information about their operation
                that should not scroll out of the visible part of the Output
                Window.  Currently the only use of the status bar by the
                core ReadoutShell components is to display the event recording
                status of active runs.
            </para>
        </section>
        
    </section>
    <section id='readoutshell_filestruct'>
        <title id='readoutshell_filestruct_title'>The event logger and ReadoutShell</title>
        <para>
            The Readout GUI works with the event logger to maintain
            a directory structure of event files and associated data.
            You can associate an arbitrary set of files and directory subtrees
            with each run.  Through heavy use of symbolic links, the
            Readout GUI provides you with two views of your data.
        </para>
        <formalpara>
            <title>Events view</title>
            <para>
                The events view presents all of the event files in a single
                directory.  This view allows you to sequentially analyze
                several runs without needing to move around in the directory
                hierarchy.
            </para>
        </formalpara>
        <formalpara>
            <title>Runs view</title>
            <para>
                This view collects all of the data associated with each run
                into a single directory.
            </para>
        </formalpara>
        <para>
            The top of the directory subtree that is managed by Readout Gui is
            determined by a symbolic link; <filename>~/stagearea</filename>.
            <footnote>
                <para>
                    Environment variables can override this link however and are
                    useful in the event you are using a single account to do
                    multiple tests for which you want to segregate the data.
                </para>
            </footnote>
            This must be created by you when you set the account up for data taking
            and should point to the event area that you were assigned.
        </para>
        <para>
            When Readout GUI runs the first time it will create the directory
            structure it need underneath the directory pointed to by
            <filename>~/stagearea</filename>.
        </para>
        <para>
            The directory tree created looks like this:
        </para>
        <figure>
            <title>Readout GUI Directory tree</title>
            <literallayout><![CDATA[
stagearea +
          +----> experiment+
          |                +---> current
          |                +---> run1
          |                +---> run2
          ...             ...
          +----> complete
          +----> current
            ]]>
            </literallayout>
        </figure>
        <para>
            Let's start with the <filename>~/stagearea/current</filename> directory.
            The Readout GUI arranges for the event file set currently being
            accumulated to be written in this directory.  Event files have the name
            <literal>run-nnnn-ss.evt</literal> where <literal>nnnn</literal> is a
            zero filled run number (e.g. <literal>0001</literal>), and
            <literal>ss</literal> is a zero filled event segment.
        </para>
        <para>
            The event data from each run are segmented into files that are no
            more than 2GBytes long.  The segments number from 00.  Segmenting
            runs into file that are no larger than 2Gbytes avoids problems
            with file size limitations on some types of file systems.
        </para>
        <para>
            The <filename>~/stagearea/experiment</filename> subdirectory tree
            provides the run view of the data.  Within that directory are
            subdirectories for each recorded run.  At the end of a run,
            the Readout GUI moves the event data files from the
            <filename>~/stagearea/current</filename> directory into the
            associated run directory.  The data in
            <filename>~stagearea/experiment/current</filename> is copied into
            the run directory as well.  Files or directories pointed to by
            symoblic links in the <filename>experiment/current</filename> subtree
            are copied rather than the links themselves.
        </para>
        <para>
            Finally, the <filename>complete</filename> directory provides the
            events view of the experiment.  At the end of a run, after the
            event file segments copied to <filename>~stagearea/experiment/runn</filename>,
            a symbolic link to each event file segment is created here.
        </para>
    </section>
    <section id='customizing_readoutshell'>
        <title id='customizing_readoutshell_title'>Customizing the ReadoutShell</title>
        <para>
            The ReadoutShell can be customized in several ways.
            <itemizedlist>
                <listitem>
                    <para>
                        Environment variables can affect the operation of
                        the ReadoutShell.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        The <filename>ReadoutCallouts.tcl</filename> script
                        can provide additional code that executes at times
                        during state machine transitions.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        The <menuchoice><guimenu>File</guimenu><guimenuitem>Load...</guimenuitem></menuchoice>
                        menu command can load an arbitrary Tcl script which can
                        register itself with the run state machine.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        The <menuchoice><guimenu>File</guimenu><guimenuitem>Add Library...</guimenuitem></menuchoice>
                        menu command can add library directories that are searched
                        for packages that supply additional data source providers.
                    </para>
                </listitem>
            </itemizedlist>
        </para>
        <para>
            The remainder of this section describes these customization paths.
            Each subsection points to appropriate reference information.
        </para>
        <section>
            <title>Environment variables</title>
            <para>
                This section describes sets of related environment variables
                that can affect the way the ReadoutShell operates.
            </para>
            <table>
                <title>Event logger environment variables</title>
                <tgroup cols='3' align='left' colsep='1' rowsep='1'>
                    <thead>
                        <row>
                            <entry>Variable Name</entry>
                            <entry>Default Value</entry>
                            <entry>Meaning</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry>EVENTLOGGER</entry>
                            <entry>$DAQROOT$/bin/eventlog</entry>
                            <entry>Selects the program that will be used to log events.</entry>
                        </row>
                        <row>
                            <entry>EVENTLOGGER_RING</entry>
                            <entry>tcp://localhost/$::tcl_platform(user)</entry>
                            <entry>Selects the ring from which the event
                                   logger logs data. Note that ::tcl_platform(user)
                                   is a Tcl variable that is always defined to
                                   be the  name of the logged in user.
                            </entry>
                        </row>
                        <row>
                            <entry>EVENTLOGGER_NSRCSFLAGS_SUPPORTED</entry>
                            <entry>true</entry>
                            <entry>If true the event logger will be started with the
                                <option>--number-of-sources</option>
                                option provided as
                                described earlier. If false, this flag will be
                                omitted.  The variable accepts any valid Tcl
                                boolean value (e.g. true, false, on, off, 1, 0).
                            </entry>
                        </row>
                        <row>
                            <entry>EVENTLOGGER_UNCONTROLLED_SOURCE_COUNT</entry>
                            <entry>0</entry>
                            <entry>Integer value added to the base source count
                                to provide the value for
                                <option>--number-of-sources</option>
                            </entry>
                        </row>
                        <row>
                            <entry>EVENTLOGGER_USE_GUI_RUNNUM</entry>
                            <entry>0</entry>
                            <entry>If Tcl boolean true, the run number for the
                                current run will be provided to the eventlog
                                program via the <option>--run</option> flag
                                to determine the name of the event files.
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
            <para>
                Note that settings made using the
                <menuchoice><guimenu>Settings</guimenu><guimenuitem>Event Recording...</guimenuitem></menuchoice>
                override environment variables.  This includes settings that have
                been saved from prior runs of the program.
            </para>
            <para>
                The table below describes the settings used to control where
                data is saved.
            </para>
            <table>
                <title>Experiment file systems environment variables</title>
                <tgroup cols='3' align='left' colsep='1' rowsep='1'>
                    <thead>
                        <row>
                            <entry>Variable Name</entry>
                            <entry>Default Value</entry>
                            <entry>Meaning</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry>EVENTS</entry>
                            <entry>~/stagearea</entry>
                            <entry>The root of the directory tree that
                            ReadoutGUI will use to manage the event and related
                            data.
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
            <note>
                <title>NOTE - difference from prior versions</title>
                <para>
                    In the 10.x and prior versions it was possible to separate
                    where the experiment view lived from where the event view
                    lived by specifying the <literal>EXPDIR</literal> environment
                    variable.   This variable is now ignored and that the
                    <filename>experiment</filename> directory will always live in the
                    <filename>stagearea</filename> directory tree.
                </para>
            </note>
            <para>
                SSHPipe clients also have default parameterizations.  These
                are based on the environment variables that were used by the
                10.x readout shell.  Reliance on these environment variables
                is not recommended, as they only populate the sshPIPE parameter
                prompter and because the point of this software is to
                manage multiple data sources rather so the concept of
                default data source parameters becomes a bit meaningless.
            </para>
            <para>
                The table below shows the environment variables that can populate
                the SSHPipe settings prompter:
            </para>
            <table>
                <title>SSHPipe prompter environment variables</title>
                <tgroup cols='3' align='left' colsep='1' rowsep='1'>
                    <thead>
                        <row>
                            <entry>Variable Name</entry>
                            <entry>Default Value</entry>
                            <entry>Meaning</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry>DAQHOST</entry>
                            <entry>localhost</entry>
                            <entry>Host in which the readout program runs</entry>
                        </row>
                        <row>
                            <entry>RDOFILE</entry>
                            <entry><emphasis>undefined</emphasis></entry>
                            <entry>The path to the program to run.
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
            <para>
                One last word.  In the past, ReadoutShell has failed to run
                properly because users have defined the environment variable
                <literal>TCLLIBPATH</literal> to include Tcl package directories
                from an older version of NSCLDAQ.  In the 11.x version of the
                program, if <literal>TCLLIBPATH</literal> is defined the program
                will exit with an error message unless you additionally define
                <literal>TCLLIPATH_OK</literal> which indicates that you are
                sure your <literal>TCLLIBPATH</literal> definition doesn not
                include any NSCLDAQ directories.
            </para>
        </section>
        <section>
            <title>ReadoutCallouts.tcl</title>
            <para>
                As with the 10.x and earlier ReadoutShells, the 11.0 program
                looks for a <filename>ReadoutCallouts.tcl</filename> file which,
                if found is sourced as the program is initialized.  This script
                can contain anything, however it's main purpose is to define one
                or more of a set of <command>proc</command>s that can be called
                by the ReadoutShell at specific times during the program's execution.
            </para>
            <para>
                The ReadoutShell looks for the <filename>ReadoutCallouts.tcl</filename>
                file in the following directories.  Only the first one is
                sourced in.  Sourcing is done at the global level.
            </para>
            <itemizedlist>
                <listitem>
                    <para>
                        <filename>~</filename> your home directory.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <filename>~/stagearea/experiment/current</filename> The
                        location the metadata associated with the current run is
                        stored.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <filename>.</filename> the current working directory.
                        at the time ReadoutShell was first started.
                    </para>
                </listitem>
            </itemizedlist>
            <para>
                If ReadoutCallouts or any other script sourced into
                ReadoutShell provides them the following <command>proc</command>s
                are called.
            </para>
            <note>
                <title>NOTE</title>
                <para>
                    Two additional callouts not avaialble in <filename>ReadoutCallouts.tcl</filename>
                    scripts for NSCLDAQ-10.x and earlier have been added.
                </para>
            </note>
            <variablelist>
                <varlistentry>
                    <term><command>OnBegin</command></term>
                    <listitem>
                        <para>
                            This command is invoked when the <literal>Halted</literal>
                            state is left for the <literal>Active</literal> state.
                            The command is passed the number of the run that is
                            about to be started.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>OnEnd</command></term>
                    <listitem>
                        <para>
                            This command is invoked when the <literal>Halted</literal>
                            state is being entered from either the
                            <literal>Active</literal> or <literal>Paused</literal>
                            states.  As with <command>OnBegin</command> the run
                            number of the run being ended is passed to the command.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>OnPause</command></term>
                    <listitem>
                        <para>
                            Called when the <literal>Paused</literal> state is
                            entered.  The run number of the current run is passed
                            in.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>OnResume</command></term>
                    <listitem>
                        <para>
                            Called when the <literal>Paused</literal> state
                            is left for <literal>Active</literal>. Again the
                            current run number is passed to the command.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>OnStart</command></term>
                    <listitem>
                        <para>
                            Called wen the <literal>Halted</literal> state
                            is entered from the <literal>Starting</literal> state
                            indicating that all event sources have started
                            without errors.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>OnFail</command></term>
                    <listitem>
                        <para>
                            Called when <literal>NotReady</literal> is
                            entered from any state other than
                            <literal>NotReady</literal>.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
            <para>
                Note that all procs described above are called at the global
                level (<command>uplevel #0</command>).
            </para>
        </section>
        <section>
            <title>Integrating Tcl scripts</title>
            <para>
                Besides automatically sourcing the <filename>ReadoutCallouts.tcl</filename>
                script described in the previous section, the ReadoutShell's
                <menuchoice><guimenu>File</guimenu><guimenuitem>Load...</guimenuitem></menuchoice>
                allows you to choose a Tcl/Tk script and source it at the
                global level at any time.
                The script you source can define any of the <command>proc</command>s
                described inthe previous section.  It can also invoke API
                <command>proc</command>s from the packages described in
                <link linkend='readoutshell_api_packages'
                      endterm='readoutshell_api_packages_title' />.
            </para>
        </section>
        <section>
            <title>Libraries and Data source providers</title>
            <para>
                The <menuchoice><guimenu>File</guimenu><guimenuitem>Library...</guimenuitem></menuchoice>
                menu command allows you to choose a directory to be added to your
                library path.  One of the main reasons to do this is to add
                a custom data source provider.  This section describes in
                general terms how to create data source providers.  See
                <link linkend='provider3_intro'
                      endterm='provider3_intro_title' />
                for reference information on data source providers.
            </para>
            <para>
                Data source providers can be thought of as a class whose instances
                manage data sources.  In order to create a data source provider
                you must:
            </para>
            <itemizedlist>
                <listitem>
                    <para>Create a provider package that encapsulates the
                    provider's interface into a Tcl <command>namespace</command>.
                    </para>
                </listitem>
                <listitem>
                    <para>Optionally create a prompter package that encapsulates
                    provides a custom GUI prompter for the parameterization
                    of the data sources your data source provider manages.
                    </para>
                </listitem>
            </itemizedlist>
            <para>
                A data source provider has a name which we will refer to as
                <emphasis>providername</emphasis> in this chapter.  The provider
                must provide a Tcl package.  The name of that package must
                be <emphasis>providername</emphasis><literal>_Provider</literal>.
                Furthermore it must define a namespace
                <literal>::</literal><emphasis>providername</emphasis>.
                If these conditions are met, and the provider's package is in the
                Tcl library search path, the ReadoutShell's
                <menuchoice><guimenu>Data Source</guimenu><guimenuitem>Add...</guimenuitem></menuchoice>
                will list the <emphasis>providername</emphasis> as one of the
                providers available to add a data source
            </para>
            <para>
                Data sources have parameterizations.  It is differences in their
                parameterizations that typically distinguish between the data
                sources a provider manages.  Data sources describe their
                the form of their parameterizations via their
                <emphasis>providername</emphasis><literal>::parameters</literal>
                <command>proc</command>.   The <literal>parameters</literal>
                proc is described in
                <link linkend='provider3_parameters' endterm='provider3_parameters_title' />
            </para>
            <para>
                If the data source provider does not provide a parameter prompeter,
                the ReadoutShell will construct a default simple prompter from
                the information returned by the data sourcde provider's
                <literal>parameters</literal> proc.   This prompter will just
                be a bunch of verbose names and text entries for each name.
            </para>
            <para>
                If this prompter is too simplistic, it is possible for a
                data source provider to also define a prompter. A prompter is
                provide by providing a package named
                <emphasis>providername</emphasis><literal>_Prompter</literal>
                which defines the proc
                <literal>::</literal><emphasis>providername</emphasis><literal>::promptParameters</literal>.
                This proc is called by the ReadoutShell with no parameters and is
                expected to return the either the parameterization dict
                (see <link linkend='provider3_start' endterm='provider3_start_title' />)
                for information about this dict.  If the user declines to
                provide parameters (e.g. cancels the dialog prompter's dialog),
                the prompter should return an empty string.
            </para>
            <para>
                The parameterization of a data source, along with a data
                source id are passed to the
                <literal>::</literal><emphasis>providername</emphasis><literal>::start</literal>
                proc to start a data source.  The source id is a unique value
                that is generated by the ReadoutShell and used to refer to
                individual data sources.  The data source id is globally unique
                (not just unique to the provider). For more information
                abut starig data sources see:
                <link linkend='provider3_start' endterm='provider3_start_title' />.
            </para>
            <para>
                Not all data sources are created equal.  Thus a data source
                must provide a proc named
                <literal>::</literal><emphasis>providername</emphasis><literal>::capabilities</literal>
                that returns a dict that descsribes the capabilities of the
                data sources it manages.  For example, if a data source is not
                capable of pausing an active run its <literal>capabilities</literal>
                proc will report that in the dict it returns.
                For more information see:
                <link linkend='provider3_capabilities' endterm='provider3_capabilities_title' />
            </para>
            <para>
                Data sources must also provide a
                <literal>::</literal><emphasis>providername</emphasis><literal>::check</literal>
                proc.  The <literal>check</literal> proc is passed the data source
                id and is expected to return a boolean that is true if the
                data source is still alive or false if the data source is
                no longer alive.  The data source provider can expect the
                ReadoutShell to periodically poll its <literal>check</literal>
                proc so that it is able to report to the user an unexpected
                exit of a data source.
                The <literal>check</literal> proc is described more completely in
                <link linkend='provider3_check' endterm='provider3_check_title' />.
            </para>
            <para>
                Data source providers must know how to end a data source.  This
                mechanism is exposed to the ReadoutShell via a proc named:
                <literal>::</literal><emphasis>providername</emphasis><literal>::stop</literal>.
                This proc is passed the source id of the source to stop.
                For more information see:
                <link linkend='provider3_stop' endterm='provider3_stop_title' />.
            </para>
            <para>
                Finally, providers must be able to actually control their data
                sources.  This implies at a minimum providing
                <literal>::</literal><replaceable>providername</replaceable><literal>::begin</literal>
                to start a run and
                <literal>::</literal><replaceable>providername</replaceable><literal>::end</literal>
                to end a run.
                In addition, if the provider's capabilities include the ability
                to pause and resume an active run,
                <literal>::</literal><replaceable>providername</replaceable><literal>::pause</literal>
                and
                <literal>::</literal><replaceable>providername</replaceable><literal>::resume</literal>
                must also be supplied.
            </para>
        </section>
        <section>
            <title>Using the ReadoutGUI in your own container script</title>
            <para>
                The ReadoutShell is a very small script.  It simply creates
                an instance of a <literal>ReadoutGui</literal> object after
                getting the package paths set up properly.  This allows you
                to customize the way the Readout GUI is produced, not only via
                <filename>ReadoutCallouts.tcl</filename> scripts and
                State maching callback bundles, but by writing your own
                container script.
            </para>
            <para>
                If you are going to do this you'll certainly need to know
                about
                <link linkend='readoutshell_api_packages' endterm='readoutshell_api_packages_title' />
                and their contents so that you can effectively customize the
                behavior and appearance of the resulting GUI.
            </para>
            <para>
                Assuming the environment variable <literal>DAQROOT</literal>
                is defined and points to the top directory of the DAQ installation
                The example below shows a minimal ReadoutGUI startup script
                with  comments that show where to include customizations.
            </para>
            <example>
                <title>Custom ReadoutGUI startup script</title>
                <programlisting>

set TclLibs [file join $::env(DAQROOT) TclLibs]    <co id='custom_readoutgui_pkgdir' />
lappend auto_path $TclLibs

package require ReadoutGui
ReadoutGuiApp  r                                  <co id='custom_readoutgui_instance' />

                                                   <co id='custom_readoutgui_extend' />
                </programlisting>
            </example>
            <calloutlist>
                <callout arearefs='custom_readoutgui_pkgdir'>
                    <para>
                        This line and the next add the NSCLDAQ Tcl library
                        directory tree to the search path used by
                        <command>package require</command>.
                    </para>
                </callout>
                <callout arearefs='custom_readoutgui_instance'>
                    <para>
                        The previous line incorporates the <literal>ReadoutGui</literal>
                        package.  This package includes the entire Readout GUI
                        graphical user interface object set and also defines the
                        <classname>ReadoutGuiApp</classname> which drives the
                        Readout Graphical user interface.
                    </para>
                    <para>
                        The line itself creates an instance of the class named
                        <varname>r</varname>.  Creating an <classname>ReadoutGuiApp</classname>
                        object creates the user interface and initializes it.
                        Initialization includes locating the
                        <filename>ReadoutCallouts.tcl</filename> script and
                        sourcing it.
                    </para>
                </callout>
                <callout arearefs='custom_readoutgui_extend'>
                    <para>
                        Once the <classname>ReadoutGuiApp</classname> application
                        object has been created additional customizations
                        can be done here.  These customizations include
                        invoking procs and methods from the various
                        <link linkend='readoutshell_api_packages'
                              endterm='readoutshell_api_packages_title' /> which
                        might alter the appearance or the behavior of the application.
                    </para>
                    <para>
                        Similarly, data source providers and additional
                        run state machine callback bundles can be registered
                        at this time.
                    </para>
                </callout>
            </calloutlist>
        </section>
        <section id='readoutshell_api_packages'>
            <title id='readoutshell_api_packages_title'>ReadoutGUI API packages</title>
            <para>
                This section will describe in general terms the packages that
                make up the ReadoutGui's application programming interface.
                pointers to reference material will be provided as well. 
            </para>
            <variablelist>
                <varlistentry>
                    <term><literal>bells</literal></term>
                    <listitem>
                        <para>
                            This package provides the <classname>bells</classname>
                            class.  This can be used to ring alarm bells in accordance with
                            some pattern.
                        </para>
                        <para>
                            See
                            <link linkend='rdogui3_bells' endterm='rdogui3_bells_title' />
                            for reference information.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>Configuration</literal></term>
                    <listitem>
                        <para>
                            Provides a manager for configuration data.  This
                            package allows you to define configuration variables
                            and their defaults.  It also supports overidding
                            default values with environment variables.
                            Normally this package is used in conjunction with the
                            <literal>StateManager</literal> package to save
                            and restore the state of configuration parameters
                            to the configuration file.
                        </para>
                        <para>
                            See
                            <link linkend='rdogui3_configuration'
                                  endterm='rdogui3_configuration_title' />
                            for reference information.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>DAQParameters</literal></term>
                    <listitem>
                        <para>
                            Provides access to parameters that affect data taking.
                            This package provides both query and modify access.
                            It uses the <literal>Configuration</literal> package
                            above.
                        </para>
                        <para>
                            See
                            <link linkend='rdogui3_daqparameters'
                                  endterm='rdogui3_daqparameters_title' />
                            for reference information.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>DataSourceManager</literal></term>
                    <listitem>
                        <para>
                            This package manages the data source providers
                            and data sources.  You need to interact with this
                            package if you want to create data sources
                            yourself (e.g. to create an exportable pre-packaged ReadoutGUI
                            for a specific setup).
                        </para>
                        <para>
                            See
                            <link linkend='rdogui3_DataSourceManager'
                                  endterm='rdogui3_DataSourceManager_title' />
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>DataSourceUI</literal></term>
                    <listitem>
                        <para>
                            This package provides the user interface
                            elements that prompt for data source parameters.
                            It provides at least one useful class
                            <classname>DialogWrapper</classname> which
                            can be  used to build custom prompters for
                            data source providers.
                        </para>
                        <para>
                            See
                            <link linkend='rdogui3_DatasourceUI'
                                  endterm='rdogui3_DatasourceUI_title' />
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>Diagnostics</literal></term>
                    <listitem>
                        <para>
                            Provides simple error/warning/info dialogs.
                            See:
                            <link linkend='rdogui3_diagnostics'
                                  endterm='rdogui3_diagnostics_title' />
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>ExpFileSystemConfig</literal></term>
                    <listitem>
                        <para>
                            Provides read/write access to configuration parameters
                            that determine where event data and related meta-data
                            are stored.
                            See:
                            <link linkend='rdogui3_expfilesystemconfig'
                                  endterm='rdogui3_expfilesystemconfig_title'
                                  />
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>ReadoutGUI</literal></term>
                    <listitem>
                        <para>
                            Provides the readout GUI application class which
                            strings everything together. See
                            <link
                                  linkend='rdogui3_readoutgui'
                                  endterm='rdogui3_readoutgui_title' />
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>ReadoutGUIPanel</literal></term>
                    <listitem>
                        <para>
                            Provides a group of API elements that allow you
                            to modify the user interface presented by the
                            <classname>ReadoutGuiApp</classname> application
                            object.
                            See:
                            <link linkend='rdogui3_readoutguipanel'
                                  endterm='rdogui3_readoutguipanel_title' />
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>RunstateMachine</literal></term>
                    <listitem>
                        <para>
                            Implements the run state machine.  This also
                            provides the mechanism to register custom
                            callback bundles.
                            See:
                            <link linkend='rdogui3_runstatemachine'
                                  endterm='rdogui3_runstatemachine_title' />
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>StateManager</literal></term>
                    <listitem>
                        <para>
                            Provides a package that supports simple Tcl
                            configuration files.  A simple Tcl configuration file
                            is a script with a bunch  of <command>set</command>
                            commands that define configuration variables.
                            The package allows you define variables that
                            are exported/imported from these files and
                            getters and setters for those variables.
                        </para>
                        <para>
                            See
                            <link linkend='rdogui3_statemanager'
                                  endterm='rdogui3_statemanager_title' />
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>ui</literal></term>
                    <listitem>
                        <para>
                            Provides access to all elements of the user interface.
                            Before using this package, see if you needs are
                            met by the <literal>ReadoutGUIPanel</literal> package
                            since that tends to be easier to use.
                        </para>
                        <para>
                            See
                            <link linkend="rdogui3_ui" endterm='rdogui3_ui_title' />
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </section>
    </section>
    <section>
        <title>Remote control package</title>
        <para>
            For some systems it is useful to have a Readout GUI that can run
            independently for testing and then be controlled by another Readout
            GUI for integrated operation.  The current implementation of the
            ReadoutShell allows you to start a remote control server that is
            highly compatible with the S800 remote run control protocol (designed by
            Daniel Bazin and Scott Williams).
        </para>
        <para>
            Similarly a single readout GUI data source can be added as a data
            source.  Note that this data source is layered on top of the
            S800 provider and therefore only one of either a remote control
            readout gui or S800 can be controlled at a time.  In the future, this
            restriction will be removed.
        </para>
        <para>
            In addition to providing remote control, there is support for relaying
            output that goes to the server's output window to the output window of the
            client.
        </para>
        <para>
            To allow your readout GUI to implement a remote control/monitor
            server, add the following lines towards the front of your
            <filename>ReadoutCallouts.tcl</filename>  script:
        </para>
        <example>
            <title>Enabling remote control/monitoring of the Readout GUI</title>
            <programlisting>
package require ReadoutGuiRemoteControl  <co id='remoteserver_require' />

ReadoutGuiRemoteControl %AUTO%           <co id='remoteserver_control' />
OutputMonitor %AUTO%                     <co id='remoteserver_monitor' />
            </programlisting>
        </example>
        <calloutlist>
            <callout arearefs='remoteserver_require'>
                <para>
                    Pulls in the code that implements the server components.
                    The server component includes a server for commands and a
                    second server that forwards output to the Output window.
                </para>
            </callout>
            <callout arearefs='remoteserver_control'>
                <para>
                    Starts an instance of the remote control server.
                    This server allows a remote client to take over the
                    Readout GUI and command it to start and stop runs.
                </para>
            </callout>
            <callout arearefs='remoteserver_monitor' >
                <para>
                    Starts an intance of the output window monitor
                    server.  This server allows a remote client to spy on
                    what is being sent to the server's ouput window.
                </para>
            </callout>
        </calloutlist>
        <para>
            On the client side of this picture there are two layers of software.
            The lower layer provides location services to support connecting with
            the servers. The upper layer implements a data source povider of type
            <literal>RemoteGUI</literal>.  Since this provider is implemented in terms
            of the <literal>S800</literal> provider, and since that provider only supports a single
            client, You can only have a single <literal>S800</literal> data
            source or a single <literal>RemoteGUI</literal> data source.
        </para>
        <para>
            Note that when using these servers, they make use of the NSCLDAQ
            port registrar/allocator. As such each service is identified by a
            service name and a username.  The service names are:
            <variablelist>
                <varlistentry>
                    <term><literal>ReadoutGUIRemoteControl</literal></term>
                    <listitem>
                        <para>
                            The Remote control server.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>ReadoutGUIOutput</literal></term>
                    <listitem>
                        <para>
                            The output window monitor server.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </para>
        <para>
            The remainder of this section describes the <literal>ReadoutGuiClient</literal>
            package, the lower level of the client software.  The upper level is
            not described because it is just a data source like any other
            data source.  In most cases you can just use the data source and
            don't need to know about the existence of the lower layers.
        </para>
        <para>
            The <literal>ReadoutGuiClient</literal> package provides location
            services (translations from host/port pairs to a remote TCP/IP port
            number) as well as a convenience <literal>snit::type</literal> you
            can use to monitor the output window.
        </para>
        <formalpara>
            <title>Location services</title>
            <para>
                Two procs allow you to translate between a username and host and
                the port that a server will accept connections.
                <function>readoutGUIControlPort</function> takes the <parameter>host</parameter>
                and <parameter>user</parameter> the server runs on and returns
                the port of the remote control server for the ReadoutGUI run on that
                host by that user.
                <orderedlist>
                    <listitem>
                        <para> The <parameter>user</parameter> parameter can
                        be omitted and defaults to the logged in client user.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            If no server is listening, the return value is an
                            empty string.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            If a server is listening, the return vale is the
                            port on which it is listening.
                        </para>
                        </listitem>
                </orderedlist>
            </para>
        </formalpara>
        <para>
            <function>readoutGUIOutputPort</function> does the same thing that
            <function>readoutGUIControlPort</function> does but looks up the port
            for the Readout GUI output window monitor server.
        </para>
        <formalpara>
            <title>ReadoutGUIOutputClient</title>
            <para><classname>ReadoutGUIOutputClient</classname> provides a
            snit::type that is a complete client of the output window monitor
            server.
            </para>
        </formalpara>
        <para>
            See <link linkend='rdogui3_readoutguioutputclient'
            endterm='rdogui3_readoutguioutputclient_title' /> for full documentation
            of this class.
        </para>
    </section>
    
</chapter>
<!-- /chapter -->
<!-- manpage 3rdogui -->
	 <refentry id='rdogui_man'>
       <refmeta>
          <refentrytitle id='rdogui_man_title'>Introduction</refentrytitle>
          <manvolnum>3rdogui</manvolnum>
       </refmeta>
       <refnamediv>
          <refname>Introduction</refname>
          <refpurpose>ReadoutGUI API introduction</refpurpose>
       </refnamediv>
       
       <refsect1>
          <title>DESCRIPTION</title>
          <para>
            This section of manual pages describe the API presented by the
            ReadoutGUI.  While you may naturally find additional methods
            if you inspect source code, these are not guaranteed to be stable
            over a major release of NSCLDAQ.  Use them at your peril.
          </para>
       </refsect1>
       <refsect1>
          <title>
         PACKAGES
          </title>
            <para>
                The API is broken up int packages of related functionality.
                These packages are instaled in the <filename>TclLibs</filename>
                directory tree of your NSCLDAQ installation.
                If DAQROOT is an environment variable that points to the top
                level diretory of your NSLCDAQ installation, you can make these
                packages available by first:
            </para>
            <informalexample>
                <programlisting>
set pkghome [file join $::env(DAQROOT) TclLibs]
lappend auto_path $pkghome
                </programlisting>
            </informalexample>
            <para>
                Below are brief descriptions of the API packages with
                pointers to the reference pages that describe them:
            </para>
            <variablelist>
                <varlistentry>
                    <term><literal>bells</literal></term>
                    <listitem>
                        <para>
                            This package provides the <classname>bells</classname>
                            class.  This can be used to ring alarm bells in accordance with
                            some pattern.
                        </para>
                        <para>
                            See
                            <link linkend='rdogui3_bells' endterm='rdogui3_bells_title' />
                            for reference information.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>Configuration</literal></term>
                    <listitem>
                        <para>
                            Provides a manager for configuration data.  This
                            package allows you to define configuration variables
                            and their defaults.  It also supports overidding
                            default values with environment variables.
                            Normally this package is used in conjunction with the
                            <literal>StateManager</literal> package to save
                            and restore the state of configuration parameters
                            to the configuration file.
                        </para>
                        <para>
                            See
                            <link linkend='rdogui3_configuration'
                                  endterm='rdogui3_configuration_title' />
                            for reference information.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>DAQParameters</literal></term>
                    <listitem>
                        <para>
                            Provides access to parameters that affect data taking.
                            This package provides both query and modify access.
                            It uses the <literal>Configuration</literal> package
                            above.
                        </para>
                        <para>
                            See
                            <link linkend='rdogui3_daqparameters'
                                  endterm='rdogui3_daqparameters_title' />
                            for reference information.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>DataSourceManager</literal></term>
                    <listitem>
                        <para>
                            This package manages the data source providers
                            and data sources.  You need to interact with this
                            package if you want to create data sources
                            yourself (e.g. to create an exportable pre-packaged ReadoutGUI
                            for a specific setup).
                        </para>
                        <para>
                            See
                            <link linkend='rdogui3_DataSourceManager'
                                  endterm='rdogui3_DataSourceManager_title' />
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>DataSourceUI</literal></term>
                    <listitem>
                        <para>
                            This package provides the user interface
                            elements that prompt for data source parameters.
                            It provides at least one useful class
                            <classname>DialogWrapper</classname> which
                            can be  used to build custom prompters for
                            data source providers.
                        </para>
                        <para>
                            See
                            <link linkend='rdogui3_DatasourceUI'
                                  endterm='rdogui3_DatasourceUI_title' />
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>Diagnostics</literal></term>
                    <listitem>
                        <para>
                            Provides simple error/warning/info dialogs.
                            See:
                            <link linkend='rdogui3_diagnostics'
                                  endterm='rdogui3_diagnostics_title' />
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>ExpFileSystemConfig</literal></term>
                    <listitem>
                        <para>
                            Provides read/write access to configuration parameters
                            that determine where event data and related meta-data
                            are stored.
                            See:
                            <link linkend='rdogui3_expfilesystemconfig'
                                  endterm='rdogui3_expfilesystemconfig_title'
                                  />
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>ReadoutGUI</literal></term>
                    <listitem>
                        <para>
                            Provides the readout GUI application class which
                            strings everything together. See
                            <link
                                  linkend='rdogui3_readoutgui'
                                  endterm='rdogui3_readoutgui_title' />
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>ReadoutGUIPanel</literal></term>
                    <listitem>
                        <para>
                            Provides a group of API elements that allow you
                            to modify the user interface presented by the
                            <classname>ReadoutGuiApp</classname> application
                            object.
                            See:
                            <link linkend='rdogui3_readoutguipanel'
                                  endterm='rdogui3_readoutguipanel_title' />
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>RunstateMachine</literal></term>
                    <listitem>
                        <para>
                            Implements the run state machine.  This also
                            provides the mechanism to register custom
                            callback bundles.
                            See:
                            <link linkend='rdogui3_runstatemachine'
                                  endterm='rdogui3_runstatemachine_title' />
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>StateManager</literal></term>
                    <listitem>
                        <para>
                            Provides a package that supports simple Tcl
                            configuration files.  A simple Tcl configuration file
                            is a script with a bunch  of <command>set</command>
                            commands that define configuration variables.
                            The package allows you define variables that
                            are exported/imported from these files and
                            getters and setters for those variables.
                        </para>
                        <para>
                            See
                            <link linkend='rdogui3_statemanager'
                                  endterm='rdogui3_statemanager_title' />
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>ui</literal></term>
                    <listitem>
                        <para>
                            Provides access to all elements of the user interface.
                            Before using this package, see if you needs are
                            met by the <literal>ReadoutGUIPanel</literal> package
                            since that tends to be easier to use.
                        </para>
                        <para>
                            See
                            <link linkend="rdogui3_ui" endterm='rdogui3_ui_title' />
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </refsect1>
     </refentry>     

      <refentry id="rdogui3_bells">
        <refmeta>
           <refentrytitle id="rdogui3_bells_title">bells</refentrytitle>
           <manvolnum>3rdogui</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>bells</refname>
           <refpurpose>Provide audible alarm bells.</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
        <command>
package require bells
          </command>
          </cmdsynopsis>
        <cmdsynopsis>
            <command>
bells <replaceable>%AUTO% | name ?options...?</replaceable>
            </command>
        </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>abell</replaceable> configure <replaceable>?options...?</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>abell</replaceable> cget <replaceable>option</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>abell</replaceable> start
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>abell</replaceable> cancel
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>abell</replaceable> destroy
                </command>
            </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            This package provides a <literal>snit::type</literal> named
            <classname>bell</classname>.  Instances of <classname>bell</classname>
            produce repeating patterns of beeps.  Typically this is used to
            alert users to conditions of alarm level severity.
           </para>
           <para>
            Bells have a <option>-pattern</option> which determines the interval
            between each beep, and an <option>-interval</option> which determines
            the time between repetitions of the pattern.
            </para>
        </refsect1>
        <refsect1>
           <title>
              OPTIONS
           </title>
           <variablelist>
            <varlistentry>
                <term><option>-interval</option> <replaceable>msec</replaceable></term>
                <listitem>
                    <para>
                        Determines the time in milliseconds between repetitions of
                        the beep pattern.  If not supplied, this defaults to
                        <literal>1000</literal> (one second).  In the interval
                        between patterns, the event loop is active.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-pattern</option> <replaceable>msec1 ...</replaceable></term>
                <listitem>
                    <para>
                        Determines the interval between beeps in one repetition
                        of the pattern.  The pattern begins with a beep after
                        which there is a delay that is determined by iterating
                        through the <option>-pattern</option> list after which
                        another beep is emitted.
                    </para>
                    <para>
                        The default is a single element of <literal>100</literal>
                        which results in a double beep with the two beeps
                        separated by <literal>0.1</literal> seconds.
                    </para>
                    <para>
                        Note that during the execution of the pattern, the
                        event loop does not execute.
                    </para>
                </listitem>
            </varlistentry>
           </variablelist>
        </refsect1>
        <refsect1>
            <title>METHODS</title>
            <para>
                Instances of a bell are created using the bell command and,
                themselves become commands.  The ways to create a bell command are:
            </para>
            <informalexample>
                <programlisting>
bell <replaceable>bellname ?options...?</replaceable>
set <replaceable>somevar</replaceable> [bell %AUTO% <replaceable>?options...?</replaceable>]
                </programlisting>
            </informalexample>
            <para>
                The first example defines the command <command>bellname</command>
                to represent an object of type <classname>bell</classname>. The
                second example lets the <command>bell</command> command select
                a unique command name and assigns it to he variable
                <varname>somevar</varname>
            </para>
            <para>
                In all cases the remainder of the command (if any) is made up
                of option-value pairs which override the default options
                (See OPTIONS above).
            </para>
            <para>
                Once created, the command representing the object
                can be used to invoke several subcommands (Methods) on the
                bell object.  These are listed and described below:
            </para>
            <variablelist>
                <varlistentry>
                    <term><methodname>destroy</methodname></term>
                    <listitem>
                        <para>
                            Destroys the object.  Once this is done, the
                            command that represents the objecdt is no longer
                            defined
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><methodname>configure</methodname> <replaceable>options...</replaceable></term>
                    <listitem>
                        <para>
                            Change the configuration options for the object.
                            If the bell is currently in the process of ringing,
                            the options are changed and will take effect at the
                            end of the current pattern. See
                            OPTIONS above.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><methodname>cget</methodname> <replaceable>optname</replaceable></term>
                    <listitem>
                        <para>
                            Returns the value of the configuration option
                            <replaceable>optname</replaceable>.  See
                            OPTIONS above for a list of the legal option names.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><methodname>start</methodname></term>
                    <listitem>
                        <para>
                            Starts repetition of the bell pattern. Once started,
                            the pattern will continue as defined by the
                            OPTIONS until the program exits, the bell object is
                            destroyed or the <methodname>cancel</methodname>
                            method is invoked.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><methodname>cancel</methodname></term>
                    <listitem>
                        <para>
                            Cancels the executing pattern.  If the pattern
                            is not executing, this is a no-op.
                        </para>
                    </listitem>
                </varlistentry>            
            </variablelist>
        </refsect1>
        <refsect1>
            <title>EXAMPLE</title>
            <para>
                This example shows the full lifecycle of a bell object.
                In this case, the bell is configured to repeat every second,
                with a pattern of two short (50ms) delays and one long (100ms) delay.
            </para>
            <example>
                <title>bell example</title>
                <programlisting>
set abell [bell %AUTO% -pattern [list 50 50 100] -interval 1000]
...
$abell start;
...
$abell cancel
$abell destroy


                </programlisting>
            </example>
        </refsect1>
      </refentry>

      <refentry id="rdogui3_configuration">
        <refmeta>
           <refentrytitle id='rdogui3_configuration_title'>Configuration</refentrytitle>
           <manvolnum>rdogui3</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>Configuration</refname>
           <refpurpose>Configuration variable management</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
          <command>
package require Configuration
          </command>
          </cmdsynopsis>
            <cmdsynopsis>
                <command>
Configuration::Set <replaceable>configname value</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
Configuration::get  <replaceable>configname ?default?</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
Configuration::readEnvironment <replaceable>confname envname ?default?</replaceable>
                </command>
            </cmdsynopsis>

            <cmdsynopsis>
                <command>
Configuration::writeConfigFile <replaceable>channel</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
Configuration::readConfigFile <replaceable>path</replaceable>
                </command>
            </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            This package maintains a set of configuration variables.  The
            configuration variables are maintained in a separate namespace
            so that they cannot accidently collide with other existing global
            variables.
           </para>
           <para>
            In addition to simple set and get operations environment variables
            can be checked for existence and used to set the value of
            variables.  Configuration files can also be read and written, however
            it would probably be better to use the
            <link linkend="rdogui3_statemanager"
                  endterm='rdogui3_statemanager_title' /> package for that
            instead.
           </para>
        </refsect1>
        <refsect1>
           <title>
              PROCEDURES
           </title>
           <para>
            The <literal>Configuration</literal> package provides <command>proc</command>s
            in the <literal>::Configuration::</literal> namespace:
           </para>
           <variablelist>
            <varlistentry>
                <term><function>::Configuration::readConfigfile</function> <parameter>path</parameter></term>
                <listitem>
                    <para>
                        The configuration file at <parameter>path</parameter> is
                        read in with the namespace set to the configuration variable
                        namespace.  The file is sourced into the current
                        interpreter (one reason that
                        <link linkend="rdogui3_statemanager"
                            endterm='rdogui3_statemanager_title' /> is a better
                        choice).
                        The source is done at the global level.        
                    </para>
                    <para>
                        The configuration file is presumed to only contain
                        <command>set</command> commands.  This is not enforced however.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><function>::Configuration::readEnvironment</function>
                    <parameter>confname envname ?default?</parameter></term>
                <listitem>
                    <para>
                        If the environment variable <parameter>envname</parameter>
                        is defined, the variable <parameter>confname</parameter> in
                        the configuration namespace is set to the value of
                        <parameter>envname</parameter>.
                        If <parameter>envname</parameter> does not exist,
                        then <parameter>confname</parameter> is set to
                        <parameter>default</parameter>.  If the
                        <parameter>default</parameter> parameter is not supplied,
                        and <parameter>envname</parameter> is not defined,
                        the variable is defined, but set to the empty string. 
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><function>::Configuration::Set</function> <parameter>confname value</parameter></term>
                <listitem>
                    <para>
                        Sets the configuration variable named <parameter>confname</parameter>
                        to <parameter>value</parameter>.   If <parameter>confname</parameter>
                        has not yet been defined this will create it.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><function>::Configuration::::get</function> <parameter>confname ?default?</parameter></term>
                <listitem>
                    <para>
                        If <parameter>confname</parameter> is already a defined
                        configuration parameter its value is returned.   If
                        not, the value of <parameter>default</parameter> is returned.
                        If not supplied <parameter>default</parameter> will
                        be the empty string.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><function>::Configuration::writeConfigFile</function> <parameter>channel</parameter></term>
                <listitem>
                    <para>
                        Writes the configuration out to the open <parameter>channel</parameter>.
                        What this means is that a .tcl script consisting of simple
                        <command>set</command> commands will be written that can
                        be read in with <function>::Configuration::readConfigFile</function>
                        to restore the state of all defined configuration variables
                        as they are defined at the time <function>::Configuration::writeConfigFile</function>
                        is called.
                    </para>
                </listitem>
            </varlistentry>
            
           </variablelist>
        </refsect1>

      </refentry>
      <refentry id="rdogui3_daqparameters">
        <refmeta>
           <refentrytitle id='rdogui3_daqparameters_title'>DAQParameters</refentrytitle>
           <manvolnum>rdogui3</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>Data Acquisition parameters</refname>
           <refpurpose>Cluster of configuration parameters for data acquisition</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
            <command>
package require DAQParameters
          </command>
          </cmdsynopsis>
            <cmdsynopsis>
                <command>
::DAQParameters::setDefaults
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
::DAQParameters::environmentOverrides
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
::DAQParameters::getEventLogger
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
::DAQParameters::getEventLoggerRing
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
::DAQParameters::getUseNsrcsFlag
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
::DAQParameters::getAdditionalSourceCount
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
::DAQParameters::geRunNumberOverrideFlag
                </command>
            </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            This package provides a cluster of configuration parameters
            (in the sense of
            <link linkend="rdogui3_configuration"
                  endterm='rdogui3_configuration_title' />).
            Mechanisms to set default values for these parameters are provided
            as well as convenience functions to fetch specific configuration
            values without the need to know the actual configuration variable name.
           </para>
           <para>
            See PROCEDURES below for a description of each command supplied
            by this package.
           </para>
        </refsect1>
        <refsect1>
           <title>
              PROCEDURES
           </title>
           <variablelist>
            <varlistentry>
                <term><function>::DAQParameters::setDefaults</function></term>
                <listitem>
                    <para>
                        Sets default values for each configuration value
                        in this cluster.  See DEFAULT VALUES for information
                        about the default values for these parameters.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><function>::DAQParameters::environmentOverrides</function></term>
                <listitem>
                    <para>
                        Applies the environment variables that normally
                        control this part of the configuration to the parameters.
                        See ENVIRONMENT below for more information about the
                        the environment variables used.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><function>::DAQParameters::getEventLogger</function></term>
                <listitem>
                    <para>
                        Returns the command that will be used to start the
                        event logger.  This is a base command string without
                        any options.  At run time the full command string is
                        computed from this value and the other
                        parameters in this cluster.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><function>::DAQParameters::getEventLoggerRing</function></term>
                <listitem>
                    <para>
                        Returns the URI of the ring buffer from which the
                        event logger will log data.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><function>::DAQParameters::getUseNsrcsFlag</function></term>
                <listitem>
                    <para>
                        Get the value of the flag that controls whether or not
                        the event logger is started out with the
                        <option>--number-of-sources</option> option on the
                        command line.  If this value is <literal>true</literal>
                        the flag value will be computed from the number of
                        data sources and the value returned by
                        <function>::DAQParameters::getAdditionalSourceCount</function>
                        command and supplied on the command line.  If the
                        value returned from this command is <literal>false</literal>
                        this option will not be used.  Note that this
                        option cannot be used with event loggers from NSCLDAQ
                        earlier than version 11.0.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><function>::DAQParameters::getAdditionalSourceCount</function></term>
                <listitem>
                    <para>
                        Gets the number of additional sources to add to the
                        number of data sources that will be supplied to the
                        <option>--number-of-sources</option> eventlog flag.
                        The purpose of that flag is to tell the event logger how
                        many end run events to expect before considering a run over.
                    </para>
                    <para>
                        This value is meaningless when
                        <function>::DAQParameters::getUseNsrcsFlag</function>
                        returns <literal>false</literal> beause in that case,
                        the <option>--number-of-sources</option> option will not
                        be added to the command line.
                    </para>
                    <para>
                        The dual purpose of this option is to deal with
                        event sources that are not controlled by the ReadoutGUI
                        that contribute end run records (positive value for
                        the parameter), and to handle event sources that
                        <emphasis>are</emphasis> controlled by the ReadoutGUI
                        that don't supply end run records (negative value).
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><function>::DAQParameters::getRunNumberOverrrideFlag</function></term>
                <listitem>
                    <para>
                        When true, the event logger is started with the
                        <option>--run</option> flag which is given the value
                        of the run number in the ReadoutGUI.  This is intended
                        for cases when the event logger is used with data sources
                        that don't contribute start of run event records, or
                        contribute start of run records with run number fields
                        that cannot be trusted.
                    </para>
                </listitem>
            </varlistentry>
            
           </variablelist>
        </refsect1>
        
        <refsect1>
            <title>DEFAULT VALUES</title>
            <para>
                The call to <function>::DAQParameters::setDefaults</function>
                sets the values of the configuration variables as follows:
            </para>
            <variablelist>
                <varlistentry>
                    <term>Event logger command</term>
                    <listitem>
                        <para>
                            <replaceable>DAQROOT</replaceable>/bin/eventlog
                            where <replaceable>DAQROOT</replaceable> is the
                            top level installation difectory of NSCLDAQ.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>Event logger ring URI</term>
                    <listitem>
                        <para>
                            <literal>tcp://localhost//$::tcl_platform(user)</literal>
                            Note that the Tcl global array <varname>::tcl_platform</varname>'s
                            <literal>user</literal> element contains the name
                            of the logged in user.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>Use <option>--number-of-sources</option></term>
                    <listitem>
                        <para>
                            <literal>true</literal>
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>Additional data sources</term>
                    <listitem>
                        <para>
                            <literal>0</literal>
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>Use <option>--run</option> run number override</term>
                    <listitem>
                        <para>
                            <literal>false</literal>
                        </para>
                    </listitem>
                </varlistentry>
                
            </variablelist>
            <para>
                These defaults are suitable for the case of a single event
                source compatible with NSCLDAQ-11.x
            </para>
        </refsect1>
        
        <refsect1>
            <title>ENVIRONMENT</title>
            <para>
                Invoking <function>::DAQParameters::environmentOverrides</function>
                looks for the following environment variables:
            </para>
            <variablelist>
                <varlistentry>
                    <term><literal>EVENTLOGGER</literal></term>
                    <listitem>
                        <para>
                            Overrides the default event logger program with
                            its value.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>EVENTLOGGER_RING</literal></term>
                    <listitem>
                        <para>
                            Overrides the event logger ringbuffer URI.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>EVENTLOGGER_NSRCSFLAGS_SUPPORTED</literal></term>
                    <listitem>
                        <para>
                            If true then <option>--number-of-sources</option>
                            will be used with the eventlog program.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>EVENTLOGGER_UNCONTROLLED_SOURCE_COUNT</literal></term>
                    <listitem>
                        <para>
                            If provided contains an additional source count for
                            use when computing the value of
                            <option>--number-of-sources</option>
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>EVENTLOGGER_USE_GUI_RUNNUM</literal></term>
                    <listitem>
                        <para>
                            If true the <option>--run</option> option will be
                            used to override run numbers in begin run records or,
                            alternatively provide run numbers where none are
                            avaialble.
                        </para>
                    </listitem>
                </varlistentry>
                
            </variablelist>
        </refsect1>
        

      </refentry>
      <refentry id="rdogui3_DataSourceManager">
        <refmeta>
           <refentrytitle id='rdogui3_DataSourceManager_title'>DataSourceManager</refentrytitle>
           <manvolnum>3rdogui</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>DataSourceManager</refname>
           <refpurpose>Data source manager and its API</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
            <command>
package require DataSourceManager
            </command>
          </cmdsynopsis>
            <cmdsynopsis>
                <command>
set <replaceable>singleton</replaceable> [DataSourcemanagerSingleton %AUTO%]
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
set <replaceable>providers</replaceable> [DataSourceManager::enumerateProviders]
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>$singelton</replaceable> load <replaceable>provider-name</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
set <replaceable>params</replaceable> \
[<replaceable>$singleton</replaceable> parameters <replaceable>provider-name</replaceable>]
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
set <replaceable>caps</replaceable> \
[<replaceable>$singleton</replaceable> capabilities <replaceable>provider-name</replaceable>]
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
set <replaceable>caps</replaceable> \
[<replaceable>$singleton</replaceable> systemCapabilities]
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>$singleton</replaceable> addSource <replaceable>provider-name param-dict</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
set <replaceable>sourceid</replaceable> \
[<replaceable>$singleton</replaceable> removeSource <replaceable>id</replaceable>]
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
set <replaceable>status</replaceable> [<replaceable>$singleton</replaceable> check]
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
set <replaceable>source-descriptions</replaceable> [<replaceable>$singleton</replaceable> sources]
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>$singleton</replaceable> stop <replaceable>id</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>$singleton</replaceable> stopAll
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>$singleton</replaceable> startAll
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>$singleton</replaceable> begin <replaceable>run-number title</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>$singleton</replaceable> end
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>$singleton</replaceable> pause
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>$singleton</replaceable> resume
                </command>
            </cmdsynopsis>


        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            The <literal>DataSourceManager</literal> is in charge of maintaining
            knowledge of the data source providers and active data sources.
            The <literal>DataSourceManager</literal> as used in the ReadoutGUI
            is a
            <ulink url='http://en.wikipedia.org/wiki/Singleton_pattern'>singleton object</ulink>.
            Rather than directly instantiating a <classname>DataSourceManager</classname>
            your code should instantiate a
            <classname>DataSourcemanagerSingleton</classname>.
            Doing so generates a
            <ulink url='http://en.wikipedia.org/wiki/Facade_pattern'>Facade object</ulink>
            that wraps the one and only data source manager the ReadoutGUI
            uses.   The resulting object exports and delegates all
            methods to the underlying singleton.
           </para>
        </refsect1>
        <refsect1>
           <title>
              TYPE METHODS
           </title>
           <variablelist>
            <varlistentry>
                <term><methodname>DataSourceManager::enumerateProviders</methodname></term>
                <listitem>
                    <para>
                        Returns a list of the names of the data source providers
                        known at the time of the call.  For more information
                        on data source providers see
                        <link linkend='provider3_intro' endterm='provider3_intro_title' />
                        and the interaces its related pages describe...
                    </para>
                    <para>
                        The set of providers is determined by the set of packages
                        that can be located and loaded with names appropriate
                        to that of a data source provider.  No attempt is made
                        to determine if these packages contain code that actually
                        meets all the requirements of a data source provider.
                    </para>
                </listitem>
            </varlistentry>
            
           </variablelist>
        </refsect1>
        <refsect1>
            <title>METHODS</title>
            <para>
                The public methods provided by the data source manage are:
            </para>
            <variablelist>
                <varlistentry>
                    <term><methodname>load</methodname> <parameter>provider-name</parameter></term>
                    <listitem>
                        <para>
                            Loads a data source provider package.  Note that:
                            <itemizedlist>
                                <listitem>
                                    <para><parameter>provider-name</parameter> is the
                                          name of the provider not the name of the
                                          provider's package (e.g
                                          <literal>SSH</literal> not <literal>SSH_Provider</literal>).
                                    </para>
                                </listitem>
                                <listitem>
                                    <para>For the load to be successful the provider's
                                    package must be locatable via the normal Tcl
                                    <command>package require</command> command.
                                    For custom providers this may necessitate changes
                                    to the <varname>::auto_path</varname> variable.
                                    </para>
                                </listitem>
                            </itemizedlist>
                        </para>
                        <para>
                            Until a package is loaded nothing can be done with it.
                            You must use the <methodname>load</methodname> method
                            rather than directly doing a <command>package require</command>
                            as the data source manager maintains a list of registered packages.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><methodname>parameters</methodname> <parameter>provider-name</parameter></term>
                    <listitem>
                        <para>
                            Returns a dict that describes the parameterization
                            required by data sources that <parameter>provider-name</parameter>
                            manages. See
                            <link linkend='provider3_intro' endterm='provider3_intro_title' />
                            for a description of this dict.
                        </para>
                        <para>
                            If you are not familiar with Tcl dicts see
                            <ulink url='http://www.tcl.tk/man/tcl8.5/TclCmd/dict.htm'>
                                http://www.tcl.tk/man/tcl8.5/TclCmd/dict.htm</ulink>
                            for a description of dicts and the command ensemble that
                            acts on them.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><methodname>capabilities</methodname> <parameter>provider-name</parameter></term>
                    <listitem>
                        <para>
                            Returns a dict that describes the capabilities of
                            <parameter>provider-name</parameter>.  The form of
                            this dict is described in
                            <link linkend='provider3_intro' endterm='provider3_intro_title' />.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><methodname>systemCapabilities</methodname></term>
                    <listitem>
                        <para>
                            Returns the minimal set of capabilities the
                            data sources have.  This is the intersection of
                            the capabilities of all providers that are represented
                            by data sources that have been added to the manager.
                        </para>
                        <para>
                            Another way to look at this method is that it returns
                            a dict of capabilities that all sources have.  For
                            example, if two data sources have been added to the manager,
                            one of them capable of pausing a run and the other not,
                            the resulting dict will show that the system cannot
                            pause runs.
                            The form of this dict is described in
                            <link linkend='provider3_intro' endterm='provider3_intro_title' />.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><methodname>addSource</methodname> <parameter>provider-name params</parameter></term>
                    <listitem>
                        <para>
                            Adds a data source to the manager.  
                            <parameter>provider-name</parameter> defines the name
                            of the data source provider that will manage the
                            source.  <parameter>params</parameter> is a dict
                            that defines the actual parameterization of this
                            source.  The keys in this dictionary are determined
                            by the result of <methodname>parameters</methodname>
                            for the provider.
                        </para>
                        <para>
                            Note that the
                            source is not yet started.  See
                            <methodname>startAll</methodname> below.
                            Note as well that this method allocates and
                            defines the source id for the data source. That
                            implies that if the <parameter>params</parameter> dict
                            has a <literal>sourceid</literal> key its value
                            will be overwritten when the parameterization
                            is stored internally by the manager.
                        </para>
                        <para>
                            The result of this method is a unique source id
                            which can be used to identify this source
                            when calling methods that work on a single
                            source.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><methodname>removeSource</methodname> <parameter>source-id</parameter></term>
                    <listitem>
                        <para>
                            Removes a source (the inverse of <methodname>addSource</methodname>)
                            from the manager.  If the soure is running, it is
                            stopped first.
                            <parameter>source-id</parameter> is the source
                            id returned from the call to <methodname>addSource</methodname>
                            that added the source to the manager.
                        </para>
                        <para>
                            It is an error to attempt to remove a nonexsitent
                            source.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><methodname>check</methodname></term>
                    <listitem>
                        <para>
                            Checks the liveness of all data sources.
                            This returns a dict whose keys are data source ids
                            and whose values are the results of check on those
                            data sources.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><methodname>sources</methodname></term>
                    <listitem>
                        <para>
                            Returns information about all of the sources
                            that have been added to the manager.
                            The result is a list ofr dicts.  Each
                            dict contains the parameterization of the data
                            source as well as keys for
                            <literal>sourceid</literal> which has the source
                            id as a value and <literal>provider</literal>
                            which is the name of the provider that manages
                            this source when it is running.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><methodname>stop</methodname> <parameter>source-id</parameter></term>
                    <listitem>
                        <para>
                            Stops the single source identified by <parameter>source-id</parameter>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><methodname>stopAll</methodname></term>
                    <listitem>
                        <para>
                            Stops all data sources.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><methodname>startAll</methodname></term>
                    <listitem>
                        <para>
                            Starts all data sources that have been added.
                        </para>
                    </listitem>
                </varlistentry>
                
            </variablelist>
            <para>
                In addition to the data source manipulation methods described
                above, the manager also exports run control methods.  It is
                better, however to force run state transitions to happen via
                the
                <link linkend='rdogui3_runstatemachine'
                      endterm='rdogui3_runstatemachine_title' />.
                In that way other actions associated with run state transitions
                can occur.
            </para>
            <para>
                For completeness, the run state control methods
                are described below.  The operate by iterating over the
                running data sources and delegating the method to their
                provider.
            </para>
            <variablelist>
                <varlistentry>
                    <term><methodname>begin</methodname> <parameter>run-number title</parameter></term>
                    <listitem>
                        <para>
                            Starts a run in all of the providers.  The
                            <parameter>run-number</parameter> and
                            <parameter>title</parameter> parameters are
                            passed without interpretation to the provider's
                            <command>begin</command> command for each data source.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><methodname>end</methodname></term>
                    <listitem>
                        <para>
                            Iterates over all data sources calling 
                            <command>end</command> for them in their
                            data source provider.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><methodname>pause</methodname></term>
                    <listitem>
                        <para>
                            Iterates over all data sources pausing them in
                            the middle of an active run. Before invoking
                            this method, the caller must ensure all data sources
                            implement the <command>pause</command> operation by
                            using <methodname>systemCapabilities</methodname>
                            to get the intersection of all data source capabilites.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><methodname>resume</methodname></term>
                    <listitem>
                        <para>
                            Iterates over all data sources resuming the paused
                            run.   
                        </para>
                    </listitem>
                </varlistentry>
                
                
            </variablelist>
            
        </refsect1>

      </refentry>

      <refentry id="rdogui3_DatasourceUI">
        <refmeta>
           <refentrytitle id="rdogui3_DatasourceUI_title">DataSourceUI</refentrytitle>
           <manvolnum>3rdogui</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>DataSourceUI</refname>
           <refpurpose>Data source parameter user interface</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
            <command>
package require DataSourceUI
          </command>
          </cmdsynopsis>
            <cmdsynopsis>
                <command>
set <replaceable>providerChooser</replaceable> [ChooseProvider <replaceable>path</replaceable>]
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
set <replaceable>dsrcprompter</replaceable> [PromptDataSource <replaceable>path</replaceable>]
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
set <replaceable>dialog</replaceable> [DialogWrapper <replaceable>path</replaceable>]
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
set <replaceable>provider</replaceable> [DataSourceUI::getProvider <replaceable>provider-list</replaceable>]
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
set <replaceable>params</replaceable> [DataSourceUI::getParameters <replaceable>provider-name param-dict</replaceable>]
                </command>
            </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            This package provides a set of mega-widgets and <command>proc</command>s
            that support prompting for information about data sources (providers and
            parameterization).  In addtion a generic dialog wrapper megawidget is
            supplied that allows you to wrap any form inside a dialog with
            <guibutton>Ok</guibutton> and optional <guibutton>Cancel</guibutton>
            buttons with the capability of going modal.
           </para>
           <para>
            The <classname>ChooseProvider</classname> megawidget along with the
            <command>DataSourceUI::getProvider proc</command> allow you to prompt
            for a data source provider.  <classname>ChooseProvider</classname>
            is the prompting form, and <command>DataSourceUI::getProvider</command>
            wraps that form with a <classname>DialogWrapper</classname> and uses
            that to modally prompt for a data source provider.
           </para>
           <para>
            The <classname>PromptDataSource</classname> megawidget understands
            how to produce a generic prompter given the parameterization
            dict of a provder.  <command>DataSourceUI::getParameters</command>
            wraps <classname>PromptDataSource</classname> in a
            <classname>DialogWrapper</classname> and modally waits for the user
            to set the parameterization which is returned to the caller.
           </para>
           <para>
            See MEGAWIDGETS for documentation about the widgets themselves.
            See PROCS for documentation about the commands.
           </para>
        </refsect1>
        <refsect1>
           <title>
              MEGAWIDGETS
           </title>
           <refsect2>
            <title>ChooseProvider</title>
            <para>
                This megawidget provides a scrolling list box.  The
                <option>-providers</option> option is the list of
                data source provider names that will stock the list.
                <option>-command</option> if not null is a script that will
                be called at the global level if an item in the list box is clicked.
            </para>
            <para>
                The <methodname>selected</methodname> method returns the text
                of the list box element that is currently selected.  If no item
                is selected, the empty string is returned.
            </para>
           </refsect2>
           <refsect2>
            <title>PromptDataSource</title>
            <para>
                This megawidet provides a very generic form that prompts for
                the parameterization of a data source.  The
                <option>-parameters</option> option should be set with the parameterization
                dict for the data source provider.  The dict is the dict
                that is returned from the <command>parameters</command> proc of
                a data source provider.  The form consists of a set of lines
                each line has a label widget, that displayse the long textual
                desription of the parameter, and an entry the user fills in to
                set that parameter's value.
            </para>
            <para>
                The <methodname>getForm</methodname> method of the
                <classname>PromptDataSource</classname> megawidget returns a
                dict whose keys are short parameter names (from the data source
                parameterization) and whose values are a list containing in order:
                <itemizedlist>
                    <listitem>
                        <para>The parameter prompt string</para>
                    </listitem>
                    <listitem>
                        <para>The path to the prompting widget for ths parameter.
                        </para>
                    </listitem>
                    <listitem>
                        <para>The contents of the entry widget.
                        </para>
                    </listitem>
                </itemizedlist>
                </para>
           </refsect2>
           <refsect2 id='rdogui3_dialogwrapper'>
            <title id='rdogui3_dialogwrapper_title'>DialogWrapper</title>
            <para>
                <classname>DialogWrapper</classname> is a helper widget that
                assists in building modal dialogs.  A dialog is typically
                composed of two sections.  The top section, the control area,
                contains a form with input controls, or possibly just a message.
                The bottom section, the action area, contains one or two buttons.
                The first button <guibutton>Ok</guibutton> accepts the form
                values while the second button <guibutton>Cancel</guibutton> 
                can optionally be displayed and indicates the user wants to
                dismiss the dialog without making choices.
            </para>
            <para>
                The <classname>DialogWrapper</classname> allows you to create an Tcl widget
                (usually a frame) and establish it as the control area of a dialog.
                The control area widget must be the child of an appropriate
                subwidget of the dialog.  That widget is returned from the
                <methodname>controlarea</methodname> method call.
            </para>
            <para>
                Once the control area widget hierarchy has been constructed and
                interally laid out, its top level frame should be configured
                to be the <option>-form</option> option of the dialog.  The
                dialg widget itself can gen generally be managed into a toplevel
                widget which displays it.
            </para>
            <para>
                To block for user interaction with the dialog (make it modal),
                invoke the <methodname>modal</methodname> method.  That method will
                return one of:
            </para>
            <variablelist>
                <varlistentry>
                    <term><literal>Ok</literal></term>
                    <listitem>
                        <para>
                            The user clicked the Ok button.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>Cancel</literal></term>
                    <listitem>
                        <para>
                            The user clicked the Cancel button.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>Destroy</literal></term>
                    <listitem>
                        <para>
                            The user destroyed the dialog using the window
                            manager control for that.
                        </para>
                    </listitem>
                </varlistentry>
                
            </variablelist>
            <para>
                Note that if the return is either <literal>Ok</literal> or
                <literal>Cancel</literal> it is still possible to retrieve
                items for the form (in the case of <literal>Cancel</literal>
                your application might use these values to default fields
                in future instances of the dialog).
            </para>
            <para>
                If the return value is <literal>Destroy</literal> the
                form widget tree has already been destroyed and therefore
                cannot be used.
            </para>
            <para>
                The <option>-showcancel</option> option is a boolean that
                controls whether or not the <guibutton>Cancel</guibutton>
                button is displayed.
            </para>
            <para>
                The normal lifecycle of this widget is to
                <itemizedlist>
                    <listitem><para>Create a toplevel widget for the dialog</para></listitem>
                    <listitem><para>Create the dialog as a child of the toplevel</para></listitem>
                    <listitem><para>Invoke the <methodname>controlarea</methodname> method to get the control areay container</para></listitem>
                    <listitem><para>Create a frame under the control area</para></listitem>
                    <listitem><para>Create the control area input form and lay it out in the frame above</para></listitem>
                    <listitem><para>Configure the dialog so that it's <option>-form</option> option is the frame above.</para></listitem>
                    <listitem><para>Invoke the <methodname>modal</methodname> method to wait for the user to interact with the form</para></listitem>
                </itemizedlist>
            </para>
            <para>
                If <methodname>modal</methodname> returned <literal>Ok</literal>
                the data from the user are fetched from the controls in the
                controlarea and the toplevel is destroyed.  If <methodname>modal</methodname>
                returns <literal>Cancel</literal> the toplevel is destroyed.
                If <methodname>modal</methodname> returned <literal>Destroy</literal>
                nothing is done because this happens when the toplevel gets destroyed by
                the user.
            </para>
           </refsect2>
        </refsect1>
        <refsect1>
            <title>PROCS</title>
            <para>
                Two of the forms described in the MEGAWIDGETS section above have
                associated convenience functions.    These convenience functions
                wrap their megawidget in a <classname>DialogWrapper</classname>
                invoke <methodname>modal</methodname> and return the
                results of the user interaction with the dialog to the caller.
            </para>
            <variablelist>
                <varlistentry>
                    <term><function>::DataSourceUI::getProvider</function> <parameter>providers</parameter></term>
                    <listitem>
                        <para>
                            Prompts for a data source provider.  <parameter>providers</parameter>
                            is a list of the providers to choose from.
                            If the user selected a provider its name is returned
                            as the value of this proc.  If the user clicked
                            <guibutton>Cancel</guibutton> or destroyed the
                            dialog an empty string is returned.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><function>::DataSourceUI::getParameters</function> <parameter>provider-name parameters</parameter></term>
                    <listitem>
                        <para>
                            Prompts for the parameterization of an instance
                            (data source) of a <parameter>provider-name</parameter>.
                            <parameter>parameters</parameter> is the
                            dict that defines the parameterization of the
                            provider's instances.
                        </para>
                    </listitem>
                </varlistentry>
                
            </variablelist>
        </refsect1>
        <refsect1>
            <title>EXAMPLES</title>
            <para>
                The example below shows how to use the <classname>DialogWrapper</classname>.
                In this case, the widgets that make up the control area are just
                constructed in line.  In general it makes sense to build
                a megawidget for the conotrolarea using snit or itk and
                provide that megawidget with methods to fetch form elements.
            </para>
            <example>
                <title>Sample use of the <classname>DialogWrapper</classname></title>
                <programlisting>
 
toplevel .dialog
DialogWrapper .dialog.wrapper                          <co id='dlgwrapper_toplevel' />

set controlArea [.dialog.wrapper controlarea]
set f [ttk::frame $controlArea.frame]                  <co id='dlgwrapper_ctlarea' />

ttk::label $f.namelabel -text {What is your name}
ttk::entry $f.name

ttk::label $f.colorlabel -text {What is your favorite color}
ttk::combobox $f.colors  -values [list red green "red no green"]
                                                     <co id='dlgwrapper_form1' />
ttk::label $f.vlabel \
    -text {What is the air speed velocity of a fully laden swallow}
ttk::combobox $f.v        -values [list African English]

grid $f.namelabel $f.name
grid $f.colorlabel $f.colors                         <co id='dlgwrapper_form2' />
grid $f.vlabel    $f.v

.dialog.wrapper configure -form $f
pack .dialog.wrapper                                 <co id='dlgwrapper_display' />

set result [.dialog.wrapper modal]                   <co id='dlgwrapper_modal' />

if {$result eq "Ok"} {
    set name [$f.name get]
    set color [$f.color get]                         <co id='dlgwrapper_ok' />
    set velocity [$f.v get]

    destroy .dialog

    bridgeOfDeath $name $color $velocity
    

} elseif {$result eq "Cancel"} {
   destroy .dialog                                   <co id='dlgwrapper_cancel' />
}
                                                    <co id='dlgwrapper_destroy' />
               </programlisting>
            </example>
            <calloutlist>
                <callout arearefs='dlgwrapper_toplevel'>
                    <para>
                        These two commands make a top level widget that will
                        hold the dialog and the dialog wrapper itself.  The
                        dialog wrapper is not yet managed into the top level.
                        If it is packed now, before it knows the shape of its
                        control are there might be an unpleasant jitter as it
                        comes up and then re-computes the geometry.
                    </para>
                </callout>
                <callout arearefs='dlgwrapper_ctlarea'>
                    <para>
                        These two commands ask the dialog wrapper to tell us
                        which widget should be the parent of our control area.
                        A frame is created and its full path is stored in the
                        variable f for convenience.
                    </para>
                </callout>
                <callout arearefs='dlgwrapper_form1'>
                    <para>
                        This makes some rather silly labels and inputs that
                        comprise the part of the dialog (control area) that
                        the user interacts with.
                    </para>
                </callout>
                <callout arearefs='dlgwrapper_form2'>
                    <para>
                        The <command>grid</command> geometry manager is then
                        used to arrange the labels and input controls into
                        <varname>f</varname>.
                    </para>
                </callout>
                <callout arearefs='dlgwrapper_display'>
                    <para>
                        The dialog widgets <option>-form</option> is set
                        to <varname>f</varname>. At that time the dialog frame
                        manages the control area and therefore comes to know
                        its size and shape.  The <command>pack</command> command
                        makes the dialog visible inside the top level widget.
                    </para>
                </callout>
                <callout arearefs='dlgwrapper_modal'>
                    <para>
                        The <methodname>modal</methodname> method blocks until
                        the user clicks <guibutton>Ok</guibutton>,
                        <guibutton>Cancel</guibutton> or destroys the widget
                        via the window manager controls.
                    </para>
                    <para>
                        The action peformed by the user to complete his or her
                        interaction with the dialog is saved in
                        <varname>result</varname>
                    </para>
                </callout>
                <callout arearefs='dlgwrapper_ok'>
                    <para>
                        If the user clicked the <guibutton>Ok</guibutton> button
                        in the dialog actinon area, <varname>result</varname> will
                        be <literal>Ok</literal>. In that case, the values of
                        the input controls are pulled out of the control area
                        widgets before the dialogt is destroyed.
                    </para>
                    <para>
                        <function>bridgeOfDeath</function> is just symbolic of
                        some <command>proc</command> that then operates on the
                        results of the dialog.  Equally easily, this could be
                        embedded in a proc and the results provided to the caller.
                    </para>
                </callout>
                <callout arearefs='dlgwrapper_cancel'>
                    <para>
                        If the user clicked the <guibutton>Cancel</guibutton> button,
                        <varname>result</varname> will be <literal>Cancel</literal>.
                        In this case we are going to ignore the data in the form
                        and just destroy the dialog
                    </para>
                </callout>
                <callout arearefs='dlgwrapper_destroy'>
                    <para>
                        If the user destroyed the dialog using the window manager
                        controls, the value of <varname>result</varname> will be
                        <literal>Destroy</literal>.  In this case, since the
                        top level is already destroyed or well on its way to being
                        destroyed, we just do nothing.
                    </para>
                </callout>
            </calloutlist>
        </refsect1>
      </refentry>
      
      <refentry id="rdogui3_diagnostics">
        <refmeta>
           <refentrytitle id='rdogui3_diagnostics_title'>Diagnostics</refentrytitle>
           <manvolnum>1tcl</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>Diagnostics</refname>
           <refpurpose>Provide error warning and message dialogs</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
            <command>
package require Diagnostics
            </command>
          </cmdsynopsis>
            <cmdsynopsis>
                <command>
::Diagnostics::Dialog <replaceable>title message icon exit-option</replaceable>
                </command>
            </cmdsynopsis>

            <cmdsynopsis>
                <command>
::Diagnostics::Error <replaceable>error-message</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
::Diagnostics::Info <replaceable>info-message</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
::Diagnostics::Warning <replaceable>warning-msg</replaceable>
                </command>
            </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            This package provides some simple mechanisms for reporting
            errors, warnings and information to users.  The main proc
            is <function>::Diagnostics::Dialog</function>.  It is written to
            operate in either Tk or Tcl only environments.
           </para>
           <para>
            In
            Tcl mode the error <parameter>message</parameter> is output to <literal>stderr</literal> and,
            if the <parameter>exit-option</parameter> is true, theuser given
            a yes no prompt to exit the program.  If the user chooses yes, the
            program exits otherwise the function returns.
           </para>
           <para>
            In Tk mode, a 
            <ulink url='http://www.tcl.tk/man/tcl8.5/TkCmd/dialog.htm'>tk_dialog</ulink>
            is used to output the error message.
            The <parameter>title</parameter> parameter is used as the dialog title
            (displayed in the to level's title bar).
            The <parameter>message</parameter> text is displayed in the dialog body.
            <parameter>icon</parameter> identifies a bitmap that will be displayed
            to the left of the message.  This is normally one of
            <literal>errro</literal>, <literal>info</literal> or <literal>warning</literal>,
            although any Tk bitmap object can be used.l
           </para>
           <para>
            In Tk mode, regardless, the dialog contains a <guibutton>Continue</guibutton>
            button which returns control to the application.  If
            <parameter>exit-option</parameter> is boolean true, an additional
            <guibutton>Exit</guibutton> button is displayed and the application
            exits if that was clicked.
           </para>
            <para>
                The remainder of the procs defined by this package are simply
                convenience commands that build pre-defined dialog types:
            </para>
            <variablelist>
                <varlistentry>
                    <term><function>::Diagnostics::Error</function> <parameter>message</parameter></term>
                    <listitem>
                        <para>
                            This is equivalent to
                            <programlisting>::Diagnostics::Dialog Error $message error 1</programlisting>
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><function>::Diagnostics::Info</function> <parameter>message</parameter></term>
                    <listitem>
                        <para>
                            Equivalent to
                            <programlisting>::Diagnostics::Dialog Information $message info 0</programlisting>
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><function>::Diagnostics::Warning</function> <parameter>message</parameter></term>
                    <listitem>
                        <para>
                            Equivalent to:
                            <programlisting>::Diagnostics::Dialog Warning $message warning 1</programlisting>
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </refsect1>
                
      </refentry>
      
      <refentry id="rdogui3_expfilesystemconfig">
        <refmeta>
           <refentrytitle id='rdogui3_expfilesystemconfig_title'>ExpFileSystemConfig</refentrytitle>
           <manvolnum>3rdogui</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>ExpFileSystemConfig</refname>
           <refpurpose>Configuration cluster for event directory tree</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
          <command>
package require ExpFileSystemConfig            
          </command>
          </cmdsynopsis>
            <cmdsynopsis>
                <command>
::ExpFileSystemConfig::setDefaults
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
::ExpFileSystemConfig::environmentOverrides
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
::ExpFileSystemConfig::getStageArea
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
::ExpFileSystemConfig::getExperimentDirectory
                </command>
            </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            This cluster of configuration options is built on top of the
            <link linkend='rdogui3_configuration'
                  endterm='rdogui3_configuration_title' /> package.
             Commands have been defined to initialize the variables supplied
             by this system to default values and to process environment
             variable overrides to those defaults.  In addition to the normal
             <command>get</command> and <command>Set</command> methods supplied
             by the <literal>Configuration</literal> package, this package
             also provides convenience commands to fetch specific
             configuration options.
           </para>
        </refsect1>
        <refsect1>
           <title>
              COMMANDS
           </title>
           <variablelist>
                <varlistentry>
                    <term><command>::ExpFileSystemConfig::setDefaults</command></term>
                    <listitem>
                        <para>
                            Set the configuration variables to their default values.
                            Note that this is done by the readout GUI automatically.
                            Only call this if you want to reinitialize these configuration
                            values.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>::ExpFileSystemConfig::environmentOverrides</command></term>
                    <listitem>
                        <para>
                            Applies environment variables to the configuration
                            values.  See ENVIRONMENT below for information about
                            the environment variables that drive this command.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>::ExpFileSystemConfig::getStageArea</command></term>
                    <listitem>
                        <para>
                            Returns the path  to the top level directory of the
                            directory tree that contains the event data and its metadata.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>::ExpFileSystemConfig::getExperimentDirectory</command></term>
                    <listitem>
                        <para>
                            Returns the path to the top level of the directory tree
                            that contains the event metadata (run directories).
                        </para>
                    </listitem>
                </varlistentry>
                
           </variablelist>
        </refsect1>
        <refsect1>
            <title>DEFAULTS</title>
            <para>
                The defaults are as follows:
                <variablelist>
                    <varlistentry>
                        <term><varname>StageArea</varname></term>
                        <listitem>
                            <para>
                                The stage area default is set to
                                <filename>~/stagearea</filename> this is
                                usually a symbolic link to the real stage area.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><varname>Experiment</varname></term>
                        <listitem>
                            <para>
                                The experiment meta data directory defaults to
                                <filename>~/experiment</filename> this is normally
                                a symbolic link to
                                <filename>~/stagearea/experiment</filename>.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </para>
        </refsect1>
        <refsect1>
            <title>ENVIRONMENT</title>
            <para>
                The following environment variables override default values
                for the configuration variables:
            </para>
            <variablelist>
                <varlistentry>
                    <term><literal>EVENTS</literal></term>
                    <listitem>
                        <para>
                            The value of this environment variable overrides
                            the Stage area default
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>EXPDIR</literal></term>
                    <listitem>
                        <para>
                            The value of this environment variable overrides
                            the Experiment metadata default value.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </refsect1>

      </refentry>

      <refentry id="rdogui3_readoutgui">
        <refmeta>
           <refentrytitle id='rdogui3_readoutgui_title'>ReadoutGui</refentrytitle>
           <manvolnum>3rdogui</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>ReadoutGui</refname>
           <refpurpose>ReadoutGui elements.</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
              <command>
package require ReadoutGui
          </command>
          </cmdsynopsis>
            <cmdsynopsis>
            <command>
ProviderList  <replaceable>widget-path ?options?</replaceable>
            </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>provider-list method ?args?</replaceable>
                </command>
            </cmdsynopsis>

            <cmdsynopsis>
                <command>
ProviderListDialog <replaceable>widget-path ?options?</replaceable>
                </command>
            </cmdsynopsis>
             <cmdsynopsis>
                 <command>
<replaceable>pld method ?args?</replaceable>
                 </command>
             </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>ProviderSelectDialog widget-path ?args?</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>psd method ?args?</replaceable>
                </command>
            </cmdsynopsis>

            <cmdsynopsis>
                <command>
ReadoutGuiApp <replaceable>%AUTO% | app-name</replaceable>
                </command>
            </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            the ReadoutGUI package provides a set of dialog widgets for
            interrogating/selecting the running data sources as well
            as an 'overall application' class that, when instantiated
            creates the entire ReadoutShell's GUI and threads together all of
            the components that make up the system.
           </para>
           <para>
            Normally,  you only need the <classname>ReadoutGuiApp</classname>
            and then only if you need a  highly customized start up.
            The other widgets are documente for the sake of completeness.
           </para>
        </refsect1>
        <refsect1>
           <title>
              MEGAWIDGETSS
           </title>
           <para>
            Subsections of this section provide reference material for the
            megawidgets that are provided by this package:
           </para>
           <variablelist>
            <varlistentry>
                <term><classname>ProviderList</classname></term>
                <listitem>
                    <para>
                        A megawidget that displays the data sources in a
                        scrollable list.  The list displays the source id,
                        the provider name and the parameterization of that instance
                        of the data source.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><classname>ProviderListDialog</classname></term>
                <listitem>
                    <para>
                        Encapsulate the <classname>ProviderList</classname>
                        in a dialog for display purposes only.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><classname>ProviderSelectDialog</classname></term>
                <listitem>
                    <para>
                        Encapsulates <classname>ProviderList</classname>
                        in a dialog that also permits selection of a data
                        source from the list.
                    </para>
                </listitem>
            </varlistentry>
            
           </variablelist>
           <refsect2>
            <title>ProviderList</title>
            <para>
                This megawidget provides a four column scrolling table that
                lists data sources and their descriptions.  The columns provided
                are:
            </para>
            <orderedlist>
                <listitem>
                    <para>
                        The id of the source.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        The provider name (source type).
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Parameter names for each parameter in the source
                        parameterization.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Parametr values for each parameter in the source
                        parameterization.
                    </para>
                </listitem>
            </orderedlist>
            <para>
                Since each source can have several parameters in its parameterization,
                a data source will show up as several lines in the table.
                The first line is just the source id and source type while
                subsequent lines give parameter name/value pairs.
            </para>
            <refsect3>
                <title>
                    OPTIONS
                </title>
                <variablelist>
                    <varlistentry>
                        <term><option>-sources</option> <replaceable>list-of-source-dicts</replaceable></term>
                        <listitem>
                            <para>
                                The data in this option determines what the
                                widget displays.  See
                                the <methodname>sources</methodname> method
                                of
                                <link linkend='rdogui3_DataSourceManager'
                                      endterm='rdogui3_DataSourceManager_title' />
                                for the form of this data.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </refsect3>
            <refsect3>
                <title>METHOD</title>
                <variablelist>
                    <varlistentry>
                        <term><methodname>getSelected</methodname></term>
                        <listitem>
                            <para>
                                The widget allows for single items to be selected.
                                This method returns the source Id of the
                                selected data source.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </refsect3>
           </refsect2>
           <refsect2>
            <title>ProviderListDialog</title>
            <para>
                This megawidget wraps a <classname>ProviderList</classname>
                in a dialog that is suited for inspecting the list of data
                sources.  The dialog has an <guibutton>Ok</guibutton> button
                which dismisses the dialog.  No access is provided to the
                selected item.  
            </para>
            <para>
                If you want to allow the user to select a data source for you
                to operate on in your code, see the <classname>ProviderSelectDialog</classname>
                below.
            </para>
            <refsect3>
                <title>OPTIONS</title>
                <para>
                    The <option>-sources</option> list from the <classname>ProviderList</classname>
                    widget is exposed and has the same meaning.
                </para>
            </refsect3>
            <refsect3>
                <title>METHODS</title>
                <para>
                    All methods from the <classname>DialogWrapper</classname>
                    megawidget described in
                    <link linkend='rdogui3_ui' endterm='rdogui3_ui_title' />
                    are supported.  Use the <methodname>modal</methodname> method
                    to block until the dialog is either destroyed by the user
                    or you need to destroy it due to an <guibutton>Ok</guibutton>
                    click.
                </para>
            </refsect3>
           </refsect2>
           <refsect2>
            <title>ProviderSelectDialog</title>
            <para>
                This dialog wraps a <classname>ProviderList</classname>
                widget in a dialog that provides an <guibutton>Ok</guibutton>
                and a <guibutton>Cancel</guibutton> button.  Access to the
                selected data source is provided to allow you to retrieve
                and operate on the selected data source in the event the
                user clicks the <guibutton>Ok</guibutton> button.
            </para>
            <refsect3>
                <title>OPTIONS</title>
                <para>The <option>-sources</option> option from the wrapped
                    <classname>ProviderList</classname> widget is exposed
                    and has the same meaning as for that widget.
                </para>
            </refsect3>
            <refsect3>
                <title>METHODS</title>
                <para>
                    All methods of the <classname>DialogWrapper</classname>
                    megawidget described in
                    <link linkend='rdogui3_ui' endterm='rdogui3_ui_title' />
                    are supported.  Use the <methodname>modal</methodname> method
                    to block until the user clicks <guibutton>Ok</guibutton> or
                    <guibutton>Cancel</guibutton> or simply destroys the
                    widget.
                </para>
                <para>
                    The <methodname>getSelected</methodname> method of the
                    <classname>ProviderList</classname>
                    is also exposed.  Normally if the <methodname>modal</methodname>
                    method returns <literal>Ok</literal> your application would
                    use <methodname>getSelected</methodname> to determine
                    which data source was selected prior to destroying the
                    dialog widget.
                </para>
            </refsect3>
           </refsect2>
        </refsect1>
        <refsect1>
            <title>APPLICATION CLASSS</title>
            <para>
                The application class <classname>ReadoutGuiApp</classname> is
                not a widget, however it does instantiate the entire widget
                tree that makes up the ReadoutShell application and
                ensures that it has the appropriate default behavior.
            </para>
            <para>
                <filename>ReadoutShell</filename> is simply a script that
                creates an instance of <classname>ReadoutGuiApp</classname>
            </para>  
        </refsect1>
      </refentry>

      <refentry id="rdogui3_readoutguipanel">
        <refmeta>
           <refentrytitle id='rdogui3_readoutguipanel_title'>ReadoutGUIPanel</refentrytitle>
           <manvolnum>3rdogui</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>ReadoutGUIPanel</refname>
           <refpurpose>ReadoutGUI Convenience commands</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
            <command>
package require ReadoutGUIPanel                
          </command>
          </cmdsynopsis>
            <cmdsynopsis>
                <command>
::ReadoutGUIPanel::addUserMenu <replaceable>ident label</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
::ReadoutGUIPanel::getRunIdInstance
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
::ReadoutGUIPanel::ghostWidgets
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
::ReadoutGUIPanel::unghostWidgets
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
::ReadoutGUIPanel::getTitle
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
::ReadoutGUIPanel::setTitle <replaceable>title-string</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
::ReadoutGUIPanel::getRun
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
::ReadoutGUIPanel::setRun <replaceable>run-number</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
::ReadoutGUIPanel::incrRun
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
::ReadoutGUIPanel::recordOff
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
::ReadoutGUIPanel::recordOn
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
::ReadoutGUIPanel::recordData
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
::ReadoutGUIPanel::getRunTime
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
::ReadoutGUIPanel::isTimed
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
::ReadoutGUIPanel::setTimed <replaceable>state</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
::ReadoutGUIPanel::getRequestedRunTime
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
::ReadoutGUIPanel::setRequestedRunTime
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
::ReadoutGUIPanel::isRecording
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
::ReadoutGUIPanel::notRecording
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
::ReadoutGUIPanel::normalColors
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
::ReadoutGUIPanel::outputText
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
::ReadoutGUIPanel::log <replaceable>source class message</replaceable>
                </command>
            </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            <literal>ReadoutGUIPanel</literal> is a collection of simple
            commands that provide access to the readout GUI and its components.
            The commands all live in the <literal>::ReadoutGUIPanel</literal>
            namespace.  In many cases they provide compatibility with
            functions that were provided by the NSCLDAQ-10.x and earlier
            ReadoutShell.  There are no plans, however to deprecate/remove
            these functions unless their functionality becomes obsolete
            in future (NSCLDAQ-12.0 or later) versions of NSCLDAQ's
            readout shell.
           </para>
        </refsect1>
        <refsect1>
           <title>
              COMMANDS
           </title>
           <variablelist>
                <varlistentry>
                    <term><command>::ReadoutGUIPanel::addUserMenu</command> <replaceable>ident label</replaceable></term>
                    <listitem>
                        <para>
                            Adds a new menu to the menubar of the ReadoutGUI.
                            The <parameter>ident</parameter> is required
                            but ignored (it was used in NSCLDAQ-10.x and earlier).
                            <parameter>label</parameter> is the label for the
                            menu in the menu bar.
                        </para>
                        <para>
                            The command returns the widget that is the menu.
                            This allows you to populate the menu for example:
                        </para>
                        <informalexample>
                            <programlisting>
set mymenu [::ReadoutGUIPanel::addUserMenu ignored Special]
$mymenu add command -label "a command" -command handleACommand
...
                            </programlisting>
                        </informalexample>
                        <para>
                            Adds a menu labeled <literal>Special</literal>
                            to the menu bar and puts a command entry labelled
                            <literal>a command</literal> on it that invokes
                            the command <command>handleACommand</command>
                            when clicked.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>::ReadoutGUIPanel::getRunIdInstance</command></term>
                    <listitem>
                        <para>
                            The Readout GUI is composed of several megawidgets.
                            These are established as singleton objects.
                            The <classname>RunIdentification</classname>
                            megawidget (see
                            <link linkend='rdogui3_ui' endterm='rdogui3_ui_title' />)
                            provides a cluster of widgets that identify the run
                            in progress or run about to start.  This command
                            returns the widget id of the run identification
                            singleton object.
                        </para>
                        <para>
                            Note that several commands below offer access to the
                            most common pieces of this widget, so you may not
                            ever actually need to use this command.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>::ReadoutGUIPanel::ghostWidgets</command></term>
                    <listitem>
                        <para>
                            Some widgets in the ReadoutGUI must be disabled while
                            the run is not in the halted state.  This
                            command disables those widgets.  See also
                            <command>::ReadoutGUIPanel::unghostWidgets</command>
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>::ReadoutGUIPanel::unghostWidgets</command></term>
                    <listitem>
                        <para>
                            Enable the widgets that must be disabled when the
                            run is not in the halted state. See also
                            <command>::ReadoutGUIPanel::ghostWidgets</command>
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>::ReadoutGUIPanel::getTitle</command></term>
                    <listitem>
                        <para>
                            Returns the title from the title section of the
                            run identification megawidget.  If the run is active
                            or paused,
                            this will be the title of the current run.  Otherwise,
                            this will be the title of the next run, assuming the
                            user does not change it. 
                        </para>
                        <para>
                            It is recommended that applications access this when
                            the run is active or about to be.  This can be done
                            by using the appropriate <filename>ReadoutCallouts.tcl</filename>
                            proc or by creating a Run state machine callback bundle
                            and using the appropriate state transition to
                            capture the title.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>::ReadoutGUIPanel::setTitle</command> <replaceable>new-title</replaceable></term>
                    <listitem>
                        <para>
                            Makes <parameter>new-title</parameter> the new title
                            string in the Run identification megawidget.
                            Note that this should only be done when the run
                            is not in one of the active states (<literal>Active</literal>
                            or <literal>Paused</literal>).  This sets the title
                            that will be associated with the next run.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>::ReadoutGUIPanel::getRun</command></term>
                    <listitem>
                        <para>
                            Returns the value of the run number in the run
                            identification megawidget.  If the run is active
                            (state in <literal>Active</literal> or <literal>Paused</literal>),
                            this will be the current run number.  If not, this
                            will be the run number of the next run started, unless
                            the user modifies it.
                        </para>
                        <para>
                            It is recommended that applications access this when
                            the run is active or about to be.  This can be done
                            by using the appropriate <filename>ReadoutCallouts.tcl</filename>
                            proc or by creating a Run state machine callback bundle
                            and using the appropriate state transition to
                            capture the title.
                        </para>                        
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>::ReadoutGUIPanel::setRun</command> <replaceable>new-run</replaceable></term>
                    <listitem>
                        <para>
                            Sets the run number in the run identification
                            megawidget to be <parameter>new-run</parameter>.
                            <parameter>new-run</parameter> must be a positive
                            integer.    This should only be modified when the
                            run is not active (in neither the
                            <literal>Active</literal> nor <literal>Paused</literal>
                            states).
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>::ReadoutGUIPanel::incrRun</command></term>
                    <listitem>
                        <para>
                            Adds one to the run number in the run identification
                            megawidget. This should only be done when the
                            run is not active (in neither the
                            <literal>Active</literal> nor <literal>Paused</literal>
                            states).
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>::ReadoutGUIPanel::recordOff</command></term>
                    <listitem>
                        <para>
                            Turns off the record checkbutton in the run control
                            megawidget.  This determines whether or not the
                            next run will be recorded to disk.  Note that
                            this does not change the rendition of the
                            output area of the widget. See
                            <command>::ReadoutGUIPanel::isRecording</command>,
                            <command>::ReadoutGUIPanel::notRecording</command>
                            and <command>::ReadoutGUIPanel::normalColors</command>
                            to modify display renditions.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>::ReadoutGUIPanel::recordOn</command></term>
                    <listitem>
                        <para>
                            Turns on the record checkbutton in the run control
                            megawidget. 
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>::ReadoutGUIPanel::recordData</command></term>
                    <listitem>
                        <para>
                            Returns the state of the record checkbutton in the
                            run control megawidget.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>::ReadoutGUIPanel::getRunTime</command></term>
                    <listitem>
                        <para>
                            Returns the number of seconds the current run has
                            been active (a paused run is not active for this
                            computation).  If the run is not active this returns
                            <literal>0</literal> if the ReadoutGUI has not yet
                            started a run or the length of the previous run if
                            it has.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>::ReadoutGUIPanel::isTimed</command></term>
                    <listitem>
                        <para>
                            Returns boolean <literal>true</literal> if the timed
                            run button is on and <literal>false</literal> if not.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>::ReadoutGUIPanel::setTimed</command> <replaceable>state</replaceable></term>
                    <listitem>
                        <para>
                            Checks or unchecks the timed run checkbutton according
                            to <parameter>state</parameter>.  If checked at the
                            start of the run, the run has a timed duration
                            (unless manually halted).  See
                            <command>::ReadoutGUIPanel::getRequestedRunTime</command>
                            and <command>::ReadoutGUIPanel::setRequestedRunTime</command>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>::ReadoutGUIPanel::getRequestedRunTime</command> </term>
                    <listitem>
                        <para>
                            Returns the number of seconds in the requested run
                            time.  This is only meaningful if the timed run
                            checkbox is checked.   The requested run time is the
                            active time (time paused does not count).
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>::ReadoutGUIPanel::setRequestedRunTime</command> <replaceable>time-in-seconds</replaceable></term>
                    <listitem>
                        <para>
                            Sets the number of seconds in the requested run time
                            to <parameter>time-in-seconds</parameter>.  If the
                            timed run checkbutton is checked, then the next run
                            will be a time duration run that will automatically
                            stop after <parameter>time-in-seconds</parameter> of
                            active time elapse.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>::ReadoutGUIPanel::isRecording</command></term>
                    <listitem>
                        <para>
                            Sets the rendition of the text widget to be consistent
                            with the run being recorded.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>::ReadoutGUIPanel::notRecording</command></term>
                    <listitem>
                        <para>
                            Sets the rendition of the text widget to be consistent
                            with the run being not recorded.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>::ReadoutGUIPanel::normalColors</command></term>
                    <listitem>
                        <para>
                            A synonym for <command>::ReadoutGUIPanel::notRecording</command>
                        </para>
                        </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>::ReadoutGUIPanel::outputText</command> <replaceable>message</replaceable></term>
                    <listitem>
                        <para>
                            Outputs <parameter>message</parameter> to the output
                            text widget.  The message is output without interpretation
                            or filtering using the default rendition.
                            See also <command>::ReadoutGUIPanel::Log</command>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>::ReadoutGUIPanel::Log</command> <replaceable>source class message</replaceable></term>
                    <listitem>
                        <para>
                            Formats a log message to be output on the text widget.
                            <parameter>source</parameter> identifies the subsystem
                            the message is coming from.
                            <parameter>class</parameter> is the class of message
                            being output.  See the documentation of the
                            <classname>OutputWindow</classname> in
                            <link linkend='rdogui3_ui' endterm='rdogui3_ui_title' />
                            for more information about what the <parameter>class</parameter>
                            is and how it influences the output. 
                        </para>
                        <para>
                            For now just know that unless reconfigured,
                            <parameter>class</parameter> represents a message
                            severity that can be one of:
                            <literal>output</literal>, <literal>log</literal>,
                            <literal>error</literal>, <literal>warning</literal>
                            or <literal>debug</literal> and note that
                            <literal>debug</literal> messages are, by default, not
                            displayed.
                        </para>
                        <para>
                            <parameter>message</parameter> is the body of the
                            message to be logged.  The message is timestamped
                            and potentially output to the text terminal along
                            with the severity and data source. For example,
                            when starting data source, the following log
                            message will appear (with an appropriate timestamp).
                        </para>
                        <informalexample>
                            <screen>
                            <computeroutput>
01/08/2014 08:50:08 : log : Run State changed : NotReady -> Starting
                            </computeroutput>
                            </screen>
                        </informalexample>
                        <para>
                            In this case <literal>log</literal> is the class,
                            <literal>Run State changed</literal> is the source
                            and <literal>NotReady -> Starting</literal> the
                            message.
                        </para>
                    </listitem>
                </varlistentry>               
           </variablelist>
        </refsect1>

      </refentry>
      <refentry id="rdogui3_runstatemachine">
        <refmeta>
           <refentrytitle id='rdogui3_runstatemachine_title'>RunStateMachine</refentrytitle>
           <manvolnum>3rdogui</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>RunStateMachine</refname>
           <refpurpose>Run control state machine</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
            <command>
package require RunStateMachine
          </command>
          </cmdsynopsis>
            <cmdsynopsis>
                <command>
set <replaceable>sm</replaceable> [RunstateMachineSingleton %AUTO%]
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>$sm method</replaceable>
                </command>
            </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            Provides the run control state machine singleton.  Constructing
            a <classname>RunstateMachineSingleton</classname> encapsulates
            a single instance of a <classname>RunStateMachine</classname> so
            that all clients are assured of interacting with the same
            state machine object.
           </para>
           <para>
            The state machine object has a well defined set of states and
            allowed transitions between those states.  See STATES below
            for the set of allowed states and transitions.
           </para>
           <para>
            By itself the state machine is not worth very much.  The value comes
            from the ability to register <firstterm>Callout bundles</firstterm>
            with the state machine.  See the CALLOUT BUNDLES for more about
            what a callback bundle is and how to create one.
           </para>
        </refsect1>
        <refsect1>
           <title>
              METHODS and TYPEMETHODS
           </title>
           <para>
            The <classname>RunstateMachineSingleton</classname> object wraps
            a single application wide <classname>RunstateMachine</classname> and
            exposes all of its methods to its client.  The methods described here
            are therefore actually <classname>RunstateMachine</classname> methods.
           </para>
           <para>
            The methods below designated as TYPEMETHODS do not require an object
            to invoke.
           </para>
           <variablelist>
            <varlistentry>
                <term><methodname>::RunstateMachine::listStates</methodname></term>
                <listitem>
                    <para>
                        This typemethod returns a Tcl list whose elements
                        are the legal states the
                        machine can be in.  These are described in the
                        STATES section below.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><methodname>::RunstateMachine::listTransitions</methodname>
                    <parameter>state</parameter></term>
                <listitem>
                    <para>
                        This typemethod accepts  the name of a
                        <parameter>state</parameter> returned from
                        <methodname>::RunstateMachine::listState</methodname>
                        and returns a list consisting of the names of the
                        valid state that can be reached from that
                        <parameter>state</parameter>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><methodname>getState</methodname></term>
                <listitem>
                    <para>
                        Return the current state of the state machine.
                        This will be a state in the list returned by
                        <methodname>::RunstateMachine::listStates</methodname>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><methodname>listCalloutBundles</methodname></term>
                <listitem>
                    <para>
                        Returns a list consisting of the names of the currently
                        registererd callout bundles.  See
                        CALLOUT BUNDLES below for more information about
                        callout bundles.   The list is provided in registration
                        order which also correspondes to the callout order.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><methodname>addCalloutBundle</methodname> <parameter>bundle-name</parameter></term>
                <listitem>
                    <para>
                        Registers a new callout bundle with the state machine.
                        See CALLOUT BUNDLES below for information about
                        what a callout bundle is. The <parameter>bundle-name</parameter>
                        is considerd to be the name of a namespace relative
                        to the global namespace (e.g MyBundle is considered to
                        be the namespace ::MyBundle).  
                    </para>
                    <para>
                        The namespace
                        is checked for the existence and proper parameterization of
                        the required callback bundle procs as described in
                        CALLOUT BUNDLES.  An error is thrown if the namespace
                        is determined to not be a valid callout bundle.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><methodname>removeCalloutBundle</methodname> <parameter>bundle-name</parameter></term>
                <listitem>
                    <para>
                        Removes the named callout bundle from the list of
                        registered bundles.  It is an error if <parameter>bundle-name</parameter>
                        does not correspond to a registered callout bundle.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><methodname>transition</methodname> <parameter>new-state</parameter></term>
                <listitem>
                    <para>
                        Attempts a transition from the current state
                        to <parameter>new-state</parameter>.  The
                        <command>leave</command> and <command>enter</command>
                        procs for the registered callback bundles are invoked.
                    </para>
                    <para>
                        <command>leave</command> is invoked prior to making the
                        transition while <command>enter</command> is invoked
                        after the transition has occurerd.
                    </para>
                    <para>
                        If <parameter>new-state</parameter> is not an allowed
                        state transition, an error is thrown.
                    </para>
                </listitem>
            </varlistentry>
            
           </variablelist>
        </refsect1>
        <refsect1>
            <title>
                STATES
            </title>
            <para>
                The <classname>RunstateMachine</classname> has a well defined
                set of state and allowed transtion between those states.
                The finite state automaton that is defined by these states and
                their allowed transitions is shown in simplified form in
                <link linkend='rdogui_statediagram' endterm='rdogui_statediagram_title' />
            </para>
            <para>
                These states and their allowed transitions are described textually
                below.
            </para>
            <variablelist>
                <varlistentry>
                    <term><literal>NotReady</literal></term>
                    <listitem>
                        <para>
                            The system is not ready for use.  In this state,
                            data sources have not yet been started.   You must
                            also be in this state to modify the set of data
                            sources known to the application.
                        </para>
                        <para>
                            Allowed target states for the <methodname>transition</methodname>
                            method are; <literal>NotReady</literal> and
                            <literal>Starting</literal>.  <literal>Starting</literal>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>Starting</literal></term>
                    <listitem>
                        <para>
                            This state is entered to start the data sources
                            that have been defined for use with the application.
                            <literal>NotReady</literal> is an allowed target state
                            and is normally entered if one or more data sources
                            failed to tart up.  <literal>Halted</literal> is the
                            other valid target state and is
                            entered if all data sources started correctly.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>Halted</literal></term>
                    <listitem>
                        <para>
                            This state indicates the system is ready for
                            use but there is no current data taking run.
                            Valid transition targets are;
                            <literal>NotReady</literal>, if a data source fails
                            or <literal>Active</literal> if a run is successfully
                            started.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>Active</literal></term>
                    <listitem>
                        <para>
                            This state indicates data taking is ongoing.
                            Valid transitions are:
                            <literal>Paused</literal> if the run is paused,
                            <literal>Halted</literal> if the run is ended and
                            <literal>NotReady</literal> if a data source fails.
                        </para>
                        <para>
                            Note that while not all data source providers support
                            a <literal>Paused</literal> state this is not known
                            or supported directly by the run state machine.
                            Instead, the ReadoutGUI interrogates the data
                            sources defined and removes the GUI elements that
                            can trigger a transition to the <literal>Paused</literal>
                            state if not all data sources support paused runs.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>Paused</literal></term>
                    <listitem>
                        <para>
                            Indicates a data taking run is temporarily paused.
                            This state can transition to:
                            <literal>Halted</literal> if the run is stopped,
                            <literal>Active</literal> if the run is resumed or
                            <literal>NotReady</literal> if a data source fails.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
            <note>
                <title>NOTE</title>
                <para>
                    In the transition diagram above, the text <literal>if a data source fails</literal>
                    means a data source provider's <command>check</command> for
                    that data source returns boolean <literal>false</literal>.
                    Thus failure is defined by and limited to the ability of the data source
                    provider to detect the failure.
                </para>
            </note>
        </refsect1>
        <refsect1>
            <title>CALLOUT BUNDLES</title>
            <para>
                The true value of the run state machine is the ability of
                components of the ReadoutGUI (including your extensions) to
                register <firstterm>Callout Bundles</firstterm>.  You can think
                of a callout bundle as a generalization of the ReadoutShell's
                <filename>ReadoutCallouts.tcl</filename> mechanism.
            </para>
            <para>
                A Callout bundle is a Tcl namespace.  The namespace must
                contain three exported<command>proc</command> definitions:
            </para>
            <variablelist>
                <varlistentry>
                    <term><command>attach</command> <parameter>current-state</parameter></term>
                    <listitem>
                        <para>
                            This proc is called when the bundle is registered
                            with the state machine via
                            <methodname>addCalloutBundle</methodname>
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>leave</command> <parameter>from-state to-state</parameter></term>
                    <listitem>
                        <para>
                            This proc is called just before the state machine makes
                            a transition from <parameter>from-state</parameter> to
                            <parameter>to-state</parameter>
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>enter</command> <parameter>from-state to-state</parameter></term>
                    <listitem>
                        <para>
                            This proc is called just after the state machine has
                            made a transition from <parameter>from-state</parameter>
                            to <parameter>to-state</parameter>.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
            <para>
                The <command>enter</command> and <command>leave</command> procs
                for the callout bundles are invoked in the order in which the
                bundles were registered.
            </para>
        </refsect1>
        <refsect1>
            <title>EXAMPLES</title>
            <para>
                The sample code below shows the creation and registration of
                a callout bundle that does nothing.  You can rename the namespace
                and fill in the procs shown below to build and register your own
                callout bundles.
            </para>
            <example>
                <title>A do nothing <classname>RunstateMachine</classname> callout bundle</title>
                <programlisting>
                    
package require RunstateMachine                         <co id='callout_bundle_require' />
                    
namespace eval ::MyBundle  {
    variable  sm
    namespace export attach enter leave                 <co id='callout_bundle_namespace' />
}

proc ::MyBundle::attach currentState {
                                                       <co id='callout_bundle_attach' />
}

proc ::MyBundle::leave {from to} {
                                                      <co id='callout_bundle_leave' />
}

proc ::MyBundle::enter {from to} {
                                                       <co id='callout_bundle_enter' />
}

set ::MyBundle::sm [RunstateMachineSingleton %AUTO]   <co id='callout_bundle_smget' />
$::MyBundle::sm    addCalloutBundle MyBundle          <co id='callout_bundle_register' />
                </programlisting>
            </example>
            <calloutlist>
                <callout arearefs='callout_bundle_require'>
                    <para>
                        Requires the run state machine package.  This is needed
                        to get access to the state machine and then to register
                        the bundle we're creating.
                    </para>
                </callout>
                <callout arearefs='callout_bundle_namespace'>
                    <para>
                        This code creates the namespace <literal>::MyBundle</literal>
                        it defines a variable <varname>sm</varname> to live in that
                        namespace (to hold the state machine object command) and
                        exports the required proc names from the namespace.
                    </para>
                </callout>
                <callout arearefs='callout_bundle_attach'>
                    <para>
                        Defines the <command>enter</command> proc of the
                        bundle. This will be called when the bundle is registered
                        with the state machine. When called, <parameter>currentState</parameter>
                        will be the state at the time the attach was done.
                    </para>
                </callout>
                <callout arearefs='callout_bundle_leave'>
                    <para>
                        Defines the <command>leave</command> proc of the bundle.
                        This will be called just before the state machine
                        begins a transition.  <parameter>from</parameter> will
                        be the state at the time the transition is being started
                        and <parameter>to</parameter> will be the target state.
                    </para>
                </callout>
                <callout arearefs='callout_bundle_enter'>
                    <para>
                        Defines the <command>enter</command> proc of the bundle.
                        This is called after the state machine completes its state
                        transition. <parameter>from</parameter> is the old state
                        and <parameter>to</parameter> is the new state.
                    </para>
                </callout>
                <callout arearefs='callout_bundle_smget'>
                    <para>
                        Obtains the run state machine singleton and assigns
                        it to the variable <varname>::MyBundle::sm</varname>.
                        This allows it to be used from within the bundle procs
                        as well as for bundle registration purposes.
                    </para>
                </callout>
                <callout arearefs='callout_bundle_register'>
                    <para>
                        Registers the bundle with the state machine.  Prior to
                        returning from this call, <command>::MyBundle::attach</command>
                        will be called.  From now on state transitions will result
                        in calls first to the bundle's <command>::MyBundle::leave</command>
                        and then to the bundle's <command>::MyBundle::enter</command>
                        procs.
                    </para>
                </callout>
            </calloutlist>
        </refsect1>
      </refentry>
      <refentry id="rdogui3_statemanager">
        <refmeta>
           <refentrytitle id='rdogui3_statemanager_title'>StateManager</refentrytitle>
           <manvolnum>3rdogui</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>StateManager</refname>
           <refpurpose>Save restore program state variables.</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
            <command>
package require StateManager
          </command>
          </cmdsynopsis>
            <cmdsynopsis>
                <command>
set <replaceable>state</replaceable> StateManager %AUTO% <replaceable>?options?</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>$state</replaceable> method <replaceable>?parameters?</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
set singleton [StateManagerSinleton %AUTO% <replaceable>?options?</replaceable>]
                </command>
            </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            While packaged with the ReadoutGUI this is actually a general purpose
            utility that provides support for Tcl script to save and restore
            state variables.  A state variable can be pretty much anything that
            might define the state of a program or control how a program operates.
           </para>
           <para>
            State is saved to and restored from Tcl scripts that consist entirely
            of <command>set</command> commands.  These scripts are sourced into
            a safe interpreter in order to ensure they cannot damage or inject
            insecure code into the application itself.
           </para>
           <para>
            Only pre-declared state variables will be saved or restored
            from the file, further securing the application script from malicious
            or erroneous restores.
           </para>
           <para>
            Note that if an application has several independent components
            that wish to share a single configuration file, the
            <classname>StateManagerSingleton</classname> can be used to provide
            access to an application speciric singleton state manager object.
           </para>
        </refsect1>
        <refsect1>
           <title>
              OPTIONS
           </title>
           <para>
            <classname>StateManager</classname> objects include the
            standard <methodname>configure</methodname> and
            <methodname>cget</methodname> methods.  These operate on
            the object option(s) described below.
           </para>
           <variablelist>
            <varlistentry>
                <term><option>-file</option> <parameter>file-path</parameter></term>
                <listitem>
                    <para>
                        Provides the path to the file that will be used by
                        <methodname>save</methodname> and
                        <methodname>restore</methodname> operations.
                    </para>
                    <para>
                        See METHODS below.
                    </para>
                </listitem>
            </varlistentry>
            
           </variablelist>

        </refsect1>
        <refsect1>
            <title>METHODS</title>
            <para>
                In addtion to the <methodname>configure</methodname> and
                <methodname>cget</methodname> methods described in
                OPTIONS above, the following methods are provided by
                <classname>StateManager</classname> objects
            </para>
            <variablelist>
                <varlistentry>
                    <term><methodname>destroy</methodname></term>
                    <listitem>
                        <para>
                            Destroys the object.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><methodname>addStateVariable</methodname> <parameter>name getter setter</parameter></term>
                    <listitem>
                        <para>
                            Defines a state variable that will be saved/restored
                            by the state manager. <parameter>name</parameter> is
                            the name of the variable as it will be defined in
                            the file (e.g. <command> set <replaceable>name value</replaceable></command>).
                        </para>
                        <para>
                            <parameter>getter</parameter> is a command to which <parameter>name</parameter>
                            will be appended that will be used by <methodname>save</methodname>
                            to obtain the variable value.
                            <parameter>setter</parameter> is a command which will be called by
                            <methodname>restore</methodname> to restore the value of <parameter>name.
                            </parameter><parameter>name</parameter>
                            and <parameter>value</parameter> will be appended to
                            the setter command.
                        </para>
                        <para>
                            If this business of getters and setters is not clear
                            see <methodname>save</methodname> and
                            <methodname>restor</methodname> and finally
                            the EXAMPLES section below.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><methodname>listStateVariables</methodname></term>
                    <listitem>
                        <para>
                            Returns a list of the state variables.  The return
                            value is a Tcl list of triplets.  Each triplet conisists
                            of a variable name, its getter and setter in that order.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><methodname>save</methodname></term>
                    <listitem>
                        <para>
                            Saves the variables to <option>-file</option>.
                            If the <option>-file</option> option is blank an
                            error is thrown. 
                        </para>
                        <para>
                            The save operates by iterating over all registered
                            variables and writing a command that is something like
                            <informalexample>
                                <programlisting>
set <replaceable>varname</replaceable> [<replaceable>getter varaname</replaceable>]
                                </programlisting>
                            </informalexample>
                            to the file.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>restore</term>
                    <listitem>
                        <para>
                            Creates a secure slave interpreter and sources
                            <option>-file</option> into that interpreter.
                            For each variable in the list of state variables,
                            if the slave interpreter has a definition for that
                            variable, the setter for that variable is called in
                            code something like this:
                            <informalexample>
                                <programlisting>
$setter $varname $value-in-safe-interp
                                </programlisting>
                            </informalexample>  
                        </para>
                    </listitem>
                </varlistentry>
                
            </variablelist>
        </refsect1>
        <refsect1>
            <title>EXAMPLES</title>
            <para>
                The example below shows how to define two state variables
                <varname>::State::var1</varname> and <varname>::State::var2</varname>
                and their associated getter/setter procs.
            </para>
            <example>
                <title>Getters and setters for StateManager</title>
                <programlisting>
namespace eval ::State {
    variable var1                                  <co id='statemgr_vars' />
    variable var2
}
...
proc ::State::getter name {
    return [set ::State::$name]                    <co id='statemgr_getter' />
}
proc ::State::setter {name  value}
{
    set ::State::$name $value                      <co id='statemgr_setter' />
}

set sm [StateManagerSingleton %AUTO%]
$sm addStateVariable var1 ::State::getter ::State::setter  <co id='statemgr_register' />
$sm addStateVariable var2 ::State::getter ::State::setter

...
$sm configure -file /path/to/configuration/file.tcl  <co id='statemgr_configfile' />
$sm save                                             <co id='statemgr_save' />
...
$sm restore                                          <co id='statemgr_restore' />

                </programlisting>
            </example>
            <calloutlist>
                <callout arearefs='statemgr_vars'>
                    <para> Creates a namespace for the state variables
                        and declares <varname>var1</varname> and
                        <varname>var2</varname> which will be saved and restored.
                    </para>
                </callout>
                <callout arearefs='statemgr_getter'>
                    <para>
                        The getter uses the name passed to it, and the fact
                        that the <command>set</command> command without a value
                        just returns the current value of the variable to
                        return the value of the named variable within the
                        <literal>::State::</literal> namespace.  Tcl rules
                        for substitution prevent the straightforward use of
                        <command>return $::State::$name</command>
                    </para>
                </callout>
                <callout arearefs='statemgr_setter'>
                    <para>
                        The setter similarly uses the name and value to update
                        the named variable in the <literal>::State</literal>
                        namespace.
                    </para>
                </callout>
                <callout arearefs='statemgr_register'>
                    <para>
                        After getting the state manager singleton,
                        <varname>var1</varname> and <varname>var2</varname>
                        are registered with getters and setters defined
                        as described above so that each variable is bound to
                        the corresponding variable in the <literal>::State</literal>
                        namespace.
                    </para>
                    <para>
                        It's worth nothing that more interesting setter and getter
                        functions are possible.  For example, a setter could
                        load a piece of a graphical user interface, and a getter
                        could retrieva a value from an element of a graphical user
                        interface.   The ReadoutShell does this in a few places.
                    </para>
                </callout>
                <callout arearefs='statemgr_configfile'>
                    <para>
                        Before doing saves and restores, the <option>-file</option>
                        must be configured to point at a file (or specify a writable file
                        for save) that is used as the target for the save or source for
                        the restore.  <option>-file</option> can be freely configured
                        many times.  For example your application might prompt the user
                        for a filename into which some configuration information
                        can be written/read.
                    </para>
                </callout>
                <callout arearefs='statemgr_save'>
                    <para>
                        Saves the values of <varname>::State::var1</varname>
                        and <varname>::State::var2</varname> to the last configured
                        <option>-file</option>.  This is done by invoking the
                        getter registered for each of those variables (and any other
                        variables that were added for that matter) in turn passing in
                        <literal>var1</literal> and <literal>var2</literal> to
                        retrieve their values.
                    </para>
                </callout>
                <callout arearefs='statemgr_restore'>
                    <para>
                        <command>source</command>s the last configured <option>-file</option>
                        into a slave safe interpreter and queries that interpreter
                        to see if each registered variable is defined.  For each
                        defined variable, the value is fetched out of the interpreter
                        and that variable's setter is invoked to update whatever
                        in the application is bound to that configuration variable.
                    </para>
                </callout>
            </calloutlist>
        </refsect1>
      </refentry>
      <refentry id="rdogui3_ui">
        <refmeta>
           <refentrytitle id='rdogui3_ui_title'>ui</refentrytitle>
           <manvolnum>3rdogui</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>ui</refname>
           <refpurpose>ReadoutGUI graphical user interface elements.</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
              <command>
package require ui
          </command>
          </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            This package provides all of the graphical user interface elements
            that are part of the standard ReadoutGUI.  It is possible for
            a custom control interface to be written using some, all or none
            of these elements. 
           </para>
           <para>
            This package can also be used to access elements of the ReadoutGUI
            from within extensions to the standard ReadoutShell.
            The package consists of a rather large set of component megawidgets
            and singleton implementations of those megawidgets.  The remainder
            of this section will briefly describe the purpose of each of those megawidgets.
            Subsequent sections will provide more detailed reference information
            about each megawidget.
           </para>
           <variablelist>
            <varlistentry>
                <term><link linkend='rdogui3_ui_readoutMenubar' endterm='rdogui3_ui_readoutMenubar_title' />
                </term>
                <listitem>
                    <para>
                        Provides the menu bar for the application.  This can
                        be used as a genric menu bar handling class for
                        your own applications distinct from the ReadoutShell
                        as well.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><link linkend='rdogui3_ui_RunIdentification'
                    endterm='rdogui3_ui_RunIdentification_title' /></term>
                <listitem>
                    <para>
                        Provides a megawidget that identifies runs.  This contains
                        an entry/display of a title string and an entry for a
                        run number.  The run number entry is constrained to
                        hold positive integers.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <link linkend='rdogui3_ui_RunControl' endterm='rdogui3_ui_RunControl_title' />
                </term>
                <listitem>
                    <para>
                        Provides a megawidget that contains the controls for a run.
                        These are buttons intended to drive the
                        <link linkend='rdogui3_runstatemachine'
                              endterm='rdogui3_runstatemachine_title' />.
                        Buttons that can appear include a <guibutton>Start</guibutton>
                        button, a <guibutton>Begin/End</guibutton> button a
                        <guibutton>Pause/Resume</guibutton> button that can be
                        disabled and a <guibutton>Record</guibutton> checkbutton.
                    </para>
                    <para>
                        The widget is linked to the run state machine
                        singleton so that button presses create the appropriate
                        state transitions.  An associated callout bundle
                        allows the widget to track state machine transitions
                        that it does not initiate.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <link linkend='rdogui3_ui_StopWatch'
                          endterm='rdogui3_ui_StopWatch_title' />
                </term>
                <listitem>
                    <para>
                        This is a non graphical element that implements
                        a simple stopwatch.  The stop watch can be started,
                        stopped and reset. Furthermore,
                        alarms can be added which invoke application specific
                        commands when they are reached.
                    </para>
                    <para>
                        This is used to implement timed runs, and to maintain
                        the elapsed run time, but also can be used in your
                        own application whenever you need this functionality.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <link linkend="rdogui3_ui_ElapsedTimeDisplay"
                          endterm='rdogui3_ui_ElapsedTimeDisplay_title' />
                </term>
                <listitem>
                    <para>
                        Works with an embedded stopwatch object to provide
                        elapsed run display.  The stopwatch is fully exposed
                        allowing application specific code to be invoked
                        when a specific elapsed run time is reached (this is how
                        timed runs work).
                    </para>
                    <para>
                        A callout bundle is provided so that the timer
                        starts, stops and resets at the appropriate times.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <link linkend='rdogui3_ui_TimedRunControls'
                          endterm='rdogui3_ui_TimedRunControls_title' />
                </term>
                <listitem>
                    <para>
                        Provides a GUI element that prompts for timed
                        run information.  This consists of elements that
                        allow users to specify the length of a timed run,
                        as well as a checkbox that allows users to enable/disabled
                        timed runs.
                    </para>
                    <para>
                        An associated callout bundle hooks the singleton
                        instance to the Run state machine and the
                        elapsed run time implementing the semantics of
                        timed runs.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <link linkend='rdogui3_ui_OutputWindow'
                          endterm='rdogui3_ui_OutputWindow_title' />
                </term>
                <listitem>
                    <para>
                        Provides a scrollable text widget and methods to output
                        data into that widget.  The widget also supports
                        formatted log entries that are very configurable.
                        A singleton and associated callout bundle supports
                        logging basic state transitions.
                    </para>
                    <para>
                        An associated
                        <link linkend='rdogui3_outputwindowsettings'
                              endterm='rdogui3_outputwindowsettings_title' />
                        provides a dialog that allows several settings of the
                        output window singleton to be modified.  Note that this
                        is a bit specialized, while the output widow itself is not.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <link linkend='rdogui3_StatusArea'
                          endterm='rdogui3_StatusArea_title' />
                </term>
                <listitem>
                    <para>
                        Provides a support for a vertically stacked set of
                        widgets and convenience functions for these to be
                        simple labels.  These are intended to provide
                        status information about components of the
                        system.
                    </para>
                </listitem>
            </varlistentry>
            
           </variablelist>
        </refsect1>
        <refsect1 id='rdogui3_ui_readoutMenubar'>
            <title id='rdogui3_ui_readoutMenubar_title'>readoutMenuBar</title>
            <para>
                This object manages a menu.  Once created it can be
                turned into a menu bar for a toplevel by using it's path as
                the <option>-menu</option> option of that toplevel. The
                delegation of all unknown options and methods to the underying
                menu makes this indistinguishable from a menu created
                via <command>menu</command>.  Convenience methods have been
                added to make simple things simpler.
            </para>
            <refsect2>
                <title>METHODS</title>
                <variablelist>
                    <varlistentry>
                        <term><methodname>addMenu</methodname> <parameter>label-text</parameter></term>
                        <listitem>
                            <para>
                                Adds a new submenu (cascade objet and associated menu)
                                to the menu.  The menubutton that triggers the
                                submenu will be labeled <parameter>label-text</parameter>.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><methodname>lookupMenu</methodname> <parameter>label-text</parameter></term>
                        <listitem>
                            <para>
                                Returns the menu widget associated with a sub-menu
                                created via <methodname>addMenu</methodname>.
                                <parameter>label-text</parameter> is the label
                                that was passed in to <methodname>addMenu</methodname>
                                when the submenu was created.
                            </para>
                            <para>
                                This relies on an internal data structure
                                that maintains the correspondence between
                                sub-menu labels and their menu widget paths.
                                Therefore this method can only be used to
                                look up submenus created with <methodname>addMenu</methodname>
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><methodname>listMenus</methodname></term>
                        <listitem>
                            <para>
                                Returns the list of menu labels created via
                                <methodname>addMenu</methodname>.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><methodname>addSeparator</methodname> <parameter>label-text</parameter></term>
                        <listitem>
                            <para>
                                Adds a separator to the end of the menu
                                whose label is <parameter>label-text</parameter>.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><methodname>addCommand</methodname>
                            <parameter>menu-label command-label command</parameter></term>
                        <listitem>
                            <para>
                                Adds a command item to the menu identified by
                                <parameter>menu-label</parameter>.  The
                                command item's label will be <parameter>command-label</parameter>.
                                When clicked the <parameter>command</parameter> will
                                be run.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><methodname>addMenuItem</methodname> <parameter>menu-label itemtype args</parameter></term>
                        <listitem>
                            <para>
                                Adds an arbitrary menu item to <parameter>menu-label</parameter>
                                The type of the item is <parameter>itemtype</parameter>.
                                The allowed values for <parameter>itemtype</parameter>
                                are the menu item types defined in
                                <ulink url='http://www.tcl.tk/man/tcl8.5/TkCmd/menu.htm'>
                                    The man page for the <command>menu</command></ulink>
                                command.
                            </para>
                            <para>
                                The <parameter>args</parameter> parameter is pasted
                                on the back end of the <command>menu add</command> command
                                and normally consists of a list of option value pairs
                                (you can use the Tcl <command>list</command> command to build it).
                                The valid options for each menu type are also
                                described in the <ulink url='http://www.tcl.tk/man/tcl8.5/TkCmd/menu.htm'>
                                    The man page for the <command>menu</command></ulink>
                                command.
                            </para>
                        </listitem>
                    </varlistentry>
                    
                </variablelist>
            </refsect2>
        </refsect1>
        <refsect1 id='rdogui3_ui_RunIdentification'>
            <title id='rdogui3_ui_RunIdentification_title'>RunIdentification</title>
            <para>
                This megawidget consists of two entries and associated labels.
                The entries provide mechanisms for users to supply a run number
                and a title string.  The run number entry is validated so that
                it must be a positive integer.
            </para>
            <refsect2>
                <title>OPTIONS</title>
                <para>
                    The megawidget supports the standard
                    <command>configure</command> and <command>cget</command>
                    methods.  These operate on the following set of options:
                </para>
                <variablelist>
                    <varlistentry>
                        <term><option>-haverun</option> <replaceable>boolean-value</replaceable></term>
                        <listitem>
                            <para>
                                If false, the run number label and entry widgets
                                are unmanaged.  This can be done if no data
                                sources support run numbers.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><option>-havetitle</option> <replaceable>boolean-value</replaceable></term>
                        <listitem>
                            <para>
                                If false, the title entry and label are unmanaged.
                                This can be done if no data sources support
                                run titles.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><option>-state</option> <replaceable>normal | disabled | readonly</replaceable></term>
                        <listitem>
                            <para>
                                Specifies the state that will be applied to all
                                entry widgets.  This is normally used to make
                                the entries read-only when the run is
                                <literal>Active</literal> or
                                <literal>Paused</literal>.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><option>-title</option> <replaceable>title-string</replaceable></term>
                        <listitem>
                            <para>
                                Sets/gets the value of the title string.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><option>-run</option> <replaceable>run-number</replaceable></term>
                        <listitem>
                            <para>
                                Sets/gets the value of the run number.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </refsect2>
        </refsect1>
        <refsect1 id='rdogui3_ui_RunControl'>
            <title id='rdogui3_ui_RunControl_title'>RunControl</title>
            <para>
                This is a megawidget that contains the controls needed
                to drive the run state machine through its state transitions.
                See
                <link linkend='rdogui3_runstatemachine'
                      endterm='rdogui3_runstatemachine_title' />
                for information about the run state machine.
            </para>
            <para>
                Associated with this widget is a singleton implementation
                and a callout bundle that hooks the widget into the
                run state machine singleton so that it can maintain a state
                that is consistent with the state of the run even in the face
                of state transitions it does not initiate.
            </para>
            <refsect2>
                <title>OPTIONS</title>
                <para>
                    The megawidget understands the standard
                    <command>configure</command> and
                    <command>cget</command> methods for configuring and
                    querying options.  The set of options understood by
                    the <classname>RunControl</classname> widget are:
                </para>
                <variablelist>
                    <varlistentry>
                        <term><option>-pauseable</option> <replaceable>boolean</replaceable></term>
                        <listitem>
                            <para>
                                Set this to boolean <literal>true</literal> if the system as a whole
                                can support paused runs.  <literal>False</literal> if not.  If
                                the value of this option is  <literal>false</literal>,
                                the <guibutton>Pause</guibutton> button removed
                                from the megawidget making it impossible for the
                                user to initiate a transition to
                                <literal>Paused</literal>.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><option>-recording</option> <replaceable>boolean</replaceable></term>
                        <listitem>
                            <para>
                                If true the recording checkbutton is on indicating
                                the run is either now being recorded (if in
                                one of the active states), or the next run
                                will be recorded if the run is not in an active
                                state.
                            </para>
                            <para>
                                Active states are
                                <literal>Active</literal> and <literal>Paused</literal>.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </refsect2>
            <refsect2>
                <title>SINGLETON IMPLEMENTATION</title>
                <para>
                    In the context of the standard ReadoutShell/ReadoutGUI,
                    the run control megawidget is attached to the run state
                    machine so that it can always reflect the state of the
                    system.   This is done by providing a singleton implementation
                    of the widget and registering a callout bundle with the
                    state machine singleton that manipulates the widget's appearance:
                </para>
                <informalexample>
                    <programlisting>
set <replaceable>rctl</replaceable> ::RunControlSingleton::getInstance <replaceable>?path ?args??</replaceable>
                    </programlisting>
                </informalexample>
                <para>
                    The first time <function>::RunControlSingleton::getInstance</function>
                    is called it must be given a widget <parameter>path</parameter> and
                    optionally addtional configuration parmaeters <parameter>args</parameter>.
                    When initially called, the singleton is created and the callout bundle
                    registered.
                </para>
                <para>
                    All calls return the widget path of the singleton.  Thus,
                    if you know the singleton has already been created the
                    code fragment below will turn on the recording checkbutton:
                </para>
                <informalexample>
                    <programlisting>
[::RunControlSingleton::getInstance] configure -recording 1
                    </programlisting>
                </informalexample>
            </refsect2>
        </refsect1>
        <refsect1 id='rdogui3_ui_StopWatch'>
            <title id='rdogui3_ui_StopWatch_title'>StopWatch</title>
            <para>
                The <classname>StopWatch</classname> class provides a timekeeper
                that can stop, start, be reset and have alarms fire and specific
                elapsed times.  An alarm is a script that is associated
                with an elapsedtime via the <methodname>addAlarm</methodname>
                method.
            </para>
            <para>
                <classname>StopWatch</classname> is not a megawidget, but does
                require applications that normally run in an event loop as it
                uses the
                <ulink url='http://www.tcl.tk/man/tcl8.5/TclCmd/after.htm'><command>after</command></ulink>
                command to schedule clock ticks.  Constructing an object creates
                an object command ensemble which provides access to the object
                methods.  The constructor returns the name of the command.
            </para>
            <para>
                You can either specify the command explicitly:
            </para>
            <informalexample>
                <programlisting>
StopWatch <replaceable>myStopwatch</replaceable>;     # Command named <literal>myStopwatch</literal>
myStopwatch <replaceable>some-method</replaceable>...
                </programlisting>
            </informalexample>
            <para>
                or you can ask the constructor to allocated a unique command
                name using the special object name %AUTO%:
            </para>
            <informalexample>
                <programlisting>
set <replaceable>myStopwatch</replaceable> [StopWatch %AUTO%];
...
$myStopWatch <replaceable>some-method</replaceable> ...
                </programlisting>
            </informalexample>
            <refsect2>
                <title>METHODS</title>
                <para>Stop watch objects have the following methods:</para>
                <variablelist>
                    <varlistentry>
                        <term><methodname>start</methodname></term>
                        <listitem>
                            <para>
                                Starts the stop watch.  When the event loop is
                                active, every .25 seconds, a tick will be declared.
                                The elapsed time is maintained in milliseconds.
                                via that counter.  If the application does not
                                often enter the event loop, clearly the stopwatch
                                will run slow.
                            </para>
                            <para>
                                Note that <methodname>start</methodname> does not
                                clear the timer.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><methodname>stop</methodname></term>
                        <listitem>
                            <para>
                                Stops the stopwatch.  If the stopwatch is already
                                halted, an error is thrown.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><methodname>reset</methodname></term>
                        <listitem>
                            <para>
                                Sets the elapsed time to 0 milliseconds.
                                It is legal to do this while the stopwatch is
                                running.  Note that this does not remove alarm
                                scripts.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><methodname>addAlarm</methodname> <parameter>when script</parameter></term>
                        <listitem>
                            <para>
                                Schedules a <parameter>script</parameter> to be run when the elapsed time
                                is  <parameter>when</parameter> seconds.
                                Note that <parameter>when</parameter>  must be a positive integer.
                                If the elapsed time in integer seconds is already
                                past <parameter>when</parameter>, the script won't run.
                            </para>
                            
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><methodname>removeAlarm</methodname> <parameter>when script</parameter></term>
                        <listitem>
                            <para>
                                Removes the matching script from the set of scheduled scripts.
                                It is an error to remove a script that has not been
                                registered.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><methodname>isRuning</methodname></term>
                        <listitem>
                            <para>
                                Returns true if the stopwatch is running.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><methodname>elapsedTime</methodname></term>
                        <listitem>
                            <para>
                                Returns the elapsed time in milliseconds.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </refsect2>
        </refsect1>
        <refsect1 id="rdogui3_ui_ElapsedTimeDisplay">
            <title id='rdogui3_ui_ElapsedTimeDisplay_title'>ElapsedTimeDisplay</title>
            <para>
                Makes use of a
                <link linkend='rdogui3_ui_StopWatch'
                      endterm='rdogui3_ui_StopWatch_title' /> to provide
                a visual elapsed time megawidget.  This is normally used by
                the ReadoutGUI to provide a visual indication of the elapsed active
                time within a data taking run.  The stopwatch methods are
                exposed so that given one  of these widgets anything that can
                be done to a stopwatch can be done to it.
            </para>
            <para>
                Within the context of the ReadoutGUI, a singleton object is
                available which hooks a callout bundle to the state machine
                singleton to ensure that the timer starts, stops and
                resets at the appropriate time.
            </para>
            <para>
                Application code can get access to this singleton by
            </para>
            <informalexample>
                <programlisting>
set <replaceable>elapsedTime</replaceable> [::ElapsedTime::getInstance]
                </programlisting>
            </informalexample>
            <para>
                This is typically done when application code wants to perform
                an action at a specific elapsed run time (alamr).  For example,
                timed runs are implemented by setting an alarm for the desired
                length of the run.  The alarm proc simply forces a state transition
                to <literal>Halted</literal>.
            </para>
        </refsect1>
        <refsect1 id='rdogui3_ui_TimedRunControls'>
            <title id='rdogui3_ui_TimedRunControls_title'>TimedRunControls</title>
            <para>
                <classname>TimedRunControls</classname> is a megawidget that
                allows user to specify timed run durations and to enable/disable
                timed runs.  A singleton is implemented which hooks itself into
                both the State machine singleton (via a callback bundle)
                and the Elapsed time singelton (via alarms) when a timed
                run is begin.
            </para>
            <refsect2>
                <title>OPTIONS</title>
                <para>
                    The <classname>TimedRunControls</classname> megawidget
                    provides the standard <methodname>configure</methodname>
                    and <methodname>cget</methodname> methods that
                    operate on the following options:
                </para>
                <variablelist>
                    <varlistentry>
                        <term><option>-state</option> <replaceable>disabled | normal | readonly</replaceable></term>
                        <listitem>
                            <para>
                                Controls the appearance and ability of the user to
                                interact with the controls.   <literal>normal</literal>
                                provides a 'normal' ui appearance and allows
                                users to interact with the widget, changing values.
                                <literal>readonly</literal> provides a normal appearance
                                but the user cannot change the values of the widget.
                                <literal>disabled</literal> ghosts the controls
                                and prevents user interaction.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><option>-timed</option> <replaceable>boolean</replaceable></term>
                        <listitem>
                            <para>
                                If <literal>true</literal> the timed run checkbox
                                is checked if <literal>false</literal> it is not
                                checked.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><option>-days</option> <replaceable>integer</replaceable></term>
                        <term><option>-hours</option> <replaceable>integer [0-23]</replaceable></term>
                        <term><option>-minutes</option> <replaceable>integer [0-59] </replaceable></term>
                        <term><option>-seconds</option> <replaceable>integer [0-52]</replaceable></term>
                        <listitem>
                            <para>
                                Specifies the desired active duration of the
                                run when a timed run is performed.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </refsect2>
            <refsect2>
                <title>SINGLETON IMPLEMENTATION</title>
                <para>
                    The ReadoutGUI/ReadoutShell manages access to the
                    timed run instance it uses via the singleton pattern.
                    If your extensions to ReadoutShell need access
                    to the duration they can access the singleton
                    via <function>::TimedRun::getInstance</function>.
                    
                </para>
                <para>
                    The code fragment below turns on timed runs and sets the
                    duration to 2hours:
                </para>
                <informalexample>
                    <programlisting>
[::TimedRun::getInstance] configure -timed true \
    -days 0 -hours 2 -minutes 0 -seconds 0
                    </programlisting>
                </informalexample>
            </refsect2>
        </refsect1>
        <refsect1 id='rdogui3_ui_OutputWindow'>
            <title id='rdogui3_ui_OutputWindow_title'>OutputWindow</title>
            <para>
                The <classname>OutputWindow</classname> megawidget is a megawidget
                that is based on a Tk
                <ulink url='http://www.tcl.tk/man/tcl8.5/TkCmd/text.htm'><command>text</command></ulink>
                widget coupled to vertical and horizontal scroll bars.  As
                the name implies, while the <command>text</command> widget
                can be used for input and output, the <classname>OutputWindow</classname>
                is intended only for output.  
            </para>
            <para>
                The ReadoutGUI/ReadoutShell uses an <classname>OutputWindow</classname>
                to report output from data sources as well as to inform the user
                of various events (e.g state transitions).  The <command>text</command>
                widget is a very complex entity.  The <classname>OutputWindow</classname>
                has a much simpler programmatic interface.
            </para>
            <para>
                Before providing the reference information, it is worth pointing
                out that the <classname>OutputWindow</classname> as support for
                log like  messages.  A log message is a message that has a severity.
                Log messages are automatically output with timestamps.  It is
                possible to instruct the <classname>OutputWindow</classname>
                to render differnet severities using different renditions.
                It is also possible to suppress the display of some message
                severities.  The log capabilitie is used extensively by the
                ReadoutGUI/ReadoutShell.  It is also possible to make the
                <classname>OutputWindow</classname> record all output
                to a log file for later review and analysis.
            </para>
            <para>
                The <classname>OutputWindow</classname> megawidget has
                a singleton associated with the instance that is used by the
                ReadoutGUI.  There is also a state machine singleton
                callout bundle that is used to log state transition
                messages.
            </para>
            <refsect2>
                <title>OPTIONS</title>
                <para>
                    <classname>OutputWindow</classname> instances support
                    the usual <methodname>configure</methodname> and
                    <methodname>cget</methodname> operations to interact with
                    configuration options.   The configuration options supported
                    are:
                </para>
                <variablelist>
                    <varlistentry>
                        <term><option>-foreground</option>   <replaceable>color-spec</replaceable></term>
                        <listitem>
                            <para>
                                Specifies the default text color.  The <parameter>color-spec</parameter>
                                can be  a color name recognized by Tk or it can
                                be an #rrggbb color value.  This option is
                                actually delegated directly to the underlying
                                <command>text</command> widget without
                                interpretation.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><option>background</option> <replaceable>color-spec</replaceable></term>
                        <listitem>
                            <para>
                                Specifies the background color of the
                                <classname>OutputText</classname> <command>text</command>
                                widget.  This is passed without interpretation to
                                the <command>text</command> widget.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><option>-width</option> <replaceable>characters-wide</replaceable></term>
                        <term><option>-height</option> <replaceable>lines-tall</replaceable></term>
                        <listitem>
                            <para>
                                Specifies the width and height of the
                                <command>text</command> widget in characters.
                                These options are passed without interpretation
                                to the <command>text</command> widget.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><option>-history</option> <replaceable>lines</replaceable></term>
                        <listitem>
                            <para>
                                The number of lines of historical data that are
                                kept in the scrolling buffer.  If the number
                                of output lines exceeds <replaceable>lines</replaceable>,
                                the oldest lines are removed from the history
                                until the number of lines remaining is at most
                                <replaceable>lines</replaceable>.
                            </para>
                            <para>
                                The default value for this is <literal>1000</literal>.
                                Note that log files do not have a line limit other
                                than the amount of disk space available.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><option>-logclasses</option> <replaceable>list-of-severities</replaceable></term>
                        <listitem>
                            <para>
                                Determines the set of legal logging classes
                                (severities) that are accepted by the
                                log message (see METHODS below).  This, in
                                addition to the value of <option>-showclass</option>
                                (see below) determine how log messages are handled
                                by the output widget.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><option>-monitorcmd</option> <replaceable>script</replaceable></term>
                        <listitem>
                            <para>
                                Provides a script that is invoked whenever output is added to
                                the window.  The ouptut is appended quoted into
                                a single word at the end of the <replaceable>script</replaceable>.
                            </para>
                        </listitem>
                    </varlistentry>
                    
                    <varlistentry>
                        <term><option>-showlog</option> <replaceable>dict-of-option-lists</replaceable></term>
                        <listitem>
                            <para>
                                Determines for each log class value in the
                                <option>-logclasses</option> option what is
                                done with messages submitted with that log class.
                                Note that changes to this value affect the display
                                of old log messages with the exception of suppressed
                                classes which will only display new entries.
                            </para>
                            <para>
                                The form of the value for this option is a dict
                                with keys that are log classes defined
                                in the <option>-logclasses</option> option value.
                                The values are lists of tag options as defined
                                <ulink url='http://www.tcl.tk/man/tcl8.5/TkCmd/text.htm#M26'>
                                    TAGS section of the Tcl/Tk text widget manpage </ulink>.
                                These options are applied to log entries with these
                                classes.
                            </para>
                            <para>
                                If a log class is omitted fromthe dict it will
                                not be displayed.  One use for this is to provide
                                a <literal>debug</literal> log class for debugging
                                information which can be suppressed by omitting
                                it from the <option>-showlog</option> dict.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
                    
            </refsect2>
            <refsect2>
                <title>METHODS</title>
                <para>
                    This section describes the public methods for the
                    <classname>OutputWindow</classname> widget.
                </para>
                <variablelist>
                    <varlistentry>
                        <term><methodname>puts</methodname> <option>?-nonewline?</option> <parameter>message</parameter></term>
                        <listitem>
                            <para>
                                Outputs <parameter>message</parameter> to the
                                <classname>OutputWindow</classname> displaying it
                                using the current values of
                                the <option>-foreground</option> and
                                <option>-background</option> options to determine
                                the text's rendition.
                            </para>
                            <para>
                                If the optional <option>-nonewline</option> is
                                provided, the text is not output with
                                a trailing newline.  This can be used to
                                build up a one-line message in several
                                <methodname>puts</methodname> calls.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><methodname>log</methodname> <parameter>class message</parameter></term>
                        <listitem>
                            <para>
                                Creates and outputs a log <parameter>message</parameter>.
                                <parameter>class</parameter> determines
                                the rendition of the message via
                                the values of the <option>-showlog</option>
                                option.  It is an error for <parameter>class</parameter>
                                to be a value not in the <option>logclasses</option>
                                option value.
                            </para>
                            <para>
                                The <parameter>messge</parameter> is output
                                preceded by a timestamp and class name.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><methodname>clear</methodname></term>
                        <listitem>
                            <para>
                                Clears the contents of the window.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><methodname>get</methodname></term>
                        <listitem>
                            <para>
                                Returns the textual contents of the window.
                                Note that no hints are provided to enable the
                                caller to determine the rendition of the text.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><methodname>open</methodname> <parameter>filename</parameter></term>
                        <listitem>
                            <para>
                                Opens the file <parameter>filename</parameter> as
                                an output log file.  From this point on all
                                output (<methodname>log</methodname> and
                                <methodname>puts</methodname>)
                                to the <classname>OutputWindow</classname> will be
                                recorded in that file.
                            </para>
                            <para>
                                The file is opened for append.  If there was
                                a previously open log file it is closed first.
                                See <methodname>close</methodname> below.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><methodname>close</methodname></term>
                        <listitem>
                            <para>
                                Closes any open log file.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>                    
            </refsect2>
            <refsect2>
                <title>SINGLETON IMPLEMENTATION</title>
                <para>
                    The application level singleton is implemented via the
                    <function>::Output::getInstance</function> method.
                    This proc is declared as follows:
                </para>
                <informalexample>
                    <programlisting>
proc Output::getInstance { {win {}} args} {
...
}
                    </programlisting>
                </informalexample>
                <para>
                    The <parameter>win</parameter> parameter is required only
                    on the first call and is the window path to be used for
                    the object.  Similarly any trailing parameters to the
                    first invocation contain configuration option/value pairs.
                    Creation register the run state machine callout bundle that
                    maintains the foreground/background appearance of the window
                    as runs start and stop.
                </para>
                <para>
                    The proc returns the widget path.
                </para>
            </refsect2>
        </refsect1>
        
      </refentry>
      <refentry id="rdogui3_outputwindowsettings">
        <refmeta>
           <refentrytitle id='rdogui3_outputwindowsettings_title'>OutputWindowSettings</refentrytitle>
           <manvolnum>3rdogui</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>OutputWindowSettings</refname>
           <refpurpose>Prompter for <classname>OutputWindow</classname> settings.</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
          <command>
OutputWindowSettings <replaceable>widget-path ?options...?</replaceable>
          </command>
          </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            This megawidget provides a prompter for options that can be applied to
            a
            <link linkend='rdogui3_ui_OutputWindow' endterm='rdogui3_ui_OutputWindow_title' />
            widget.  A convenience proc is also provided that wraps this widget
            in a dialog and, when the user accepts the state of the dialog,
            changes the configuration options of the
            <classname>OutputWindow</classname> singleton appropriately.
           </para>
        </refsect1>
        <refsect1>
           <title>
              OPTIONS
           </title>
           <para>
            The widget accepts the standard <methodname>configure</methodname>
            and <methodname>cget</methodname> methods.  These operate on the
            following set of options:
           </para>
            <variablelist>
             <varlistentry>
                 <term><option>-rows</option> <replaceable>row-count</replaceable></term>
                 <listitem>
                     <para>
                         Sets/gets the number of rows requested from the
                         prompter (this is controlled by a spinbox widget).
                     </para>
                 </listitem>
             </varlistentry>
             <varlistentry>
                 <term><option>-columns</option> <replaceable>column-count</replaceable></term>
                 <listitem>
                     <para>
                         Sets/gets the number of columns requested from the
                         prompter.   This is controlled by a spinbox widget.
                     </para>
                 </listitem>
             </varlistentry>
             <varlistentry>
                 <term><option>-history</option> <replaceable>history-lines</replaceable></term>
                 <listitem>
                     <para>
                         Sets/gets the number of lines of history information
                         requested from the prompter.  This is controlled
                         by a spinbox widget.
                     </para>
                 </listitem>
             </varlistentry>
             <varlistentry>
                 <term><option>-debug</option> <replaceable>1 | 0</replaceable></term>
                 <listitem>
                     <para>
                         Gets/sets the state of the checkbutton widget that is
                         labeled <literal>Show debugging Output</literal>.
                     </para>
                 </listitem>
             </varlistentry>
             
            </variablelist>
        </refsect1>
        <refsect1>
            <title>CONVENIENCE PROC</title>
            <para>
                <function>::Output::promptSettings</function> displays a
                <classname>OutputWindowSettings</classname> widget wrapped in a
                <link linkend='rdogui3_dialogwrapper' endterm='rdogui3_dialogwrapper_title' />.
                If the user clicks <guibutton>Ok</guibutton>, the proc fetches
                the singleton <classname>OutputWindow</classname> and sets its
                options accordingly. 
            </para>
            <para>
                The <literal>Show debugging Output</literal> checkbox is handled
                by making or removing a debug entry in the <classname>OutputWindow</classname>'s
                <option>-showlog</option> dict for the <literal>debug</literal> class.
                The contents of this entry, when present, are empty resulting
                in default text rendition.
            </para>
        </refsect1>
      </refentry>
      
      <refentry id="rdogui3_StatusArea">
        <refmeta>
           <refentrytitle id='rdogui3_StatusArea_title'>StatusArea</refentrytitle>
           <manvolnum>3rdogui</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>StatusArea</refname>
           <refpurpose>Status area megawidget</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
            <command>
StatusArea <replaceable>window-path</replaceable>
          </command>
          </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            <classname>StatusArea</classname> is a megawidget that is a container
            for status items.  Status items, sometimes called
            <firstterm>status bars</firstterm> are arranged as a set of vertically
            stacked widgets inside the <classname>StatusArea</classname>.
           </para>
           <para>
            In most but not all cases, status items will be simple label
            widgets intended to provide textual information about the status
            of some facet of the program.  The <classname>StatusArea</classname>
            provides methods that simplify the creation and management of these
            labels.
           </para>
           <para>
            A singleton implementation is also available.
           </para>
        </refsect1>
        <refsect1>
           <title>
              METHODS
           </title>
           <variablelist>
            <varlistentry>
                <term><methodname>addWidget</methodname> <parameter>args</parameter></term>
                <listitem>
                    <para>
                        This adds an arbitrary widget to the status area.
                        The <parameter>args</parameter> should be a widget creation
                        command without the window path (This gets generated by
                        <methodname>addWigdget</methodname>).  For example:
                    </para>
                    <informalexample>
                        <programlisting>
$statusBar addWidget checkbutton -onvalue 1 -offvalue 0 -variable myvar -text {A checkbutton}
                        </programlisting>
                    </informalexample>
                    <para>
                        Adds a checkbutton control to the status bar.  To add
                        frames containing multiple widgets to the status bar,
                        create a megawidget (with snit or itk for example) and
                        pass the megawidget constructor name to the
                        <methodname>addWidget</methodname> method.
                    </para>
                    <para>
                        The widget will be added to the bottom of the status
                        area.  The actual widget path is returned by
                        this method.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><methodname>addMessage</methodname> <parameter>?initial-text?</parameter></term>
                <listitem>
                    <para>
                        Adds a message to the bottom of the status window.
                        Messages are implemented as label widgets.
                        If provided the optional
                        <parameter>initial-text</parameter> argument is the
                        text initially displayed by the widget.
                    </para>
                    <para>
                        The method returns a <firstterm>message handle</firstterm>.
                        The message handle is <emphasis>not</emphasis> the widget
                        path of the label widget.  It can be used in other
                        message related methods (e.g. <methodname>addMessage</methodname>)
                        however.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><methodname>setMessage</methodname> <replaceable>handle text args</replaceable></term>
                <listitem>
                    <para>
                        Changes the message text displayed by the message
                        referred to by <parameter>handle</parameter> to
                        <parameter>text</parameter>.  If additional parameters
                        are supplied the must be option/value pairs that are
                        valid for configuring a
                        <ulink url='http://www.tcl.tk/man/tcl8.5/TkCmd/ttk_label.htm'>
                            ttk::label
                        </ulink>
                        widget.
                    </para>
                    <para>
                        The example below creates a message widget and
                        outputs some text in it colored green:
                    </para>
                    <informalexample>
                        <programlisting>
set msg [$status addMessage]
$status setMessage $msg {Some text} -foreground green
                        </programlisting>
                    </informalexample>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><methodname>statusItems</methodname></term>
                <listitem>
                    <para>
                        Returns a list of the widget paths that
                        of the widgets in the status area.  This includes
                        the message widgets as well as the other widgets you
                        may have added with <methodname>addMessage</methodname>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><methodname>messageHandles</methodname></term>
                <listitem>
                    <para>
                        Slightly mis-named method returns the widget paths
                        of the <command>ttk::label</command> widgets
                        created by the <methodname>addMessage</methodname>
                        command.
                    </para>
                </listitem>
            </varlistentry>
            
           </variablelist>
        </refsect1>
        <refsect1>
            <title>SINGLETON IMPLEMENTATION</title>
            <para>
                <function>::StatusBar::getInstance</function> returns the
                widget path for the singleton status area widget.
                The first time it is called, the otherwise optional
                widget path for the status area must be passed in, and
                the actual <classname>StatusArea</classname> widget
                will be created.
            </para>
        </refsect1>
      </refentry>

<!-- /manpage -->
<!-- manpage 3provider -->
      <refentry id="provider3_intro">
        <refmeta>
           <refentrytitle id='provider3_intro_title'>Introduction</refentrytitle>
           <manvolnum>3provider</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>Introduction</refname>
           <refpurpose>Data source providers</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
              <command>
package provide <replaceable>providerName</replaceable>_Provider <replaceable>version-string</replaceable>
          </command>
          </cmdsynopsis>
            <cmdsynopsis>
                <command>
namespace eval <replaceable>providerName</replaceable> {...}
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
proc ::<replaceable>providerName</replaceable>::parameters {} {...}
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
proc ::<replaceable>providerName</replaceable>::start params {...}
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
proc ::<replaceable>providerName</replaceable>::check sourceId {...}
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
proc ::<replaceable>providerName</replaceable>::stop sourceId {...}
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
proc ::<replaceable>providerName</replaceable>::begin {sourceId runNumber title} {...}
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
proc ::<replaceable>providerName</replaceable>::pause sourceId {...}
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
proc ::<replaceable>providerName</replaceable>::resume sourceId {...}
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
proc ::<replaceable>providerName</replaceable>::end sourceId {...}
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
proc ::<replaceable>providerName</replaceable>::capabilities {} {...}
                </command>
            </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            Data source providers are Tcl loadable packages that provide
            code that understands how to maniuplate a specific type of
            data source.  NSCLDAQ comes with two pre-built data source providers;
            <link linkend="provider3_sshpipe" endterm='provider3_sshpipe_title' />
            which understands how to run command line readout programs on the end
            of a SSH pipeline to a (possibily) remote system, and
            <link linkend='provider3_s800' endterm='provider3_s800_title' /> which
            knows how to connect to and send appropriate commands to the
            S800 data acquisition readout program.
           </para>
           <para>
            If a Source provider supplies the code for a type of data source,
            a specific data source is identified by a <parameter>sourceId</parameter>
            this is assigned by the code that creates data sources.  In general
            while it's a good idea to define data source ids that are unique across
            all data source providers (that's what the ReadoutGUI data source
            manager does), it is only required that source ids be unique within
            a specific provider.
           </para>
           <para>
            This section of man pages provides:
            <itemizedlist>
                <listitem><para>Reference material on the API a data source provider must export.</para></listitem>
                <listitem><para>Reference information that describes the SSHPipe provider.</para></listitem>
                <listitem><para>Reference information that describes the S800 provider.</para></listitem>
            </itemizedlist>
           </para>
        </refsect1>
        <refsect1>
           <title>
              CREATING A DATA SOURCE PROVIDER
           </title>
           <para>
                Data source providers are Tcl packages with names that end in
                <literal>_Provider</literal> for example, the SSHPipe provider
                is a package named <literal>SSHPipe_Provider</literal>. The
                section of the package name before the trailing <literal>_Provider</literal>
                is called the <emphasis>provider name</emphasis>.
           </para>
           <para>
                Data source providers are expected to define a specific set
                of named procedures in a namespace that matches their
                provider name.   Thus the SSHPipe provider defines procs in the
                <literal>::SSHPipe::</literal> namespace.  These procs need not
                be exported from the namespace.
           </para>
           <para>
            The code fragment below shows a simplified version of how the
            package and namespace are defined and a definition for the
            <literal>parameters</literal> proc is made within that namespace
           </para>
           <informalexample>
            <programlisting>
package provide MyDataSource_Provider 1.0 

namespace eval ::MyDataSource {}

proc ::MyDataSource::parameters {} {
  # Actual implementation omitted
  #  ...
}
            </programlisting>
           </informalexample>
           <para>
            While only the API functions described in this manpage need to be
            in the provider's namespace, it is good programming practice to
            put any utility functions either in that namespace or in some
            other namespace that is specific to the data source provider
            (e.g.  <replaceable>providerName</replaceable>_private).
            This minimizes the chances that your definitions will re-define
            some previously defined proc in the global namespace.
           </para>
           <para>
            For information on Tcl namespaces, see the documentation for the
            <ulink url='http://www.tcl.tk/man/tcl8.5/TclCmd/namespace.htm'>
                Tcl namespace command</ulink>.
           </para>
        </refsect1>
        <refsect1>
            <title>API FUNCTIONS</title>
            <para>
                This section provides a brief overview of each API function
                a data provider must implement along with a pointer to the
                detailed documentation for that function.  In the documentation
                below, the namespace for the API function is omitted for the sake
                of brevity.
            </para>
            <variablelist>
                <varlistentry>
                    <term><command>parameters</command></term>
                    <listitem>
                        <para>
                            Each data source a data source provider starts may
                            require some parameterization.  For example, the
                            S800 provider needs to know the host on which the
                            S800 readout program is running along with the
                            TCP/IP port on which that program is listening for
                            command connections.
                            <link linkend='provider3_parameters'
                                  endterm='provider3_parameters_title' />
                            returns information about the parameterization of
                            the provider.  The information returned is sufficient
                            for calling code to produce a very simple prompter
                            for those parameters.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>start</command> <replaceable>params</replaceable></term>
                    <listitem>
                        <para>
                            The <command>start</command> command of a data source
                            provider start a data source given a specific
                            parameterization.
                            The
                            <link linkend='provider3_start'
                                  endterm='provider3_start_title' />
                            describes this command.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>check</command> <replaceable>sourceId</replaceable></term>
                    <listitem>
                        <para>
                            Whatever code is managing a set of data providers
                            needs to know when one of the active sources
                            has exited.
                            <link linkend='provider3_check'
                                  endterm='provider3_check_title' />
                            returns a true value if a source is still running and
                            false if not.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>stop</command> <replaceable>sourceId</replaceable></term>
                    <listitem>
                        <para>
                            <link linkend='provider3_stop'
                                  endterm='provider3_stop_title' />
                            Stops the specified data source.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>begin</command> <replaceable>sourceId runNumber title</replaceable></term>
                    <listitem>
                        <para>
                            Starts data taking for a new run.
                            See <link linkend='provider3_begin'
                                endterm='provider3_begin_title' />
                            for reference information.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>pause</command> <replaceable>sourceId</replaceable></term>
                    <listitem>
                        <para>
                            If your data source implements pause/resume functionality
                            you must define this command to pause the run.
                            See the 
                            <link linkend='provider3_pause'
                                  endterm='provider3_pause_title' />
                            reference material for more information.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>resume</command> <replaceable>sourceId</replaceable></term>
                    <listitem>
                        <para>
                            If your data source implements pause/resume functionality
                            you must implement
                            <link linkend='provider3_resume'
                                  endterm='provider3_resume_title' />
                            to resume paused runs.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>end</command> <replaceable>sourceId</replaceable></term>
                    <listitem>
                        <para>
                            The
                            <link linkend='provider3_end'
                                  endterm='provider3_end_title' />
                            ends a run in a data source.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>capbilities</command></term>
                    <listitem>
                        <para>
                            Describes the data
                            <link linkend='provider3_capabilities'
                                  endterm='provider3_capabilities_title' />
                            source capabilities.  
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </refsect1>
      </refentry>

      <refentry id="provider3_parameters">
        <refmeta>
           <refentrytitle id='provider3_parameters_title'>parameters</refentrytitle>
           <manvolnum>3provider</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>parameters</refname>
           <refpurpose>Describe data source parameterization</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
              <command>
proc ::<replaceable>providerName</replaceable>::parameters {} {
  ...
}
          </command>
          </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            Each data source managed by a data source provider is specified
            by means of some set of data source specific parameters.
            The <command>parameters</command> proc of each data source
            returns a Tcl
            <ulink url='dict'>dict</ulink> that describes the set of parameters
            expected.
           </para>
           <para>
            The keys of the dict are short parameter names (used by the
            data source to look up the parameter in the dict).  The value
            of each dict element is is a human-readable description of the
            parameter.  Normally a graphical user interface would use this
            string to prompt the user for a value.
           </para>
        </refsect1>

      </refentry>
      <refentry id="provider3_start">
        <refmeta>
           <refentrytitle id='provider3_start_title'>start</refentrytitle>
           <manvolnum>3provider</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>start</refname>
           <refpurpose>Start a data source</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
              <command>
::<replaceable>providerName</replaceable>::start <replaceable>param-dict</replaceable>
          </command>
          </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            Starts a data source for the provider.   The
            <parameter>param-dict</parameter> parameter is a Tcl
            <ulink url='dict'>dict</ulink>.  The keys for the dict are the
            same as the keys for the dict returned from
            <link linkend='provider3_parameters'
                  endterm='provider3_parameters_title' />.
            Key values are the parameter values.  An additional key
            <literal>sourceid</literal> is always added to this dict and it
            represents a unique identifier that will be used
            to refer to this data source from now on.
           </para>
        </refsect1>
 
      </refentry>
      <refentry id="provider3_check">
        <refmeta>
           <refentrytitle id='provider3_check_title'>check</refentrytitle>
           <manvolnum>3provider</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>check</refname>
           <refpurpose>Check Data Source Liveness</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
              <command>
proc ::<replaceable>providerName</replaceable>::check <replaceable>sourceId</replaceable> {
...
}
          </command>
          </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            The <command>check</command> proc can be called once a data source
            has been started.  The <parameter>sourceId</parameter> parameter is
            the value of the <literal>sourceid</literal> dict element passed to the
            <link linkend='provider3_start' endterm='provider3_start_title' />
            command.
           </para>
           <para>
            This command should return a boolean true value if the data source
            identified by <parameter>sourceId</parameter> is still running or
            a boolean false value if the data source is no longer running.
            Boolean values are those accepted by the C function
            <ulink url='http://www.tcl.tk/man/tcl8.5/TclLib/GetInt.htm'>
                Tcl_GetBoolean</ulink>.
           </para>
        </refsect1>

      </refentry>
      <refentry id="provider3_stop">
        <refmeta>
           <refentrytitle id='provider3_stop_title'>stop</refentrytitle>
           <manvolnum>3provider</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>stop</refname>
           <refpurpose>Stop data sources</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
            <command>
proc ::<replaceable>providername</replaceable>::stop <replaceable>sourceId</replaceable> {
...
}
          </command>
          </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            Called to stop the data source identified by
            <parameter>sourceId</parameter>.
            The <parameter>sourceId</parameter> parameter is
            the value of the <literal>sourceid</literal> dict element passed to the
            <link linkend='provider3_start' endterm='provider3_start_title' />
            command.
           </para>
           <para>r
            Once this command is executed, the data source provider should invalidate
            the <parameter>sourceId</parameter>, and take whatever steps are needed
            to release any resources the data source has used.
           </para>
        </refsect1>

      </refentry>
      <refentry id="provider3_begin">
        <refmeta>
           <refentrytitle id='provider3_begin_title'>begin</refentrytitle>
           <manvolnum>3provider</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>begin</refname>
           <refpurpose>Start data taking in a data source</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
            <command>
proc ::<replaceable>providerName</replaceable>::begin {sourceId runNumber title} {
...
}
          </command>
          </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            Starts data taking at the beginning of a run for the
            source identified by <parameter>sourceId</parameter>.  The
            <parameter>runNumber</parameter> and <parameter>title</parameter>
            parameters are the run number and title of the run.  They
            can be ignored if the data source has specified that it does not
            have the capability of associatig run numbers and titles with
            data taking runs.
           </para>
           <para>
            The <parameter>sourceId</parameter> parameter is, as usual,
            the value of the <literal>sourceid</literal> dict element passed to the
            <link linkend='provider3_start' endterm='provider3_start_title' />
            command.
           </para>
        </refsect1>

      </refentry>
      <refentry id="provider3_pause">
        <refmeta>
           <refentrytitle id='provider3_pause_title'>pause</refentrytitle>
           <manvolnum>3provider</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>pause</refname>
           <refpurpose>Pause a data taking run (optional)</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
              <command>
proc ::<replaceable>providerName</replaceable>::pause <replaceable>sourceId</replaceable> {
...
}
          </command>
          </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            Pauses a data taking run in the data source identified by
            <parameter>sourceId</parameter>.
            The <parameter>sourceId</parameter> parameter is
            the value of the <literal>sourceid</literal> dict element passed to the
            <link linkend='provider3_start' endterm='provider3_start_title' />
            command.
           </para>
           <para>
            This proc is optional.  Specifically, if the data source provider's
            <link linkend='provider3_capabilities'
                  endterm='provider3_capabilities_title' /> specifies  the
            provider is unable to pause runs, the provider need not implement
            either this proc or the
            <link linkend='provider3_resume' endterm='provider3_resume_title' />
            proc.  Similarly, the data source manager should not invoke the
            <command>pause</command> or <command>resume</command> commands on
            data sources that cannot support it.
           </para>
           <para>
            The ReadoutGUI data source manager and GUI will prevent an invocation
            of the <command>pause</command> and <command>resume</command>
            operations on any data of the data sources
            unless all data sources specified able to perform these
            operations.
            </para>
        </refsect1>

      </refentry>
      <refentry id="provider3_resume">
        <refmeta>
           <refentrytitle id='provider3_resume_title'>resume</refentrytitle>
           <manvolnum>3provider</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>resume</refname>
           <refpurpose>Resume a Paused Run</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
              <command>
proc ::<replaceable>providerName</replaceable>::resume <replaceable>sourceId</replaceable> {
...
}
          </command>
          </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            Resumes a run that is paused in the data source identified by
            <parameter>sourceId</parameter>.
            This proc is optional.  Specifically, if the data source provider's
            <link linkend='provider3_capabilities'
                  endterm='provider3_capabilities_title' /> specifies  the
            provider is unable to pause runs, the provider need not implement
            either this proc or the
            <link linkend='provider3_pause' endterm='provider3_pause_title' />
            proc.  Similarly, the data source manager should not invoke the
            <command>pause</command> or <command>resume</command> commands on
            data sources that cannot support it.
           </para>
           <para>
            The ReadoutGUI data source manager and GUI will prevent an invocation
            of the <command>pause</command> and <command>resume</command>
            operations on any data of the data sources
            unless all data sources specified able to perform these
            operations.
           </para>
        </refsect1>
      </refentry>
      <refentry id="provider3_end">
        <refmeta>
           <refentrytitle id='provider3_end_title'>end</refentrytitle>
           <manvolnum>3provider</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>end</refname>
           <refpurpose>End a Data Taking Run</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
              <command>
proc ::<replaceable>providerName</replaceable>::end <replaceable>sourceId</replaceable> {
...
}
          </command>
          </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            Ends a data taking run in the data source <parameter>sourceId</parameter>.
            The <parameter>sourceId</parameter> is the value of the
            <literal>sourceid</literal> key in the dict passed to the
            provider's
            <link linkend='provider3_start' endterm='provider3_start_title' />
            <command>start</command> proc was called to start the data source.
           </para>
        </refsect1>

      </refentry>
      <refentry id="provider3_capabilities">
        <refmeta>
           <refentrytitle id='provider3_capabilities_title'>capabilities</refentrytitle>
           <manvolnum>3provider</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>capabilities</refname>
           <refpurpose>Get Provider Capabilities Dict</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
              <command>
proc ::<replaceable>providerName</replaceable>::capabilities {} {
...
}
          </command>
          </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            Not all data source providers are created equal.  This command
            is expected to return a dict that describes the data source's
            capabilities.  The keys to this dict are capability names.
            The values generally are booleans that indicate whether that
            capability is supported.
           </para>
        </refsect1>
        <refsect1>
            <title>CAPABILITIES</title>
            <para>
                At present the following capabilities are defined:
            </para>
            <variablelist>
                <varlistentry>
                    <term><literal>canPause</literal></term>
                    <listitem>
                        <para>
                            If true the provider implements the
                            <command>pause</command> and
                            <command>resume</command> procs and they
                            do what they are advertised to do.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>runsHaveTitles</literal></term>
                    <listitem>
                        <para>
                            If true the provider will honor the
                            <parameter>title</parameter> parameter passed to the
                            <link linkend='provider3_begin'
                                  endterm='provider3_begin_title' />
                            command.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>runsHaveNumbers</literal></term>
                    <listitem>
                        <para>
                            If true the provider will honer the
                            <parameter>runNumber</parameter> parameter
                            passed to the
                            <link linkend='provider3_begin'
                                  endterm='provider3_begin_title' />
                            command.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </refsect1>
      </refentry>
      
      <refentry id="provider3_sshpipe">
        <refmeta>
           <refentrytitle id='provider3_sshpipe_title'>SSHPipe</refentrytitle>
           <manvolnum>3provider</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>SSHPipe</refname>
           <refpurpose>SSHPipe data source provider.</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
              <command>
package require SSHPipe_Provider
          </command>
          </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            The <literal>SSHPipe_Provider</literal> implements a
            data source provider (see
            <link linkend='provider3_intro' endterm='provider3_intro_title' />)
            that controls command driven programs on the end of an SSH Pipe
            into a remote (or local) system.
           </para>
           <para>
            To use the ssh pipe provider:
           </para>
           <orderedlist>
            <listitem><para>NSCLDAQ-11.x must be installed on the target system
                in the same installation directory try as in the host system.
                </para></listitem>
            <listitem><para>The path to the remote program must be valid on the remote system.
                For the most part this works best when the local and remote systems
                share filesystems.
                </para></listitem>
            <listitem><para>Password-less logins have been set up between
                the local and remote systems.  A procedure for this can be
                found by googling <literal>ssh without password</literal>.
                One hit that is valid as of today is:
                <ulink url='http://www.thegeekstuff.com/2008/11/3-steps-to-perform-ssh-login-without-password-using-ssh-keygen-ssh-copy-id/'>
                       http://www.thegeekstuff.com/2008/11/3-steps-to-perform-ssh-login-without-password-using-ssh-keygen-ssh-copy-id/
                </ulink>
                </para></listitem>
           </orderedlist>
        </refsect1>
        <refsect1>
           <title>
              PARAMETERIZATION
           </title>
           <para>
            The parameters required for the <literal>SSHPipe</literal> data source
            provider are:
           </para>
           <variablelist>
            <varlistentry>
                <term><literal>host</literal></term>
                <listitem>
                    <para>
                        The host on which the readout runs.  The readout
                        host must resolve via DNS or alternatively
                        can be a dotted IP number.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><literal>path</literal></term>
                <listitem>
                    <para>
                        The full path to the Readout program in the remote host.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><literal>wdir</literal></term>
                <listitem>
                    <para>
                        The working directory in the remote host
                        desired for the readout program.  This defaults to the
                        remote home directory.  Often, if <replaceable>readoutPath</replaceable>
                        is the path to the readout program, what is desired is:
                        <programlisting>file dirname $readoutPath</programlisting>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><literal>parameters</literal></term>
                <listitem>
                    <para>
                        Parameters that will be passed on the command line
                        to the Readout program when it is run.  For eample for
                        NSCL Readout programs,
                        <literal>--ring=</literal><replaceable>some-non-default-ring</replaceable>
                        is often used.
                    </para>
                </listitem>
            </varlistentry>
            
           </variablelist>
        </refsect1>
        <refsect1>
            <title>READOUT PROGRAM REQUIREMENTS</title>
            <para>
                Readout programs are sent specific commands in specific ways.
                This places
                the following requirements on Readout program that will be controlled
                via SSHPipe:
            </para>
            <orderedlist>
                <listitem><para>
                    Readout programs must be command drive and expect comands
                    on their <literal>stdin</literal> file descriptor.
                    </para></listitem>
                <listitem><para>
                    Readout program output you want seen by the user must be
                    sent to either <literal>stdout</literal> or
                    <literal>stderr</literal>
                    </para></listitem>
                <listitem><para>An endfile on the <literal>stdin</literal> pipe
                    must exit the program.
                    </para></listitem>
                <listitem><para>The <command>exit</command> command must exit
                    the program.
                    </para></listitem>
                <listitem><para>The <command>set <replaceable>varname value</replaceable></command>
                    command must be defined for the variables <varname>title</varname>
                    and <varname>run</varname> and set the run number and title
                    accordingly.
                    </para></listitem>
                <listitem><para>The <command>begin</command> command must start
                    a new run.
                    </para></listitem>
                <listitem><para>The <command>end</command> command must end an
                    active run.
                    </para></listitem>
                <listitem><para>The <command>pause</command> command must pause
                    an active run.
                    </para></listitem>
                <listitem><para>The <command>resume</command> command must resume
                     paused run.
                     </para></listitem>
            </orderedlist>
        </refsect1>
        <refsect1>
            <title>TRICKS FOR TICKY READOUTS</title>
            <para>
                If your Readout program meets most of the requirements in the
                section <literal>READOUT PROGRAM REQUIREMENTS</literal> above,
                you may still be able to use the SSHPipe provider by wrapping
                it appropriately.  For example:
            </para>
            <formalpara>
                <title>Readout cannot pause/resume</title>
                
                    <para>
                        Make a new provider that implements all of its API
                        entries by calling the <literal>::SSHPipe::</literal>
                        entry, however your capabilities <command>proc</command>
                        will force the value of the <literal>canPause</literal>
                        capability to false.
                    </para>
            </formalpara>
        </refsect1>
      </refentry>

      <refentry id="provider3_s800">
        <refmeta>
           <refentrytitle id='provider3_s800_title'>s800</refentrytitle>
           <manvolnum>3provider</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>s800</refname>
           <refpurpose>s800 data source provider.</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
              <command>
package require s800
          </command>
          </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            This data source provider provides the command and control over the
            S800 data acquisition system Readout.  The S800 uses a Readout
            program that is an TCP/IP server.
           </para>
           <para>
            Note that the provider only manages the run control of the S800.
            The <filename>s800toring</filename> utility described below must
            be started as well from your <filename>ReadoutCallouts.tcl</filename>
            script. See <literal>S800TORING</literal> below.
           </para>
        </refsect1>
        <refsect1>
           <title>
              PARAMETERIZATION
           </title>
           <variablelist>
                <varlistentry>
                    <term><literal>host</literal></term>
                    <listitem>
                        <para>
                            The IP DNS name or dotted IP address of the
                            host that is running the S800 readout program.
                            Note that this software cannot star the readout program.
                            What it does on a <function>start</function> operation
                            is to connect to an already running readout program.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>port</literal></term>
                    <listitem>
                        <para>
                            The port on which the S800 readout program
                            is listening for connections.
                        </para>
                    </listitem>
                </varlistentry>
                
                
           </variablelist>
        </refsect1>
        <refsect1>
            <title>S800TORING</title>
            <para>
                The S800 Readout program is not an NSCLDAQ readout program.
                It does not put data into ring buffers but instead supplies
                data via a TCP/IP connection.  Furthermore the data format
                is that of NSCLDAQ-8.x.
            </para>
            <para>
                The <literal>s800toring</literal>
                program connects to the S800 data transfer socket,
                translates events into ring items and puts those items into a
                ring buffer from which they can be fetched by other programs.
            </para>
            <para>
                In the sample startup below, we are assuming the existence
                of an environment variable, <literal>DAQROOT</literal>,
                that points to the top level directory of the NSCLDAQ-11
                installation.
            </para>
            <informalexample>
                <cmdsynopsis>
                    <command>
$DAQROOT/bin/s800toring <replaceable>host port ring</replaceable>
                    </command>
                </cmdsynopsis>
            </informalexample>
            <para>
                The <replaceable>host</replaceable> and
                <replaceable>port</replaceable> command line parameters
                are the host and port on which the s800 is listening for event
                service connections (this is not in general the same value
                as the s800 command port).  The <replaceable>ring</replaceable>
                parameter is the name of the ring buffer into which data
                should be placed. If the ring buffer does not yet exist,
                <literal>s800toring</literal>  will create it.
            </para>
        </refsect1>
      </refentry>
                

<!-- /manpage -->
<!-- manpage 1daq -->

      <refentry id="manpage_readoutshell">
        <refmeta>
           <refentrytitle>ReadoutShell</refentrytitle>
           <manvolnum>1daq</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>ReadoutShell</refname>
           <refpurpose>Shell wrapper for readout programs.</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
              <command>
$DAQROOT/bin/ReadoutShell
          </command>
          </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            Provides a graphical use interface wrapper around readout programs.
            This command takes no parameters or options.  It does maintain
            a memory of the most recent configuration for its internal components
            as well as providing a scheme for extensions to add to this configuration.
            See FILES for more information about the configuration.
           </para>
        </refsect1>
        <refsect1>
           <title>
              ENVIRONMENT
           </title>
            <variablelist>
                <varlistentry>
                    <term><literal>EVENTLOGGER</literal></term>
                    <listitem>
                        <para>
                            Overrides the default event logger program with
                            its value.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>EVENTLOGGER_RING</literal></term>
                    <listitem>
                        <para>
                            Overrides the event logger ringbuffer URI.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>EVENTLOGGER_NSRCSFLAGS_SUPPORTED</literal></term>
                    <listitem>
                        <para>
                            If true then <option>--number-of-sources</option>
                            will be used with the eventlog program.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>EVENTLOGGER_UNCONTROLLED_SOURCE_COUNT</literal></term>
                    <listitem>
                        <para>
                            If provided contains an additional source count for
                            use when computing the value of
                            <option>--number-of-sources</option>
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>EVENTLOGGER_USE_GUI_RUNNUM</literal></term>
                    <listitem>
                        <para>
                            If true the <option>--run</option> option will be
                            used to override run numbers in begin run records or,
                            alternatively provide run numbers where none are
                            avaialble.
                        </para>
                    </listitem>
                </varlistentry>
                
            </variablelist>
            
             <variablelist>
                <varlistentry>
                    <term><literal>EVENTS</literal></term>
                    <listitem>
                        <para>
                            The value of this environment variable overrides
                            the Stage area default
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>EXPDIR</literal></term>
                    <listitem>
                        <para>
                            The value of this environment variable overrides
                            the Experiment metadata default value.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
             
             
        </refsect1>
        <refsect1>
            <title>FILES</title>
            <variablelist>
                <varlistentry>
                    <term><filename>~/stagearea</filename></term>
                    <listitem>
                        <para>
                            A symbolic link to the work area used by the ReadoutShell
                            to maintain its directory structure.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><filename>~/stagearea/current</filename></term>
                    <listitem>
                        <para>
                            Directory containing the
                            event file currently being recorded.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><filename>~/stagearea/complete</filename></term>
                    <listitem>
                        <para>
                            Directory containing symbolic links to all
                            event files that have been completely acquired.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><filename>~/stagerea/experiment/run*</filename></term>
                    <listitem>
                        <para>
                            Directories containing event files and metadata
                            for all completely acquired runs.  The wild-carded
                            part of the directory string is the run number, e.g.
                            <filename>~/stagerea/experiment/run1234</filename>
                            contains the event file and metadata for run
                            number <literal>1234</literal>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><filename>~/stagearea/experiment/current</filename></term>
                    <listitem>
                        <para>
                            Directory containing the metadata for the current run.
                            The data in this directory will be copied into the
                            run directory at the end of the run.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><filename>~/stagearea/.settings.tcl</filename></term>
                    <listitem>
                        <para>
                            File from which saved settings are restored
                            and into which saved settings are written.
                            This file is just a bunch of Tcl
                            <command>set</command> commands that are
                            read/written by
                            the
                            <link linkend='rdogui3_statemanager'
                                  endterm='rdogui3_statemanager_title' />
                            via its singleton implementation.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><filename>ReadoutCallouts.tcl</filename></term>
                    <listitem>
                        <para>
                            File that contains extensions to the ReadoutShell.
                            This file is searched for in order in:
                            <filename>~</filename>,
                            <filename>!/stagearea/experiment/currnet</filename>
                            and the current worknig directory.  The first found
                            file and only the first of these is loaded.
                        </para>
                    </listitem>
                </varlistentry>
                
            </variablelist>
        </refsect1>
      </refentry>
        <refentry id="rdogui3_readoutguioutputclient">
          <refmeta>
             <refentrytitle id="rdogui3_readoutguioutputclient_title">ReadoutGUIOutputClient</refentrytitle>
             <manvolnum>3rdogui</manvolnum>
          </refmeta>
          <refnamediv>
             <refname>ReadoutGUIOutputClient</refname>
             <refpurpose>Readout gui output monitor client.</refpurpose>
          </refnamediv>
          
          <refsynopsisdiv>
            <cmdsynopsis>
                <command>
ReadoutGUIOutputClient <replaceable>name ?options?</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>name method params</replaceable>                    
                </command>
            </cmdsynopsis>

          </refsynopsisdiv>
          <refsect1>
             <title>DESCRIPTION</title>
             <para>
                <classname>ReadoutGUIOutputClient</classname> provides a packaged
                client for the output  monitor for applications that use the event
                loop.  Note that Tcl/Tk applications by default use the event loop.
                When a client object is constructed, it creates a new command ensemble
                whose sub commands are the method names of the object.  The command
                name can either be specified or a unique one can be assigned by
                specifying the special object name <literal>%AUTO%</literal>.
                Regardless the constructor returns the name of the command as its
                result.  Thus e.g.:
             </para>
             <informalexample>
                <programlisting>
set outputMonitor [ReadoutGUIOutputClient %AUTO%]
$outputMonitor configure -host spdaq123.nscl.msu.edu
                </programlisting>
             </informalexample>
             <para>
                is a pretty common pattern.
             </para>
          </refsect1>
          <refsect1>
             <title>
                OPTIONS
             </title>
             <para>
                <classname>ReadoutGUIOutputClient</classname> objects include
                the <command>configure</command> and <command>cget</command>
                commands that manipulate and query configuration options of the
                object.  Normally one configures the object and then invokes
                the <command>connect</command> method to start processing
                data.  See METHODS for more about <command>connect</command>.
             </para>
             <variablelist>
                <varlistentry>
                    <term><option>-host</option></term>
                    <listitem>
                        <para>
                            Specifies the name or IP address of the host that
                            is running the server.  The default value, if not
                            explicitly configured is <literal>localhost</literal>
                            which corresponds to the system running the application.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-user</option></term>
                    <listitem>
                        <para>
                            Specifies the user that is running the server application.
                            If not configured, the default value is the current
                            logged in user; <literal>$::tcl_platform(user)</literal>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>-outputcmd</command></term>
                    <listitem>
                        <para>
                            The value of this option is a script that is executed
                            whenever something was output to the server's output
                            window.  The text that was output is passed as an
                            additional argument to the script.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-closecmd</option></term>
                    <listitem>
                        <para>
                            The value of this option is a script that is executed
                            when the object loses connection with the command server.
                        </para>
                    </listitem>
                </varlistentry>
                
                
             </variablelist>
          </refsect1>
            <refsect1>
                <title>METHODS</title>
                <para>
                    There is only one method <methodname>connect</methodname>
                    it has no additional parameters and should be invoked once
                    the object is configured.  <methodname>connect</methodname>
                    attempts to make the connection with the server and
                    sets up the fileevents to invoke the <option>-outputcmd</option>
                    and <option>-closecmd</option> scripts at appropriate times.
                </para>
                <para>
                    Failures result in an error signal.
                </para>
            </refsect1>
        </refentry>
      
<!-- /manpage -->